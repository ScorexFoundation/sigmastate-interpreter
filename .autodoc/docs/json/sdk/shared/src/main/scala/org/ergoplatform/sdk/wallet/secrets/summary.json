{
  "folderName": "secrets",
  "folderPath": ".autodoc/docs/json/sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/secrets",
  "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/.autodoc/docs/json/sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/secrets",
  "files": [
    {
      "fileName": "DerivationPath.scala",
      "filePath": "sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/secrets/DerivationPath.scala",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/secrets/DerivationPath.scala",
      "summary": "The code defines a class called `DerivationPath` which represents a hierarchical deterministic (HD) key derivation path. The HD key derivation path is a sequence of integers that represents a path from the root of a tree of keys to a particular key. The class has methods to encode and decode the path as a string, to convert the path to a public or private branch, to find the next available path index for a new key, and to check if the path corresponds to a specific derivation path.\n\nThe `DerivationPath` class has a constructor that takes a sequence of integers and a boolean flag indicating whether the path is from the public or private branch. The class has methods to get the depth of the path, the last element of the path, and whether the path is a master path. The class also has methods to create a new path by extending the current path with a new index, increasing the last element of the path, and converting the path to a public or private branch.\n\nThe `DerivationPath` class has a method to encode the path as a parsable string. The method first checks whether the path is from the public or private branch and adds the appropriate prefix to the string. The method then converts each element of the path to a string and adds a forward slash between each element.\n\nThe `DerivationPath` class has a method to find the next available path index for a new key. The method takes a list of previously generated keys and a boolean flag indicating whether to use pre-EIP3 derivation or not. The method first checks whether there are any keys generated and whether the last key is a master key. If there are no keys generated or the last key is a master key, the method returns the first key in the specified derivation path. If the last key corresponds to the EIP-3 derivation path, the method returns a new path with the last element increased by one. Otherwise, the method finds the maximum index of the last non-hardened segment of each key and returns a new path with the last non-hardened segment increased by one.\n\nThe `DerivationPath` class has a method to check whether the path corresponds to the EIP-3 derivation path. The method checks whether the tail of the path matches the first three elements of the EIP-3 derivation path.\n\nThe `DerivationPath` class has a method to convert the path to a byte array using a `DerivationPathSerializer`. The `DerivationPathSerializer` is a Sigma serializer that serializes the path as a sequence of bytes. The `DerivationPathSerializer` has methods to serialize and parse the path.\n\nOverall, the `DerivationPath` class provides a way to represent and manipulate HD key derivation paths. The class can be used in the larger project to generate and manage keys for the Ergo platform. For example, the class can be used to generate new keys for transactions or to manage the keys in a wallet.",
      "questions": "1. What is the purpose of the DerivationPath class?\n- The DerivationPath class represents a hierarchical deterministic (HD) key derivation path, as defined in the BIP-32 specification, and provides methods for encoding, decoding, and manipulating such paths.\n\n2. What is the difference between a public and private branch in a derivation path?\n- A public branch in a derivation path corresponds to a chain of public keys, while a private branch corresponds to a chain of private keys. Public branches can be used to derive child public keys, while private branches can be used to derive child private keys.\n\n3. What is the purpose of the DerivationPathSerializer class?\n- The DerivationPathSerializer class is a SigmaSerializer implementation that provides methods for serializing and deserializing DerivationPath objects to and from byte arrays, respectively. This allows for the efficient storage and transmission of HD key derivation paths."
    },
    {
      "fileName": "ExtendedKey.scala",
      "filePath": "sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/secrets/ExtendedKey.scala",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/secrets/ExtendedKey.scala",
      "summary": "The code defines a trait called `ExtendedKey` which is used to represent extended private and public keys in a cryptocurrency wallet. The trait defines two subtypes of extended keys: `k` for private keys and `K` for public keys. Each extended key is represented as a tuple of the key and a chain code `c`. The chain code is a 32-byte value that is identical for corresponding private and public keys. \n\nThe trait also defines a method `child(idx: Int): T` which is used to compute the corresponding child extended key given a parent extended key and an index `idx`. The algorithm to compute the child key depends on whether the child is a hardened key or not, and whether we're talking about private or public keys. The trait does not provide an implementation for this method, but it is expected to be implemented in derived classes.\n\nThe `derive(upPath: DerivationPath): T` method is used to derive a child key from a parent key given a derivation path. The method checks that the given derivation path is compatible with the current path and then iteratively computes the child key using the `child` method. \n\nOverall, this code provides a foundation for working with extended keys in a cryptocurrency wallet. It allows for the computation of child keys from parent keys and provides a way to represent extended keys as tuples of the key and chain code. This trait can be extended to provide implementations for specific cryptocurrencies such as Bitcoin or Ethereum. \n\nExample usage:\n\n```scala\n// create a Bitcoin extended private key\nval privateKey = new BitcoinExtendedPrivateKey(k, c, path)\n\n// derive a child key from the parent key\nval childKey = privateKey.derive(DerivationPath(\"m/0/1\"))\n```",
      "questions": "1. What is the purpose of the ExtendedKey trait?\n- The ExtendedKey trait defines the basic structure and functionality of extended private and public keys, including the ability to derive child keys.\n\n2. What is the significance of the chain code in extended keys?\n- The chain code is an extra 256 bits of entropy added to both private and public keys, which is identical for corresponding keys and is used in the derivation of child keys.\n\n3. What is the purpose of the derive method in the ExtendedKey trait?\n- The derive method takes a derivation path and returns the corresponding extended key, ensuring that the path is compatible with the current key and using the child method to derive the key."
    },
    {
      "fileName": "ExtendedPublicKey.scala",
      "filePath": "sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/secrets/ExtendedPublicKey.scala",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/secrets/ExtendedPublicKey.scala",
      "summary": "The code defines a class called `ExtendedPublicKey` which represents a public key, its chain code, and its path in a key tree. This class is used in the larger project to derive child public keys from a given parent public key. The `ExtendedPublicKey` class has three fields: `keyBytes`, `chainCode`, and `path`. `keyBytes` is an array of bytes representing the public key, `chainCode` is an array of bytes representing the chain code, and `path` is an instance of the `DerivationPath` class representing the path in the key tree.\n\nThe `ExtendedPublicKey` class has two methods: `key` and `child`. The `key` method returns an instance of `ProveDlog` which represents the public key. The `child` method takes an integer `idx` and returns a new instance of `ExtendedPublicKey` representing the child public key at the given index. The `ExtendedPublicKey` class also overrides the `equals`, `hashCode`, and `toString` methods.\n\nThe `ExtendedPublicKey` object has a method called `deriveChildPublicKey` which takes a parent public key and an integer `idx` and returns a new instance of `ExtendedPublicKey` representing the child public key at the given index. This method uses the `CryptoFacade` object to derive the child public key from the parent public key and the index. The `deriveChildPublicKey` method is tail-recursive and supports public key derivation for non-hardened keys.\n\nThe `ExtendedPublicKeySerializer` object defines a serializer for the `ExtendedPublicKey` class. This serializer is used to serialize and deserialize instances of `ExtendedPublicKey` to and from bytes.\n\nOverall, this code provides functionality for deriving child public keys from a given parent public key. This is useful in the larger project for generating a hierarchy of public keys for use in a hierarchical deterministic wallet.",
      "questions": "1. What is the purpose of the ExtendedPublicKey class?\n- The ExtendedPublicKey class represents a public key, its chain code, and path in a key tree, following the BIP-0032 specification.\n\n2. What is the purpose of the deriveChildPublicKey method in the ExtendedPublicKey object?\n- The deriveChildPublicKey method is used to derive a child public key from a parent public key, following the BIP-0032 specification.\n\n3. What is the purpose of the ExtendedPublicKeySerializer object?\n- The ExtendedPublicKeySerializer object is used to serialize and deserialize ExtendedPublicKey objects, including their key bytes, chain code, and derivation path."
    },
    {
      "fileName": "ExtendedSecretKey.scala",
      "filePath": "sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/secrets/ExtendedSecretKey.scala",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/secrets/ExtendedSecretKey.scala",
      "summary": "The code defines a class called `ExtendedSecretKey` which represents a secret key, its chain code, and its path in a key tree. The class extends `ExtendedKey` and implements `SecretKey`. It also defines methods for deriving child secret keys, computing public keys, and checking if the key is erased. \n\nThe `ExtendedSecretKey` class is used in the larger project for generating and managing secret keys. It is part of a larger wallet system that allows users to store and manage their cryptocurrency assets. The `ExtendedSecretKey` class is used to derive child keys from a parent key, which is useful for generating a hierarchical deterministic (HD) wallet. HD wallets allow users to generate an unlimited number of public keys from a single seed, making it easier to manage multiple cryptocurrency assets. \n\nThe `ExtendedSecretKey` class also provides methods for computing public keys and checking if the key is erased. The `publicKey` method computes the corresponding public key for the secret key, while the `isErased` method checks if the key has been erased (i.e., all bytes are zero). \n\nThe `ExtendedSecretKey` class is serialized using the `SigmaSerializer` interface, which allows instances of the class to be converted to and from byte arrays. The `ExtendedSecretKeySerializer` object provides methods for serializing and deserializing instances of the `ExtendedSecretKey` class. \n\nOverall, the `ExtendedSecretKey` class is an important component of the larger wallet system and provides functionality for generating and managing secret keys. Its methods for deriving child keys and computing public keys make it useful for generating HD wallets, while its serialization methods allow instances of the class to be stored and retrieved from disk.",
      "questions": "1. What is the purpose of the ExtendedSecretKey class?\n- The ExtendedSecretKey class represents a secret key, its chain code, and path in a key tree, and is used for key derivation.\n\n2. What is the difference between the deriveChildSecretKey and deriveChildPublicKey methods in the ExtendedSecretKey object?\n- The deriveChildSecretKey method derives a child secret key from a parent secret key, while the deriveChildPublicKey method derives a child public key from a parent secret key.\n\n3. What is the usePre1627KeyDerivation parameter in the deriveMasterKey method of the ExtendedSecretKey object?\n- The usePre1627KeyDerivation parameter is used to specify whether to use the incorrect (previous) BIP32 derivation method, and is expected to be false for new wallets and true for old pre-1627 wallets."
    },
    {
      "fileName": "Index.scala",
      "filePath": "sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/secrets/Index.scala",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/secrets/Index.scala",
      "summary": "The code in this file defines a Scala object called \"Index\" that contains several methods related to indexing and serialization of integers. The purpose of this code is to provide a set of utility functions that can be used by other parts of the project to manage and manipulate indexes.\n\nThe first method defined in the object is \"hardIndex\", which takes an integer as input and returns a new integer with the HardRangeStart value (0x80000000) bitwise ORed with the input integer. This method is used to create a \"hardened\" index, which is a special type of index used in certain cryptographic protocols.\n\nThe second method, \"isHardened\", takes an integer as input and returns a boolean indicating whether the input integer is a hardened index. This method is used to check whether an index is hardened before performing certain operations on it.\n\nThe third method, \"serializeIndex\", takes an integer as input and returns an array of bytes representing the serialized form of the integer. This method is used to convert an index into a format that can be stored or transmitted.\n\nThe fourth method, \"parseIndex\", takes an array of bytes as input and returns the integer value represented by the bytes. This method is used to convert a serialized index back into its original integer form.\n\nOverall, this code provides a set of utility functions that can be used to manage and manipulate indexes in a standardized way. Other parts of the project can use these functions to ensure consistency and compatibility when working with indexes. For example, if a module needs to serialize an index for storage in a database, it can use the \"serializeIndex\" method to ensure that the index is stored in a consistent format. Similarly, if a module needs to check whether an index is hardened before performing a cryptographic operation, it can use the \"isHardened\" method to ensure that the operation is performed correctly.",
      "questions": "1. What is the purpose of the `Index` object and its methods?\n   - The `Index` object provides methods for working with indexes in a specific range and converting them to and from byte arrays.\n2. What is the significance of the `HardRangeStart` value?\n   - The `HardRangeStart` value is used to mark indexes in a specific range as \"hardened\", which is a concept in cryptography that adds additional security to certain operations.\n3. Are there any potential issues with the `serializeIndex` and `parseIndex` methods?\n   - It is possible that these methods may not handle edge cases or unexpected input correctly, so it would be important to thoroughly test them and potentially add error handling."
    },
    {
      "fileName": "SecretKey.scala",
      "filePath": "sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/secrets/SecretKey.scala",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/secrets/SecretKey.scala",
      "summary": "This code defines a set of traits and classes for handling secret keys in the Ergo Platform SDK wallet. The purpose of this code is to provide a basic framework for handling secret data, encapsulating a corresponding private input for a Sigma protocol. \n\nThe `SecretKey` trait defines a basic interface for secret data, with a single method `privateInput` that returns the private input of a Sigma protocol. This trait is extended by the `PrimitiveSecretKey` trait, which represents a secret that does not have a derivation scheme. \n\nThe `PrimitiveSecretKey` object provides a factory method for creating instances of `PrimitiveSecretKey` from a `SigmaProtocolPrivateInput`. This method uses pattern matching to determine the type of the input and returns either a `DlogSecretKey` or a `DhtSecretKey` instance, depending on the input type. \n\nThe `DlogSecretKey` and `DhtSecretKey` classes represent secret exponents of a group element, i.e. secret `w` such as `h = g^^w`, where `g` is a group generator and `h` is a public key. `DlogSecretKey` represents the secret exponent of a group element in a discrete logarithm group, while `DhtSecretKey` represents the secret exponent of a Diffie-Hellman tuple. Both classes take a private input in the form of a Sigma-protocol private input as a constructor argument. \n\nOverall, this code provides a basic framework for handling secret keys in the Ergo Platform SDK wallet. It allows for the creation of instances of `PrimitiveSecretKey`, which can be used to represent secret exponents of group elements in discrete logarithm groups or Diffie-Hellman tuples. These secret keys can then be used in other parts of the wallet to perform various cryptographic operations. \n\nExample usage:\n\n```\nval dlogInput = DLogProverInput(...)\nval dlogSecretKey = DlogSecretKey(dlogInput)\n\nval dhtInput = DiffieHellmanTupleProverInput(...)\nval dhtSecretKey = DhtSecretKey(dhtInput)\n```",
      "questions": "1. What is the purpose of this code?\n- This code defines traits and case classes for secret keys used in Sigma protocols.\n\n2. What Sigma protocols are supported by this code?\n- The code supports Sigma protocols that use DLogProverInput and DiffieHellmanTupleProverInput.\n\n3. What is the difference between DlogSecretKey and DhtSecretKey?\n- DlogSecretKey represents the secret exponent of a group element, while DhtSecretKey represents the secret exponent of a Diffie-Hellman tuple."
    }
  ],
  "folders": [],
  "summary": "The code in this folder provides functionality for handling secret keys, extended keys, and key derivation paths in the Ergo Platform SDK wallet. It is essential for generating and managing keys in a hierarchical deterministic (HD) wallet, which allows users to generate an unlimited number of public keys from a single seed, making it easier to manage multiple cryptocurrency assets.\n\n`DerivationPath.scala` defines a class for representing and manipulating HD key derivation paths. It provides methods for encoding and decoding paths, converting paths to public or private branches, finding the next available path index for a new key, and checking if a path corresponds to a specific derivation path. This class can be used to generate new keys for transactions or to manage keys in a wallet.\n\n`ExtendedKey.scala` defines a trait for representing extended private and public keys in a cryptocurrency wallet. It provides methods for computing child keys from parent keys and representing extended keys as tuples of the key and chain code. This trait can be extended to provide implementations for specific cryptocurrencies such as Bitcoin or Ethereum.\n\nExample usage:\n\n```scala\n// create a Bitcoin extended private key\nval privateKey = new BitcoinExtendedPrivateKey(k, c, path)\n\n// derive a child key from the parent key\nval childKey = privateKey.derive(DerivationPath(\"m/0/1\"))\n```\n\n`ExtendedPublicKey.scala` and `ExtendedSecretKey.scala` define classes for representing public and secret keys, their chain codes, and their paths in a key tree. They provide methods for deriving child keys, computing public keys, and checking if a key is erased. These classes are used to generate and manage keys in the larger wallet system.\n\n`Index.scala` provides utility functions for managing and manipulating indexes, such as creating hardened indexes, checking if an index is hardened, and serializing and parsing indexes. These functions ensure consistency and compatibility when working with indexes in other parts of the project.\n\n`SecretKey.scala` defines a set of traits and classes for handling secret keys in the wallet. It provides a basic framework for handling secret data, encapsulating a corresponding private input for a Sigma protocol. Instances of `PrimitiveSecretKey` can be created to represent secret exponents of group elements in discrete logarithm groups or Diffie-Hellman tuples, which can then be used in other parts of the wallet to perform various cryptographic operations.\n\nExample usage:\n\n```scala\nval dlogInput = DLogProverInput(...)\nval dlogSecretKey = DlogSecretKey(dlogInput)\n\nval dhtInput = DiffieHellmanTupleProverInput(...)\nval dhtSecretKey = DhtSecretKey(dhtInput)\n```\n\nOverall, the code in this folder is crucial for managing keys and key derivation paths in the Ergo Platform SDK wallet. It provides a foundation for generating and managing keys in a hierarchical deterministic wallet, allowing users to efficiently manage multiple cryptocurrency assets.",
  "questions": ""
}