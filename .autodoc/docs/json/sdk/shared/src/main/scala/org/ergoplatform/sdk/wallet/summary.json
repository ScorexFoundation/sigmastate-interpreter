{
  "folderName": "wallet",
  "folderPath": ".autodoc/docs/json/sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet",
  "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/.autodoc/docs/json/sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet",
  "files": [
    {
      "fileName": "AssetUtils.scala",
      "filePath": "sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/AssetUtils.scala",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/AssetUtils.scala",
      "summary": "The `AssetUtils` object provides utility functions for working with token assets in the Ergo blockchain. The functions are designed to work with `TokensMap`, which is a type alias for `Map[ModifierId, Long]`. The `ModifierId` is a unique identifier for a transaction output, and the `Long` value represents the amount of tokens associated with that output.\n\nThe `mergeAssetsMut` function takes a mutable map `into` and one or more `TokensMap` instances `from`. It merges the `from` maps into the `into` map by adding the token amounts for each `ModifierId`. If a `ModifierId` is present in both the `into` and `from` maps, the amounts are added together. This function modifies the `into` map in place.\n\n```scala\nval into: mutable.Map[ModifierId, Long] = mutable.Map(\n  ModifierId @@ Array.fill(32)(0.toByte) -> 100L\n)\nval from1: TokensMap = Map(\n  ModifierId @@ Array.fill(32)(1.toByte) -> 50L\n)\nval from2: TokensMap = Map(\n  ModifierId @@ Array.fill(32)(0.toByte) -> 25L\n)\nAssetUtils.mergeAssetsMut(into, from1, from2)\n// into now contains:\n// Map(\n//   ModifierId @@ Array.fill(32)(0.toByte) -> 125L,\n//   ModifierId @@ Array.fill(32)(1.toByte) -> 50L\n// )\n```\n\nThe `mergeAssets` function is similar to `mergeAssetsMut`, but it returns a new `TokensMap` instead of modifying an existing one. It takes an initial `TokensMap` and one or more additional `TokensMap` instances to merge into it. The resulting `TokensMap` contains the merged token amounts.\n\n```scala\nval initialMap: TokensMap = Map(\n  ModifierId @@ Array.fill(32)(0.toByte) -> 100L\n)\nval map1: TokensMap = Map(\n  ModifierId @@ Array.fill(32)(1.toByte) -> 50L\n)\nval map2: TokensMap = Map(\n  ModifierId @@ Array.fill(32)(0.toByte) -> 25L\n)\nval merged: TokensMap = AssetUtils.mergeAssets(initialMap, map1, map2)\n// merged contains:\n// Map(\n//   ModifierId @@ Array.fill(32)(0.toByte) -> 125L,\n//   ModifierId @@ Array.fill(32)(1.toByte) -> 50L\n// )\n```\n\nThe `subtractAssets` function takes an initial `TokensMap` and one or more `TokensMap` instances to subtract from it. It returns a new `TokensMap` with the token amounts subtracted. If a `ModifierId` is present in both the initial map and the subtractor maps, the amounts are subtracted from the initial map. If the resulting amount is zero, the `ModifierId` is removed from the map.\n\n```scala\nval initialMap: TokensMap = Map(\n  ModifierId @@ Array.fill(32)(0.toByte) -> 100L,\n  ModifierId @@ Array.fill(32)(1.toByte) -> 50L\n)\nval subtractor1: TokensMap = Map(\n  ModifierId @@ Array.fill(32)(0.toByte) -> 25L\n)\nval subtractor2: TokensMap = Map(\n  ModifierId @@ Array.fill(32)(1.toByte) -> 75L\n)\nval subtracted: TokensMap = AssetUtils.subtractAssets(initialMap, subtractor1, subtractor2)\n// subtracted contains:\n// Map(\n//   ModifierId @@ Array.fill(32)(0.toByte) -> 75L\n// )\n```\n\nThe `subtractAssetsMut` function takes a mutable map `from` and a `TokensMap` `subtractor`. It subtracts the token amounts in the `subtractor` map from the `from` map. If the resulting amount is zero, the `ModifierId` is removed from the `from` map. This function modifies the `from` map in place.\n\n```scala\nval from: mutable.Map[ModifierId, Long] = mutable.Map(\n  ModifierId @@ Array.fill(32)(0.toByte) -> 100L,\n  ModifierId @@ Array.fill(32)(1.toByte) -> 50L\n)\nval subtractor: TokensMap = Map(\n  ModifierId @@ Array.fill(32)(0.toByte) -> 25L,\n  ModifierId @@ Array.fill(32)(1.toByte) -> 75L\n)\nAssetUtils.subtractAssetsMut(from, subtractor)\n// from now contains:\n// Map(\n//   ModifierId @@ Array.fill(32)(0.toByte) -> 75L\n// )\n```\n\nOverall, these utility functions provide a convenient way to work with token assets in the Ergo blockchain. They can be used in various parts of the project, such as in the wallet or in smart contracts that deal with tokens.",
      "questions": "1. What is the purpose of the `AssetUtils` object?\n- The `AssetUtils` object provides utility functions for merging and subtracting token maps.\n\n2. What is the difference between the `mergeAssetsMut` and `mergeAssets` functions?\n- The `mergeAssetsMut` function takes a mutable map as its first argument and modifies it in place, while the `mergeAssets` function returns a new map without modifying the original.\n\n3. What happens if the `subtractAssets` function is called with a negative amount for a token or with an amount greater than the current balance?\n- The function will throw an exception with an appropriate error message indicating that the subtraction is invalid."
    },
    {
      "fileName": "Constants.scala",
      "filePath": "sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/Constants.scala",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/Constants.scala",
      "summary": "The code defines a set of constants used in the Ergo Platform SDK wallet. The `Constants` object contains several values that are used throughout the project. \n\nThe `ModifierIdLength` constant is used to specify the length of the modifier ID in the protocol and should not be changed. \n\nThe `CoinType` constant is used to define the coin type for the wallet. It is calculated based on the ASCII values of the letters in the word \"ergo\" and is used in the derivation path for the wallet. \n\nThe `MaxAssetsPerBox` constant specifies the maximum number of tokens that can be stored in a single box due to a byte size limit for the Ergo box. \n\nThe `preEip3DerivationPath` and `eip3DerivationPath` constants define the derivation paths for the wallet before and after the implementation of EIP-3. These paths are used to generate addresses for the wallet. \n\nThe `MnemonicSentenceSizes`, `AllowedStrengths`, and `AllowedEntropyLengths` constants are used in the generation of mnemonic phrases for the wallet. They specify the allowed sizes for the mnemonic sentence, the allowed strengths for the entropy, and the allowed lengths for the entropy, respectively. \n\nOverall, this code provides a set of constants that are used throughout the Ergo Platform SDK wallet to ensure consistency and standardization in the wallet's functionality. Developers can use these constants in their own code to ensure compatibility with the wallet. \n\nExample usage:\n\n```scala\nimport org.ergoplatform.sdk.wallet.Constants\n\nval coinType = Constants.CoinType\nval maxAssets = Constants.MaxAssetsPerBox\nval preEip3Path = Constants.preEip3DerivationPath\nval eip3Path = Constants.eip3DerivationPath\nval sentenceSizes = Constants.MnemonicSentenceSizes\nval allowedStrengths = Constants.AllowedStrengths\nval allowedLengths = Constants.AllowedEntropyLengths\n```",
      "questions": "1. What is the purpose of the `Constants` object?\n- The `Constants` object contains various constants used in the project, such as `ModifierIdLength`, `CoinType`, `MaxAssetsPerBox`, and others.\n\n2. What is the significance of the `preEip3DerivationPath` and `eip3DerivationPath` constants?\n- These constants define the derivation paths used for generating wallet addresses before and after the implementation of EIP-3, respectively.\n\n3. What are the `MnemonicSentenceSizes`, `AllowedStrengths`, and `AllowedEntropyLengths` constants used for?\n- These constants define the allowed sizes and strengths of mnemonic sentences and entropy lengths for generating wallet seeds."
    }
  ],
  "folders": [
    {
      "folderName": "protocol",
      "folderPath": ".autodoc/docs/json/sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/protocol",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/.autodoc/docs/json/sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/protocol",
      "files": [],
      "folders": [
        {
          "folderName": "context",
          "folderPath": ".autodoc/docs/json/sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/protocol/context",
          "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/.autodoc/docs/json/sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/protocol/context",
          "files": [
            {
              "fileName": "ErgoLikeParameters.scala",
              "filePath": "sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/protocol/context/ErgoLikeParameters.scala",
              "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/protocol/context/ErgoLikeParameters.scala",
              "summary": "The code defines a trait called ErgoLikeParameters, which represents a set of blockchain parameters that can be readjusted via miners voting and voting-related data. These parameters are included in the extension section of the first block of a voting epoch. \n\nThe trait contains several methods that return the values of different parameters. These parameters include the cost of storing 1 byte in UTXO for four years, the cost of a transaction output, the max block size, the cost of a token contained in a transaction, the cost of a transaction input, the cost of a transaction data input, the cost of a transaction output, and the computation units limit per block. \n\nIn addition to these parameters, the trait also includes methods that return the height when voting for a soft-fork had been started, the votes for soft-fork collected in previous epochs, and the protocol version. \n\nThis code is likely used in a larger project that involves blockchain technology and mining. The ErgoLikeParameters trait provides a way to read and adjust various blockchain parameters that can affect the behavior of the blockchain. These parameters can be adjusted via miners voting and voting-related data, which allows for decentralized decision-making. \n\nHere is an example of how one of these methods might be used:\n\n```\nval params: ErgoLikeParameters = // get parameters from somewhere\nval storageFeeFactor: Int = params.storageFeeFactor\nprintln(s\"Cost of storing 1 byte in UTXO for four years: $storageFeeFactor nanoErgs\")\n```\n\nThis code gets the storageFeeFactor parameter from an instance of ErgoLikeParameters and prints it to the console.",
              "questions": "1. What is the purpose of this code and what does it do?\n   \n   This code defines a trait called ErgoLikeParameters which contains various parameters related to the blockchain, such as the cost of storing data, transaction output, input, and token access, as well as the maximum block size and computation units limit per block. It also includes fields related to miners voting and voting-related data.\n\n2. What are the expected data types for the return values of the methods defined in this trait?\n   \n   The return types for the methods defined in this trait are all Int, except for softForkStartingHeight and softForkVotesCollected which are both Option[Int], and blockVersion which is Byte.\n\n3. Are all the parameters defined in this trait adjustable via miners voting or just some of them?\n   \n   It is not explicitly stated which parameters are adjustable via miners voting, but it is mentioned that all the fields included in the extension section of a first block of a voting epoch are related to miners voting and voting-related data. Therefore, it can be assumed that all the parameters defined in this trait may be adjustable via miners voting."
            },
            {
              "fileName": "ErgoLikeStateContext.scala",
              "filePath": "sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/protocol/context/ErgoLikeStateContext.scala",
              "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/protocol/context/ErgoLikeStateContext.scala",
              "summary": "The code provided defines a trait and a case class that represent the blockchain context used in transaction validation for the Ergo platform. The trait is called ErgoLikeStateContext and it defines three methods. The first method, sigmaLastHeaders, returns a fixed number of last block headers (10 in Ergo). The second method, previousStateDigest, returns the UTXO set digest from the last header of sigmaLastHeaders. The third method, sigmaPreHeader, returns the pre-header (header without certain fields) of the current block.\n\nThe case class, CErgoLikeStateContext, implements the ErgoLikeStateContext trait and takes in three parameters: sigmaLastHeaders, previousStateDigest, and sigmaPreHeader. These parameters are then used to initialize the corresponding methods in the trait.\n\nThis code is important in the larger project because it provides the necessary context for validating transactions on the Ergo platform. The sigmaLastHeaders method provides information about the previous blocks, while the previousStateDigest method provides the UTXO set digest from the last header. The sigmaPreHeader method provides information about the current block being validated.\n\nHere is an example of how this code might be used in the larger project:\n\n```\nval context = CErgoLikeStateContext(lastHeaders, stateDigest, preHeader)\nval tx = ErgoTransaction(inputs, outputs, dataInputs)\nval verifier = new ErgoLikeTransactionVerifier()\nval result = verifier.verify(tx, context)\n```\n\nIn this example, a new context is created using the CErgoLikeStateContext case class and the necessary parameters. An ErgoTransaction is then created using inputs, outputs, and dataInputs. Finally, a new ErgoLikeTransactionVerifier is created and the transaction and context are passed in to the verify method. The result of the verification is then returned.",
              "questions": "1. What is the purpose of the `ErgoLikeStateContext` trait?\n   - The `ErgoLikeStateContext` trait is used in transaction validation within the blockchain context.\n\n2. What is the difference between `sigmaLastHeaders` and `previousStateDigest`?\n   - `sigmaLastHeaders` returns a fixed number of last block headers, while `previousStateDigest` returns the UTXO set digest from the last header of `sigmaLastHeaders`.\n\n3. What is the purpose of the `CErgoLikeStateContext` case class?\n   - The `CErgoLikeStateContext` case class implements the `ErgoLikeStateContext` trait and provides concrete implementations for the trait's methods."
            },
            {
              "fileName": "TransactionContext.scala",
              "filePath": "sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/protocol/context/TransactionContext.scala",
              "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/protocol/context/TransactionContext.scala",
              "summary": "The code provided is a Scala class called TransactionContext, which is part of the Ergo Platform SDK wallet protocol context. This class is responsible for managing the execution context related to spending transactions. \n\nThe TransactionContext class takes three parameters: boxesToSpend, dataBoxes, and spendingTransaction. The boxesToSpend parameter is an IndexedSeq of ErgoBox objects, which represent the inputs of the transaction. The dataBoxes parameter is also an IndexedSeq of ErgoBox objects, but these are read-only data inputs of the transaction. Finally, the spendingTransaction parameter is an ErgoLikeTransactionTemplate object, which represents the spending transaction itself.\n\nThe purpose of this class is to provide a context for executing spending transactions. It allows developers to manage the inputs and data inputs of a transaction, as well as the transaction itself. This context can be used to validate and execute spending transactions, as well as to generate output candidates in ErgoLikeContext.\n\nOne potential use case for this class is in the development of a cryptocurrency wallet application. The TransactionContext class could be used to manage the inputs and data inputs of a transaction when sending cryptocurrency from one wallet to another. It could also be used to validate the transaction and generate output candidates before broadcasting the transaction to the network.\n\nOverall, the TransactionContext class is an important component of the Ergo Platform SDK wallet protocol context, providing developers with a powerful tool for managing spending transactions.",
              "questions": "1. What is the purpose of the TransactionContext class?\n- The TransactionContext class represents part of the execution context for spending a transaction, including inputs, data inputs, and the spending transaction itself.\n\n2. What is the significance of the ErgoLikeTransactionTemplate and UnsignedInput types?\n- The ErgoLikeTransactionTemplate type is a template for an Ergo transaction, while UnsignedInput represents an input to a transaction that has not yet been signed.\n\n3. What is the meaning of the TODO comment in the code?\n- The TODO comment suggests that the TransactionContext class may be simplified in the future after a refactoring of the ErgoLikeContext in sigma."
            }
          ],
          "folders": [],
          "summary": "The `.autodoc/docs/json/sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/protocol/context` folder contains code related to the Ergo Platform SDK wallet protocol context. This context is essential for managing and validating transactions on the Ergo platform.\n\n**ErgoLikeParameters.scala** defines a trait called ErgoLikeParameters, which represents a set of adjustable blockchain parameters. These parameters can be read and modified via miners voting and voting-related data. The trait contains methods that return the values of various parameters, such as the cost of storing 1 byte in UTXO for four years, the cost of a transaction output, the max block size, and more. This trait is crucial for decentralized decision-making in the larger project involving blockchain technology and mining.\n\nExample usage:\n\n```scala\nval params: ErgoLikeParameters = // get parameters from somewhere\nval storageFeeFactor: Int = params.storageFeeFactor\nprintln(s\"Cost of storing 1 byte in UTXO for four years: $storageFeeFactor nanoErgs\")\n```\n\n**ErgoLikeStateContext.scala** defines a trait and a case class that represent the blockchain context used in transaction validation for the Ergo platform. The trait, ErgoLikeStateContext, defines methods that return information about the previous blocks, the UTXO set digest from the last header, and the pre-header of the current block. The case class, CErgoLikeStateContext, implements the ErgoLikeStateContext trait and initializes the corresponding methods with the provided parameters. This code is essential for providing the necessary context for validating transactions on the Ergo platform.\n\nExample usage:\n\n```scala\nval context = CErgoLikeStateContext(lastHeaders, stateDigest, preHeader)\nval tx = ErgoTransaction(inputs, outputs, dataInputs)\nval verifier = new ErgoLikeTransactionVerifier()\nval result = verifier.verify(tx, context)\n```\n\n**TransactionContext.scala** is a Scala class that manages the execution context related to spending transactions. It takes three parameters: boxesToSpend, dataBoxes, and spendingTransaction. The class provides a context for executing spending transactions, allowing developers to manage the inputs and data inputs of a transaction, as well as the transaction itself. This context can be used to validate and execute spending transactions and generate output candidates in ErgoLikeContext. This class is an important component of the Ergo Platform SDK wallet protocol context, providing developers with a powerful tool for managing spending transactions.",
          "questions": ""
        }
      ],
      "summary": "The code in this folder is part of the Ergo Platform SDK wallet protocol and is responsible for managing and validating transactions on the Ergo platform. It consists of three main Scala files: `ErgoLikeParameters.scala`, `ErgoLikeStateContext.scala`, and `TransactionContext.scala`.\n\n`ErgoLikeParameters.scala` defines a trait called ErgoLikeParameters, which represents a set of adjustable blockchain parameters. These parameters can be read and modified via miners voting and voting-related data. The trait contains methods that return the values of various parameters, such as the cost of storing 1 byte in UTXO for four years, the cost of a transaction output, the max block size, and more. This trait is crucial for decentralized decision-making in the larger project involving blockchain technology and mining.\n\nExample usage:\n\n```scala\nval params: ErgoLikeParameters = // get parameters from somewhere\nval storageFeeFactor: Int = params.storageFeeFactor\nprintln(s\"Cost of storing 1 byte in UTXO for four years: $storageFeeFactor nanoErgs\")\n```\n\n`ErgoLikeStateContext.scala` defines a trait and a case class that represent the blockchain context used in transaction validation for the Ergo platform. The trait, ErgoLikeStateContext, defines methods that return information about the previous blocks, the UTXO set digest from the last header, and the pre-header of the current block. The case class, CErgoLikeStateContext, implements the ErgoLikeStateContext trait and initializes the corresponding methods with the provided parameters. This code is essential for providing the necessary context for validating transactions on the Ergo platform.\n\nExample usage:\n\n```scala\nval context = CErgoLikeStateContext(lastHeaders, stateDigest, preHeader)\nval tx = ErgoTransaction(inputs, outputs, dataInputs)\nval verifier = new ErgoLikeTransactionVerifier()\nval result = verifier.verify(tx, context)\n```\n\n`TransactionContext.scala` is a Scala class that manages the execution context related to spending transactions. It takes three parameters: boxesToSpend, dataBoxes, and spendingTransaction. The class provides a context for executing spending transactions, allowing developers to manage the inputs and data inputs of a transaction, as well as the transaction itself. This context can be used to validate and execute spending transactions and generate output candidates in ErgoLikeContext. This class is an important component of the Ergo Platform SDK wallet protocol context, providing developers with a powerful tool for managing spending transactions.\n\nIn summary, the code in this folder is essential for managing and validating transactions on the Ergo platform. It provides developers with the necessary tools and context to work with adjustable blockchain parameters, transaction validation, and spending transaction execution.",
      "questions": ""
    },
    {
      "folderName": "secrets",
      "folderPath": ".autodoc/docs/json/sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/secrets",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/.autodoc/docs/json/sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/secrets",
      "files": [
        {
          "fileName": "DerivationPath.scala",
          "filePath": "sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/secrets/DerivationPath.scala",
          "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/secrets/DerivationPath.scala",
          "summary": "The code defines a class called `DerivationPath` which represents a hierarchical deterministic (HD) key derivation path. The HD key derivation path is a sequence of integers that represents a path from the root of a tree of keys to a particular key. The class has methods to encode and decode the path as a string, to convert the path to a public or private branch, to find the next available path index for a new key, and to check if the path corresponds to a specific derivation path.\n\nThe `DerivationPath` class has a constructor that takes a sequence of integers and a boolean flag indicating whether the path is from the public or private branch. The class has methods to get the depth of the path, the last element of the path, and whether the path is a master path. The class also has methods to create a new path by extending the current path with a new index, increasing the last element of the path, and converting the path to a public or private branch.\n\nThe `DerivationPath` class has a method to encode the path as a parsable string. The method first checks whether the path is from the public or private branch and adds the appropriate prefix to the string. The method then converts each element of the path to a string and adds a forward slash between each element.\n\nThe `DerivationPath` class has a method to find the next available path index for a new key. The method takes a list of previously generated keys and a boolean flag indicating whether to use pre-EIP3 derivation or not. The method first checks whether there are any keys generated and whether the last key is a master key. If there are no keys generated or the last key is a master key, the method returns the first key in the specified derivation path. If the last key corresponds to the EIP-3 derivation path, the method returns a new path with the last element increased by one. Otherwise, the method finds the maximum index of the last non-hardened segment of each key and returns a new path with the last non-hardened segment increased by one.\n\nThe `DerivationPath` class has a method to check whether the path corresponds to the EIP-3 derivation path. The method checks whether the tail of the path matches the first three elements of the EIP-3 derivation path.\n\nThe `DerivationPath` class has a method to convert the path to a byte array using a `DerivationPathSerializer`. The `DerivationPathSerializer` is a Sigma serializer that serializes the path as a sequence of bytes. The `DerivationPathSerializer` has methods to serialize and parse the path.\n\nOverall, the `DerivationPath` class provides a way to represent and manipulate HD key derivation paths. The class can be used in the larger project to generate and manage keys for the Ergo platform. For example, the class can be used to generate new keys for transactions or to manage the keys in a wallet.",
          "questions": "1. What is the purpose of the DerivationPath class?\n- The DerivationPath class represents a hierarchical deterministic (HD) key derivation path, as defined in the BIP-32 specification, and provides methods for encoding, decoding, and manipulating such paths.\n\n2. What is the difference between a public and private branch in a derivation path?\n- A public branch in a derivation path corresponds to a chain of public keys, while a private branch corresponds to a chain of private keys. Public branches can be used to derive child public keys, while private branches can be used to derive child private keys.\n\n3. What is the purpose of the DerivationPathSerializer class?\n- The DerivationPathSerializer class is a SigmaSerializer implementation that provides methods for serializing and deserializing DerivationPath objects to and from byte arrays, respectively. This allows for the efficient storage and transmission of HD key derivation paths."
        },
        {
          "fileName": "ExtendedKey.scala",
          "filePath": "sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/secrets/ExtendedKey.scala",
          "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/secrets/ExtendedKey.scala",
          "summary": "The code defines a trait called `ExtendedKey` which is used to represent extended private and public keys in a cryptocurrency wallet. The trait defines two subtypes of extended keys: `k` for private keys and `K` for public keys. Each extended key is represented as a tuple of the key and a chain code `c`. The chain code is a 32-byte value that is identical for corresponding private and public keys. \n\nThe trait also defines a method `child(idx: Int): T` which is used to compute the corresponding child extended key given a parent extended key and an index `idx`. The algorithm to compute the child key depends on whether the child is a hardened key or not, and whether we're talking about private or public keys. The trait does not provide an implementation for this method, but it is expected to be implemented in derived classes.\n\nThe `derive(upPath: DerivationPath): T` method is used to derive a child key from a parent key given a derivation path. The method checks that the given derivation path is compatible with the current path and then iteratively computes the child key using the `child` method. \n\nOverall, this code provides a foundation for working with extended keys in a cryptocurrency wallet. It allows for the computation of child keys from parent keys and provides a way to represent extended keys as tuples of the key and chain code. This trait can be extended to provide implementations for specific cryptocurrencies such as Bitcoin or Ethereum. \n\nExample usage:\n\n```scala\n// create a Bitcoin extended private key\nval privateKey = new BitcoinExtendedPrivateKey(k, c, path)\n\n// derive a child key from the parent key\nval childKey = privateKey.derive(DerivationPath(\"m/0/1\"))\n```",
          "questions": "1. What is the purpose of the ExtendedKey trait?\n- The ExtendedKey trait defines the basic structure and functionality of extended private and public keys, including the ability to derive child keys.\n\n2. What is the significance of the chain code in extended keys?\n- The chain code is an extra 256 bits of entropy added to both private and public keys, which is identical for corresponding keys and is used in the derivation of child keys.\n\n3. What is the purpose of the derive method in the ExtendedKey trait?\n- The derive method takes a derivation path and returns the corresponding extended key, ensuring that the path is compatible with the current key and using the child method to derive the key."
        },
        {
          "fileName": "ExtendedPublicKey.scala",
          "filePath": "sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/secrets/ExtendedPublicKey.scala",
          "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/secrets/ExtendedPublicKey.scala",
          "summary": "The code defines a class called `ExtendedPublicKey` which represents a public key, its chain code, and its path in a key tree. This class is used in the larger project to derive child public keys from a given parent public key. The `ExtendedPublicKey` class has three fields: `keyBytes`, `chainCode`, and `path`. `keyBytes` is an array of bytes representing the public key, `chainCode` is an array of bytes representing the chain code, and `path` is an instance of the `DerivationPath` class representing the path in the key tree.\n\nThe `ExtendedPublicKey` class has two methods: `key` and `child`. The `key` method returns an instance of `ProveDlog` which represents the public key. The `child` method takes an integer `idx` and returns a new instance of `ExtendedPublicKey` representing the child public key at the given index. The `ExtendedPublicKey` class also overrides the `equals`, `hashCode`, and `toString` methods.\n\nThe `ExtendedPublicKey` object has a method called `deriveChildPublicKey` which takes a parent public key and an integer `idx` and returns a new instance of `ExtendedPublicKey` representing the child public key at the given index. This method uses the `CryptoFacade` object to derive the child public key from the parent public key and the index. The `deriveChildPublicKey` method is tail-recursive and supports public key derivation for non-hardened keys.\n\nThe `ExtendedPublicKeySerializer` object defines a serializer for the `ExtendedPublicKey` class. This serializer is used to serialize and deserialize instances of `ExtendedPublicKey` to and from bytes.\n\nOverall, this code provides functionality for deriving child public keys from a given parent public key. This is useful in the larger project for generating a hierarchy of public keys for use in a hierarchical deterministic wallet.",
          "questions": "1. What is the purpose of the ExtendedPublicKey class?\n- The ExtendedPublicKey class represents a public key, its chain code, and path in a key tree, following the BIP-0032 specification.\n\n2. What is the purpose of the deriveChildPublicKey method in the ExtendedPublicKey object?\n- The deriveChildPublicKey method is used to derive a child public key from a parent public key, following the BIP-0032 specification.\n\n3. What is the purpose of the ExtendedPublicKeySerializer object?\n- The ExtendedPublicKeySerializer object is used to serialize and deserialize ExtendedPublicKey objects, including their key bytes, chain code, and derivation path."
        },
        {
          "fileName": "ExtendedSecretKey.scala",
          "filePath": "sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/secrets/ExtendedSecretKey.scala",
          "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/secrets/ExtendedSecretKey.scala",
          "summary": "The code defines a class called `ExtendedSecretKey` which represents a secret key, its chain code, and its path in a key tree. The class extends `ExtendedKey` and implements `SecretKey`. It also defines methods for deriving child secret keys, computing public keys, and checking if the key is erased. \n\nThe `ExtendedSecretKey` class is used in the larger project for generating and managing secret keys. It is part of a larger wallet system that allows users to store and manage their cryptocurrency assets. The `ExtendedSecretKey` class is used to derive child keys from a parent key, which is useful for generating a hierarchical deterministic (HD) wallet. HD wallets allow users to generate an unlimited number of public keys from a single seed, making it easier to manage multiple cryptocurrency assets. \n\nThe `ExtendedSecretKey` class also provides methods for computing public keys and checking if the key is erased. The `publicKey` method computes the corresponding public key for the secret key, while the `isErased` method checks if the key has been erased (i.e., all bytes are zero). \n\nThe `ExtendedSecretKey` class is serialized using the `SigmaSerializer` interface, which allows instances of the class to be converted to and from byte arrays. The `ExtendedSecretKeySerializer` object provides methods for serializing and deserializing instances of the `ExtendedSecretKey` class. \n\nOverall, the `ExtendedSecretKey` class is an important component of the larger wallet system and provides functionality for generating and managing secret keys. Its methods for deriving child keys and computing public keys make it useful for generating HD wallets, while its serialization methods allow instances of the class to be stored and retrieved from disk.",
          "questions": "1. What is the purpose of the ExtendedSecretKey class?\n- The ExtendedSecretKey class represents a secret key, its chain code, and path in a key tree, and is used for key derivation.\n\n2. What is the difference between the deriveChildSecretKey and deriveChildPublicKey methods in the ExtendedSecretKey object?\n- The deriveChildSecretKey method derives a child secret key from a parent secret key, while the deriveChildPublicKey method derives a child public key from a parent secret key.\n\n3. What is the usePre1627KeyDerivation parameter in the deriveMasterKey method of the ExtendedSecretKey object?\n- The usePre1627KeyDerivation parameter is used to specify whether to use the incorrect (previous) BIP32 derivation method, and is expected to be false for new wallets and true for old pre-1627 wallets."
        },
        {
          "fileName": "Index.scala",
          "filePath": "sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/secrets/Index.scala",
          "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/secrets/Index.scala",
          "summary": "The code in this file defines a Scala object called \"Index\" that contains several methods related to indexing and serialization of integers. The purpose of this code is to provide a set of utility functions that can be used by other parts of the project to manage and manipulate indexes.\n\nThe first method defined in the object is \"hardIndex\", which takes an integer as input and returns a new integer with the HardRangeStart value (0x80000000) bitwise ORed with the input integer. This method is used to create a \"hardened\" index, which is a special type of index used in certain cryptographic protocols.\n\nThe second method, \"isHardened\", takes an integer as input and returns a boolean indicating whether the input integer is a hardened index. This method is used to check whether an index is hardened before performing certain operations on it.\n\nThe third method, \"serializeIndex\", takes an integer as input and returns an array of bytes representing the serialized form of the integer. This method is used to convert an index into a format that can be stored or transmitted.\n\nThe fourth method, \"parseIndex\", takes an array of bytes as input and returns the integer value represented by the bytes. This method is used to convert a serialized index back into its original integer form.\n\nOverall, this code provides a set of utility functions that can be used to manage and manipulate indexes in a standardized way. Other parts of the project can use these functions to ensure consistency and compatibility when working with indexes. For example, if a module needs to serialize an index for storage in a database, it can use the \"serializeIndex\" method to ensure that the index is stored in a consistent format. Similarly, if a module needs to check whether an index is hardened before performing a cryptographic operation, it can use the \"isHardened\" method to ensure that the operation is performed correctly.",
          "questions": "1. What is the purpose of the `Index` object and its methods?\n   - The `Index` object provides methods for working with indexes in a specific range and converting them to and from byte arrays.\n2. What is the significance of the `HardRangeStart` value?\n   - The `HardRangeStart` value is used to mark indexes in a specific range as \"hardened\", which is a concept in cryptography that adds additional security to certain operations.\n3. Are there any potential issues with the `serializeIndex` and `parseIndex` methods?\n   - It is possible that these methods may not handle edge cases or unexpected input correctly, so it would be important to thoroughly test them and potentially add error handling."
        },
        {
          "fileName": "SecretKey.scala",
          "filePath": "sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/secrets/SecretKey.scala",
          "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/secrets/SecretKey.scala",
          "summary": "This code defines a set of traits and classes for handling secret keys in the Ergo Platform SDK wallet. The purpose of this code is to provide a basic framework for handling secret data, encapsulating a corresponding private input for a Sigma protocol. \n\nThe `SecretKey` trait defines a basic interface for secret data, with a single method `privateInput` that returns the private input of a Sigma protocol. This trait is extended by the `PrimitiveSecretKey` trait, which represents a secret that does not have a derivation scheme. \n\nThe `PrimitiveSecretKey` object provides a factory method for creating instances of `PrimitiveSecretKey` from a `SigmaProtocolPrivateInput`. This method uses pattern matching to determine the type of the input and returns either a `DlogSecretKey` or a `DhtSecretKey` instance, depending on the input type. \n\nThe `DlogSecretKey` and `DhtSecretKey` classes represent secret exponents of a group element, i.e. secret `w` such as `h = g^^w`, where `g` is a group generator and `h` is a public key. `DlogSecretKey` represents the secret exponent of a group element in a discrete logarithm group, while `DhtSecretKey` represents the secret exponent of a Diffie-Hellman tuple. Both classes take a private input in the form of a Sigma-protocol private input as a constructor argument. \n\nOverall, this code provides a basic framework for handling secret keys in the Ergo Platform SDK wallet. It allows for the creation of instances of `PrimitiveSecretKey`, which can be used to represent secret exponents of group elements in discrete logarithm groups or Diffie-Hellman tuples. These secret keys can then be used in other parts of the wallet to perform various cryptographic operations. \n\nExample usage:\n\n```\nval dlogInput = DLogProverInput(...)\nval dlogSecretKey = DlogSecretKey(dlogInput)\n\nval dhtInput = DiffieHellmanTupleProverInput(...)\nval dhtSecretKey = DhtSecretKey(dhtInput)\n```",
          "questions": "1. What is the purpose of this code?\n- This code defines traits and case classes for secret keys used in Sigma protocols.\n\n2. What Sigma protocols are supported by this code?\n- The code supports Sigma protocols that use DLogProverInput and DiffieHellmanTupleProverInput.\n\n3. What is the difference between DlogSecretKey and DhtSecretKey?\n- DlogSecretKey represents the secret exponent of a group element, while DhtSecretKey represents the secret exponent of a Diffie-Hellman tuple."
        }
      ],
      "folders": [],
      "summary": "The code in this folder provides functionality for handling secret keys, extended keys, and key derivation paths in the Ergo Platform SDK wallet. It is essential for generating and managing keys in a hierarchical deterministic (HD) wallet, which allows users to generate an unlimited number of public keys from a single seed, making it easier to manage multiple cryptocurrency assets.\n\n`DerivationPath.scala` defines a class for representing and manipulating HD key derivation paths. It provides methods for encoding and decoding paths, converting paths to public or private branches, finding the next available path index for a new key, and checking if a path corresponds to a specific derivation path. This class can be used to generate new keys for transactions or to manage keys in a wallet.\n\n`ExtendedKey.scala` defines a trait for representing extended private and public keys in a cryptocurrency wallet. It provides methods for computing child keys from parent keys and representing extended keys as tuples of the key and chain code. This trait can be extended to provide implementations for specific cryptocurrencies such as Bitcoin or Ethereum.\n\nExample usage:\n\n```scala\n// create a Bitcoin extended private key\nval privateKey = new BitcoinExtendedPrivateKey(k, c, path)\n\n// derive a child key from the parent key\nval childKey = privateKey.derive(DerivationPath(\"m/0/1\"))\n```\n\n`ExtendedPublicKey.scala` and `ExtendedSecretKey.scala` define classes for representing public and secret keys, their chain codes, and their paths in a key tree. They provide methods for deriving child keys, computing public keys, and checking if a key is erased. These classes are used to generate and manage keys in the larger wallet system.\n\n`Index.scala` provides utility functions for managing and manipulating indexes, such as creating hardened indexes, checking if an index is hardened, and serializing and parsing indexes. These functions ensure consistency and compatibility when working with indexes in other parts of the project.\n\n`SecretKey.scala` defines a set of traits and classes for handling secret keys in the wallet. It provides a basic framework for handling secret data, encapsulating a corresponding private input for a Sigma protocol. Instances of `PrimitiveSecretKey` can be created to represent secret exponents of group elements in discrete logarithm groups or Diffie-Hellman tuples, which can then be used in other parts of the wallet to perform various cryptographic operations.\n\nExample usage:\n\n```scala\nval dlogInput = DLogProverInput(...)\nval dlogSecretKey = DlogSecretKey(dlogInput)\n\nval dhtInput = DiffieHellmanTupleProverInput(...)\nval dhtSecretKey = DhtSecretKey(dhtInput)\n```\n\nOverall, the code in this folder is crucial for managing keys and key derivation paths in the Ergo Platform SDK wallet. It provides a foundation for generating and managing keys in a hierarchical deterministic wallet, allowing users to efficiently manage multiple cryptocurrency assets.",
      "questions": ""
    },
    {
      "folderName": "settings",
      "folderPath": ".autodoc/docs/json/sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/settings",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/.autodoc/docs/json/sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/settings",
      "files": [
        {
          "fileName": "EncryptionSettings.scala",
          "filePath": "sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/settings/EncryptionSettings.scala",
          "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet/settings/EncryptionSettings.scala",
          "summary": "The code above defines a Scala package called `org.ergoplatform.sdk.wallet.settings` that contains a case class called `EncryptionSettings` and two implicit objects that implement the `Encoder` and `Decoder` traits from the `io.circe` library. \n\nThe `EncryptionSettings` case class has three parameters: `prf`, `c`, and `dkLen`. These parameters are used to define the encryption parameters for a password-based key derivation function (PBKDF2). The `prf` parameter is a string that represents the pseudo-random function used by the PBKDF2 algorithm. The `c` parameter is an integer that represents the number of iterations used by the PBKDF2 algorithm. The `dkLen` parameter is an integer that represents the desired bit-length of the derived key.\n\nThe `EncryptionSettingsEncoder` object implements the `Encoder` trait for the `EncryptionSettings` case class. This object defines a `apply` method that takes an instance of `EncryptionSettings` and returns a JSON object that represents the instance. The JSON object has three fields: `prf`, `c`, and `dkLen`. The values of these fields are obtained from the corresponding parameters of the `EncryptionSettings` instance.\n\nThe `EncryptionSettingsDecoder` object implements the `Decoder` trait for the `EncryptionSettings` case class. This object defines an `apply` method that takes a `HCursor` instance and returns a `Decoder.Result` instance that represents the `EncryptionSettings` instance. The `HCursor` instance is used to navigate the JSON object that represents the `EncryptionSettings` instance. The `as` method is used to extract the values of the `prf`, `c`, and `dkLen` fields from the JSON object. These values are then used to create a new instance of the `EncryptionSettings` case class.\n\nThis code is used to define the encryption parameters for the PBKDF2 algorithm used by the larger project. The `EncryptionSettings` case class can be used to create instances of the encryption parameters, and the `EncryptionSettingsEncoder` and `EncryptionSettingsDecoder` objects can be used to convert instances of the `EncryptionSettings` case class to and from JSON format. This allows the encryption parameters to be stored and retrieved from a file or database. \n\nExample usage:\n\n```scala\nval encryptionSettings = EncryptionSettings(\"HmacSHA256\", 10000, 256)\nval json = encryptionSettings.asJson\nval jsonString = json.noSpaces\n// Store jsonString in a file or database\n\n// Retrieve jsonString from a file or database\nval json = parser.parse(jsonString).getOrElse(Json.Null)\nval encryptionSettings = json.as[EncryptionSettings].getOrElse(throw new Exception(\"Invalid JSON\"))\n```",
          "questions": "1. What is the purpose of the `EncryptionSettings` class?\n- The `EncryptionSettings` class represents encryption parameters, including the pseudo-random function, number of PBKDF2 iterations, and desired bit-length of the derived key.\n\n2. What is the purpose of the `EncryptionSettingsEncoder` and `EncryptionSettingsDecoder` objects?\n- The `EncryptionSettingsEncoder` object provides a way to encode `EncryptionSettings` objects as JSON, while the `EncryptionSettingsDecoder` object provides a way to decode JSON into `EncryptionSettings` objects.\n\n3. Why is the `cats.syntax.either._` import needed?\n- The `cats.syntax.either._` import is needed for compatibility with Scala 2.11."
        }
      ],
      "folders": [],
      "summary": "The `EncryptionSettings.scala` file is part of the `org.ergoplatform.sdk.wallet.settings` package and provides a case class and JSON encoding/decoding functionality for encryption settings used in the PBKDF2 algorithm. The main purpose of this code is to define the encryption parameters, store them in a JSON format, and retrieve them when needed.\n\nThe `EncryptionSettings` case class has three parameters:\n\n- `prf`: A string representing the pseudo-random function used by the PBKDF2 algorithm.\n- `c`: An integer representing the number of iterations used by the PBKDF2 algorithm.\n- `dkLen`: An integer representing the desired bit-length of the derived key.\n\nThe `EncryptionSettingsEncoder` object implements the `Encoder` trait for the `EncryptionSettings` case class. It defines an `apply` method that takes an instance of `EncryptionSettings` and returns a JSON object representing the instance. The JSON object has three fields: `prf`, `c`, and `dkLen`, with values obtained from the corresponding parameters of the `EncryptionSettings` instance.\n\nThe `EncryptionSettingsDecoder` object implements the `Decoder` trait for the `EncryptionSettings` case class. It defines an `apply` method that takes a `HCursor` instance and returns a `Decoder.Result` instance representing the `EncryptionSettings` instance. The `HCursor` instance is used to navigate the JSON object representing the `EncryptionSettings` instance, and the `as` method extracts the values of the `prf`, `c`, and `dkLen` fields from the JSON object. These values are then used to create a new instance of the `EncryptionSettings` case class.\n\nThis code can be used in the larger project to define encryption parameters for the PBKDF2 algorithm, store them in a JSON format, and retrieve them when needed. This allows the encryption parameters to be stored and retrieved from a file or database.\n\nExample usage:\n\n```scala\nval encryptionSettings = EncryptionSettings(\"HmacSHA256\", 10000, 256)\nval json = encryptionSettings.asJson\nval jsonString = json.noSpaces\n// Store jsonString in a file or database\n\n// Retrieve jsonString from a file or database\nval json = parser.parse(jsonString).getOrElse(Json.Null)\nval encryptionSettings = json.as[EncryptionSettings].getOrElse(throw new Exception(\"Invalid JSON\"))\n```\n\nIn summary, the `EncryptionSettings.scala` file provides a case class and JSON encoding/decoding functionality for encryption settings used in the PBKDF2 algorithm. This allows the larger project to store and retrieve encryption parameters in a JSON format, making it easier to manage and maintain the encryption settings.",
      "questions": ""
    }
  ],
  "summary": "The code in the `.autodoc/docs/json/sdk/shared/src/main/scala/org/ergoplatform/sdk/wallet` folder provides essential functionality for managing keys, key derivation paths, encryption settings, and transactions in the Ergo Platform SDK wallet. It consists of several Scala files and subfolders, each focusing on a specific aspect of the wallet.\n\n`AssetUtils.scala` provides utility functions for working with token assets in the Ergo blockchain. It offers functions like `mergeAssetsMut`, `mergeAssets`, `subtractAssets`, and `subtractAssetsMut` for merging and subtracting token amounts in `TokensMap`. These functions can be used in various parts of the project, such as in the wallet or in smart contracts that deal with tokens.\n\n`Constants.scala` defines a set of constants used throughout the Ergo Platform SDK wallet, ensuring consistency and standardization in the wallet's functionality. Developers can use these constants in their own code to ensure compatibility with the wallet.\n\nThe `protocol` subfolder contains code responsible for managing and validating transactions on the Ergo platform. It provides developers with the necessary tools and context to work with adjustable blockchain parameters, transaction validation, and spending transaction execution.\n\nThe `secrets` subfolder provides functionality for handling secret keys, extended keys, and key derivation paths in the Ergo Platform SDK wallet. It is essential for generating and managing keys in a hierarchical deterministic (HD) wallet, allowing users to efficiently manage multiple cryptocurrency assets.\n\nThe `settings` subfolder contains the `EncryptionSettings.scala` file, which provides a case class and JSON encoding/decoding functionality for encryption settings used in the PBKDF2 algorithm. This allows the larger project to store and retrieve encryption parameters in a JSON format, making it easier to manage and maintain the encryption settings.\n\nExample usage of `AssetUtils`:\n\n```scala\nval initialMap: TokensMap = Map(\n  ModifierId @@ Array.fill(32)(0.toByte) -> 100L\n)\nval map1: TokensMap = Map(\n  ModifierId @@ Array.fill(32)(1.toByte) -> 50L\n)\nval map2: TokensMap = Map(\n  ModifierId @@ Array.fill(32)(0.toByte) -> 25L\n)\nval merged: TokensMap = AssetUtils.mergeAssets(initialMap, map1, map2)\n// merged contains:\n// Map(\n//   ModifierId @@ Array.fill(32)(0.toByte) -> 125L,\n//   ModifierId @@ Array.fill(32)(1.toByte) -> 50L\n// )\n```\n\nExample usage of `Constants`:\n\n```scala\nimport org.ergoplatform.sdk.wallet.Constants\n\nval coinType = Constants.CoinType\nval maxAssets = Constants.MaxAssetsPerBox\nval preEip3Path = Constants.preEip3DerivationPath\nval eip3Path = Constants.eip3DerivationPath\nval sentenceSizes = Constants.MnemonicSentenceSizes\nval allowedStrengths = Constants.AllowedStrengths\nval allowedLengths = Constants.AllowedEntropyLengths\n```\n\nIn summary, the code in this folder is crucial for managing keys, key derivation paths, encryption settings, and transactions in the Ergo Platform SDK wallet. It provides a foundation for generating and managing keys in a hierarchical deterministic wallet, allowing users to efficiently manage multiple cryptocurrency assets.",
  "questions": ""
}