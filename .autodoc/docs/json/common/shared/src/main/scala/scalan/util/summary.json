{
  "folderName": "util",
  "folderPath": ".autodoc/docs/json/common/shared/src/main/scala/scalan/util",
  "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/.autodoc/docs/json/common/shared/src/main/scala/scalan/util",
  "files": [
    {
      "fileName": "CollectionUtil.scala",
      "filePath": "common/shared/src/main/scala/scalan/util/CollectionUtil.scala",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/common/shared/src/main/scala/scalan/util/CollectionUtil.scala",
      "summary": "The CollectionUtil object provides utility functions for working with collections in Scala. \n\nThe `concatArrays` method is deprecated and should not be used. It concatenates two arrays of the same type into a new array. The `concatArrays_v5` method is the recommended replacement for `concatArrays`. It concatenates two arrays of the same type into a new array using `System.arraycopy`. It takes a `ClassTag` to create the proper resulting array.\n\nThe `deepHashCode` method returns a hash code for an array. It uses `java.util.Arrays` to compute the hash code.\n\nThe `createMultiMap` method groups a sequence of pairs by their first values as keys. It returns a multimap with an `ArrayBuffer` of values for each key.\n\nThe `joinSeqs` method performs a relational inner join of two sequences using the given key projections. It takes two sequences, `outer` and `inner`, and two functions, `outKey` and `inKey`, that extract the keys from the elements of the sequences. It returns a sequence of pairs of elements from `outer` and `inner` that have the same key.\n\nThe `outerJoinSeqs` method performs an outer join of two sequences using the given key projections. It takes two sequences, `outer` and `inner`, and three functions, `outKey`, `inKey`, and `proj`, that extract the keys from the elements of the sequences and combine the elements into a result. It returns a sequence of pairs of keys and results.\n\nThe `AnyOps` implicit class provides a `traverseDepthFirst` method that traverses a tree of elements depth-first and returns a list of elements.\n\nThe `TraversableOps` implicit class provides several methods for working with collections. The `updateMany` method returns a copy of the collection where elements at the specified indices are replaced with the specified values. The `cast` method checks that each element of the collection is of a specified type and returns the collection casted to that type. The `distinctBy` method returns a new collection with duplicate elements removed based on a key function. The `sameElements2` method checks if two collections have the same elements in the same order, including nested collections and arrays.\n\nOverall, the CollectionUtil object provides a set of useful utility functions for working with collections in Scala. These functions can be used in a variety of contexts to manipulate and transform collections.",
      "questions": "1. What is the purpose of the `concatArrays` method and why is it deprecated?\n- The `concatArrays` method concatenates two arrays into a new resulting array, but it is deprecated and should only be used for backwards compatibility with v3.x and v4.x.\n2. What is the difference between the `createMultiMap` and `joinSeqs` methods?\n- The `createMultiMap` method groups a given sequence of pairs by first values as keys and returns a multimap with ArrayBuffer of values for each key, while the `joinSeqs` method performs a relational inner join of two sequences using the given key projections.\n3. What is the purpose of the `distinctBy` method and why is it needed?\n- The `distinctBy` method is used to return a new collection with distinct elements based on a key function, and it is needed for compatibility with Scala 2.11."
    },
    {
      "fileName": "Extensions.scala",
      "filePath": "common/shared/src/main/scala/scalan/util/Extensions.scala",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/common/shared/src/main/scala/scalan/util/Extensions.scala",
      "summary": "The code in this file provides a set of implicit classes and methods that extend the functionality of built-in Scala types. These extensions include methods for converting between numeric types, performing arithmetic operations with overflow checking, and converting boolean values to bytes. \n\nOne notable method is `to256BitValueExact`, which checks whether a given `BigInteger` can be represented as a 256-bit two's-complement value. This method is used in deserialization to ensure that a `BigInteger` value can be safely converted to a fixed-size byte array without losing information. \n\nThe code also includes an implicit class called `Ensuring`, which provides a way to add runtime assertions to any value. The `ensuring` method takes a condition and an error message, and throws an exception if the condition is not met. This can be useful for enforcing invariants or validating input parameters. \n\nOverall, this code provides a set of utility functions that can be used throughout a larger project to extend the functionality of built-in types and perform common operations with additional safety checks. \n\nExample usage:\n\n```scala\nimport scalan.util.Extensions._\n\nval x: Int = 100\nval y: Short = 200\nval z: Byte = 1\n\n// Convert between numeric types\nval xByte: Byte = x.toByteExact\nval yInt: Int = y.toIntExact\nval zShort: Short = z.toShortExact\n\n// Perform arithmetic operations with overflow checking\nval sum: Byte = z.addExact(xByte)\nval diff: Short = y.subtractExact(xByte)\nval prod: Byte = z.multiplyExact(xByte)\n\n// Convert boolean values to bytes\nval trueByte: Byte = true.toByte\nval falseByte: Byte = false.toByte\n\n// Add runtime assertions to a value\nval result = x + y + z\nresult.ensuring(_ > 0, _ => s\"Result should be positive but was $result\")\n```",
      "questions": "1. What is the purpose of the `Extensions` object and its implicit classes?\n- The `Extensions` object contains implicit classes that provide additional functionality to primitive types such as `Byte`, `Short`, `Int`, `Long`, `Boolean`, and `BigInteger`.\n2. What is the purpose of the `toUByte` method?\n- The `toUByte` method is used to convert a signed byte to an unsigned byte by masking the byte with `0xFF`.\n3. What is the purpose of the `to256BitValueExact` method?\n- The `to256BitValueExact` method checks if a `BigInteger` can be represented as a 256-bit two's-complement value and returns the value if it can, otherwise it throws an `ArithmeticException`."
    },
    {
      "fileName": "GraphUtil.scala",
      "filePath": "common/shared/src/main/scala/scalan/util/GraphUtil.scala",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/common/shared/src/main/scala/scalan/util/GraphUtil.scala",
      "summary": "# GraphUtil Code Explanation\n\nThe `GraphUtil` object contains two methods that implement a depth-first search algorithm to traverse a graph and return a set of reachable nodes or a topologically ordered sequence of reachable nodes. \n\nThe `depthFirstSetFrom` method takes two parameters: a `starts` buffer containing the starting nodes for the search, and a `neighbours` function representing the adjacency matrix of the graph. The method returns a `DSet` of nodes reachable from the `starts` including `starts` themselves. The `neighbours` function takes a node `s` and returns a `DBuffer` of its neighbors. The method uses a recursive `visit` function to traverse the graph starting from each node in the `starts` buffer. The `visited` set keeps track of the nodes that have already been visited to avoid revisiting them. \n\nThe `depthFirstOrderFrom` method also takes a `starts` buffer and a `neighbours` function as parameters. It returns a topologically ordered `DBuffer` of nodes reachable from the `starts` including `starts` themselves. The method uses a similar recursive `visit` function as the `depthFirstSetFrom` method, but it also appends each visited node to a `res` buffer after visiting all of its neighbors. This ensures that the nodes are added to the result buffer in the correct order. \n\nBoth methods use the `cfor` loop from the `debox` library to iterate over the nodes in the `starts` buffer and the neighbors of each visited node. The `@specialized(Int)` annotation on the type parameter `A` ensures that the method is optimized for `Int` types. The `ClassTag` context bound on the type parameter `A` allows the method to create new instances of the type `A` at runtime. \n\nThese methods can be used in a larger project to analyze graphs and extract information about their structure. For example, they could be used to find all the nodes that are reachable from a given set of starting nodes, or to order the nodes in a graph based on their dependencies. The methods could also be extended to handle weighted graphs or directed graphs by modifying the `neighbours` function. \n\nExample usage:\n\n```\nimport scalan.util.GraphUtil\n\nval graph = Map(\n  1 -> List(2, 3),\n  2 -> List(4),\n  3 -> List(4),\n  4 -> List()\n)\n\nval starts = debox.Buffer.of(1)\nval neighbours = (n: Int) => debox.Buffer.fromIterable(graph.getOrElse(n, List()))\n\nval reachableNodes = GraphUtil.depthFirstSetFrom(starts)(neighbours)\nval orderedNodes = GraphUtil.depthFirstOrderFrom(starts, neighbours)\n\nprintln(reachableNodes) // DSet(1, 2, 3, 4)\nprintln(orderedNodes) // DBuffer(4, 2, 3, 1)\n```",
      "questions": "1. What is the purpose of the `GraphUtil` object?\n- The `GraphUtil` object provides two methods for building and ordering a set of reachable nodes in a graph using a depth first search algorithm.\n\n2. What is the input format for the `depthFirstSetFrom` method?\n- The `depthFirstSetFrom` method takes in a starting set of nodes and a function representing the adjacency matrix of the graph, where the type of value representing the node should implement equality which is used in debox.Set.\n\n3. What is the output format for the `depthFirstOrderFrom` method?\n- The `depthFirstOrderFrom` method returns a topologically ordered sequence of nodes reachable from the starting nodes, including the starting nodes themselves, in the form of a DBuffer."
    },
    {
      "fileName": "MemoizedFunc.scala",
      "filePath": "common/shared/src/main/scala/scalan/util/MemoizedFunc.scala",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/common/shared/src/main/scala/scalan/util/MemoizedFunc.scala",
      "summary": "The `MemoizedFunc` class is designed to transform a given function into a memoized equivalent function. Memoization is a technique that involves caching the results of a function so that it can be retrieved on repeated invocations with the same argument. This can be useful in situations where the function is computationally expensive and is called frequently with the same arguments.\n\nThe `MemoizedFunc` class takes a function `f` as its input and returns a new function that is memoized. The memoization is implemented by computing the function `f` only once for each argument value and storing the computed result in a hash table. The hash table is implemented using the `AVHashMap` class, which is a custom implementation of a hash table that is optimized for performance.\n\nThe `apply` method of the `MemoizedFunc` class is used to apply the memoized function to a given argument. If the result for the argument is already present in the hash table, it is retrieved and returned. Otherwise, the function `f` is computed for the argument, and the result is stored in the hash table for future use.\n\nThe `reset` method of the `MemoizedFunc` class is used to clear the cache of memoized results. This can be useful in situations where the function `f` is updated or the arguments change, and the cached results are no longer valid.\n\nOverall, the `MemoizedFunc` class provides a simple and efficient way to memoize a function in Scala. It can be used in a variety of contexts where memoization is useful, such as in machine learning algorithms or in web applications that require frequent computations. Here is an example of how to use the `MemoizedFunc` class:\n\n```\nval memoizedFunc = new MemoizedFunc((x: Int) => {\n  // Some expensive computation\n  x * x\n})\n\nval result1 = memoizedFunc(5) // Computes result for 5\nval result2 = memoizedFunc(5) // Retrieves cached result for 5\nmemoizedFunc.reset() // Clears the cache\nval result3 = memoizedFunc(5) // Computes result for 5 again\n```",
      "questions": "1. What is the purpose of the AVHashMap import?\n   - The AVHashMap is used to store the computed results of the function in a hash table for memoization.\n\n2. Can the MemoizedFunc class be used with functions that have multiple arguments?\n   - No, the MemoizedFunc class only accepts functions with a single argument of type AnyRef.\n\n3. Is it possible to change the size of the hash table used for memoization?\n   - Yes, the size of the hash table can be changed by modifying the argument passed to the AVHashMap constructor."
    },
    {
      "fileName": "StringUtil.scala",
      "filePath": "common/shared/src/main/scala/scalan/util/StringUtil.scala",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/common/shared/src/main/scala/scalan/util/StringUtil.scala",
      "summary": "# StringUtil Code Explanation\n\nThe `StringUtil` object contains utility functions for manipulating strings. The purpose of this code is to provide a set of functions that can be used to manipulate strings in various ways. \n\nThe `quote` function takes an input `x` of any type and returns a string with the input enclosed in double quotes. This function can be used to format strings for display or output.\n\nThe `deepAppend` function takes a `StringBuilder` object and an input `x` of any type. It recursively descends into the array structure of `x` and appends a string representation of `x` to the `StringBuilder`. This function can be used to convert complex data structures to strings for display or output.\n\nThe `cleanFileName` function takes an input string and returns a new string that can be used as a file name. This function replaces spaces with hyphens and removes any characters that are not printable. This function can be used to sanitize user input for use as a file name.\n\nThe `fileName` function takes a file name and a list of path components and returns a string that represents the full file path. This function can be used to construct file paths from components.\n\nThe `StringUtilExtensions` class provides two extension methods for strings. The `isNullOrEmpty` method returns true if the string is null or empty. The `opt` method takes two optional parameters: a function to apply to the string and a default value to return if the string is empty. This method can be used to provide a default value for empty strings.\n\nOverall, the `StringUtil` object provides a set of utility functions for manipulating strings that can be used in a variety of contexts.",
      "questions": "1. What does the `deepAppend` method do?\n   - The `deepAppend` method takes a `StringBuilder` and an object `x` as input and recursively descends into the Array structure of `x` to emit its string representation into the `StringBuilder`.\n2. What is the purpose of the `cleanFileName` method?\n   - The `cleanFileName` method accepts a string and returns a similar string that can be used as a file name. It replaces spaces and certain special characters with underscores to ensure that the resulting string is a valid file name.\n3. What is the purpose of the `StringUtilExtensions` class?\n   - The `StringUtilExtensions` class provides two extension methods for the `String` class: `isNullOrEmpty` checks if the string is null or empty, and `opt` returns the string if it is not empty, otherwise it returns a default value."
    }
  ],
  "folders": [],
  "summary": "The `.autodoc/docs/json/common/shared/src/main/scala/scalan/util` folder contains utility functions and classes for working with collections, strings, graphs, and memoization. These utilities can be used throughout the larger project to perform common operations and extend the functionality of built-in Scala types.\n\n`CollectionUtil.scala` provides utility functions for working with collections in Scala, such as concatenating arrays, computing hash codes, creating multimaps, and performing relational joins on sequences. The `AnyOps` and `TraversableOps` implicit classes provide additional methods for traversing trees and manipulating collections. Example usage:\n\n```scala\nimport scalan.util.CollectionUtil._\n\nval arr1 = Array(1, 2, 3)\nval arr2 = Array(4, 5, 6)\nval concatArr = concatArrays_v5(arr1, arr2) // Array(1, 2, 3, 4, 5, 6)\n```\n\n`Extensions.scala` contains implicit classes and methods that extend the functionality of built-in Scala types, such as converting between numeric types, performing arithmetic operations with overflow checking, and converting boolean values to bytes. The `Ensuring` implicit class provides a way to add runtime assertions to any value. Example usage:\n\n```scala\nimport scalan.util.Extensions._\n\nval x: Int = 100\nval y: Short = 200\nval z: Byte = 1\n\nval xByte: Byte = x.toByteExact\nval yInt: Int = y.toIntExact\nval zShort: Short = z.toShortExact\n```\n\n`GraphUtil.scala` implements depth-first search algorithms to traverse a graph and return a set of reachable nodes or a topologically ordered sequence of reachable nodes. These methods can be used to analyze graphs and extract information about their structure. Example usage:\n\n```scala\nimport scalan.util.GraphUtil\n\nval graph = Map(1 -> List(2, 3), 2 -> List(4), 3 -> List(4), 4 -> List())\nval starts = debox.Buffer.of(1)\nval neighbours = (n: Int) => debox.Buffer.fromIterable(graph.getOrElse(n, List()))\n\nval reachableNodes = GraphUtil.depthFirstSetFrom(starts)(neighbours)\nval orderedNodes = GraphUtil.depthFirstOrderFrom(starts, neighbours)\n```\n\n`MemoizedFunc.scala` provides a class for transforming a given function into a memoized equivalent function, caching the results of a function for repeated invocations with the same argument. Example usage:\n\n```scala\nval memoizedFunc = new MemoizedFunc((x: Int) => x * x)\n\nval result1 = memoizedFunc(5)\nval result2 = memoizedFunc(5)\nmemoizedFunc.reset()\nval result3 = memoizedFunc(5)\n```\n\n`StringUtil.scala` contains utility functions for manipulating strings, such as quoting, appending complex data structures to a `StringBuilder`, cleaning file names, and constructing file paths. The `StringUtilExtensions` class provides extension methods for strings, such as checking if a string is null or empty and providing a default value for empty strings. Example usage:\n\n```scala\nimport scalan.util.StringUtil._\n\nval input = \"example.txt\"\nval cleanName = cleanFileName(input) // \"example-txt\"\n```",
  "questions": ""
}