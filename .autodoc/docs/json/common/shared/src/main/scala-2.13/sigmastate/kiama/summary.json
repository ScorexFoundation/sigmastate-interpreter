{
  "folderName": "kiama",
  "folderPath": ".autodoc/docs/json/common/shared/src/main/scala-2.13/sigmastate/kiama",
  "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/.autodoc/docs/json/common/shared/src/main/scala-2.13/sigmastate/kiama",
  "files": [],
  "folders": [
    {
      "folderName": "util",
      "folderPath": ".autodoc/docs/json/common/shared/src/main/scala-2.13/sigmastate/kiama/util",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/.autodoc/docs/json/common/shared/src/main/scala-2.13/sigmastate/kiama/util",
      "files": [
        {
          "fileName": "Collections.scala",
          "filePath": "common/shared/src/main/scala-2.13/sigmastate/kiama/util/Collections.scala",
          "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/common/shared/src/main/scala-2.13/sigmastate/kiama/util/Collections.scala",
          "summary": "The code in this file provides utility functions for working with collections in Scala and Java. The `Collections` object contains methods for converting between Java and Scala collections, as well as building collections using the `Builder` class.\n\nThe `javaCollectionToVector` method takes a Java `Collection` and converts it to a Scala `Vector`. This can be useful when working with Java libraries that return collections that need to be used in Scala code.\n\nThe `mapToJavaMap` method takes a Scala `Map` and converts it to a Java `Map`. This can be useful when working with Java libraries that require Java maps as input.\n\nThe `seqToJavaList` method takes a Scala `Seq` and converts it to a Java `List`. This can be useful when working with Java libraries that require Java lists as input.\n\nThe `newBuilder` method creates a new `Builder` instance for a given collection type. The first overload takes a `Factory` instance, which is used to create a new collection of the desired type. The second overload takes a `CanBuildFrom` instance, which is used to create a new collection of the desired type from an existing collection.\n\nOverall, these utility functions can be used to simplify working with collections in mixed Scala and Java codebases. They provide a convenient way to convert between collection types and build collections of the desired type.",
          "questions": "1. What is the purpose of this file in the Kiama project?\n- This file contains utility functions for converting between Java and Scala collections, as well as building collections. \n\n2. What types of collections can be converted using the `javaCollectionToVector` and `seqToJavaList` functions?\n- `javaCollectionToVector` can convert any Java collection to a Scala Vector, while `seqToJavaList` can convert a Scala Seq to a Java List.\n\n3. What is the purpose of the `Factory` and `CanBuildFrom` type aliases?\n- These type aliases are used to abstract over the specific collection types being built, allowing the `newBuilder` function to work with any collection type that has a corresponding factory or build-from method."
        }
      ],
      "folders": [],
      "summary": "The `Collections.scala` file in the `.autodoc/docs/json/common/shared/src/main/scala-2.13/sigmastate/kiama/util` folder provides utility functions for working with collections in Scala and Java. These utility functions are particularly useful when working with mixed Scala and Java codebases, as they simplify the process of converting between collection types and building collections of the desired type.\n\nThe `Collections` object contains the following methods:\n\n1. `javaCollectionToVector`: This method takes a Java `Collection` and converts it to a Scala `Vector`. This can be useful when working with Java libraries that return collections that need to be used in Scala code. For example:\n\n```scala\nimport java.util.ArrayList\nimport sigmastate.kiama.util.Collections._\n\nval javaList = new ArrayList[String]()\njavaList.add(\"Hello\")\njavaList.add(\"World\")\n\nval scalaVector = javaCollectionToVector(javaList)\n```\n\n2. `mapToJavaMap`: This method takes a Scala `Map` and converts it to a Java `Map`. This can be useful when working with Java libraries that require Java maps as input. For example:\n\n```scala\nimport java.util.Map\nimport sigmastate.kiama.util.Collections._\n\nval scalaMap = Map(\"one\" -> 1, \"two\" -> 2)\nval javaMap: Map[String, Integer] = mapToJavaMap(scalaMap)\n```\n\n3. `seqToJavaList`: This method takes a Scala `Seq` and converts it to a Java `List`. This can be useful when working with Java libraries that require Java lists as input. For example:\n\n```scala\nimport java.util.List\nimport sigmastate.kiama.util.Collections._\n\nval scalaSeq = Seq(\"one\", \"two\", \"three\")\nval javaList: List[String] = seqToJavaList(scalaSeq)\n```\n\n4. `newBuilder`: This method creates a new `Builder` instance for a given collection type. There are two overloads for this method:\n\n   - The first overload takes a `Factory` instance, which is used to create a new collection of the desired type. For example:\n\n     ```scala\n     import scala.collection.mutable.ArrayBuffer\n     import sigmastate.kiama.util.Collections._\n\n     val factory = ArrayBuffer\n     val builder = newBuilder(factory)\n     ```\n\n   - The second overload takes a `CanBuildFrom` instance, which is used to create a new collection of the desired type from an existing collection. For example:\n\n     ```scala\n     import scala.collection.immutable.Vector\n     import sigmastate.kiama.util.Collections._\n\n     val canBuildFrom = implicitly[CanBuildFrom[Vector[Int], Int, Vector[Int]]]\n     val builder = newBuilder(canBuildFrom)\n     ```\n\nIn summary, the utility functions provided in the `Collections.scala` file can be used to simplify working with collections in mixed Scala and Java codebases. They provide a convenient way to convert between collection types and build collections of the desired type.",
      "questions": ""
    }
  ],
  "summary": "The `Collections.scala` file in the `sigmastate.kiama.util` package provides utility functions for working with collections in Scala and Java. These utility functions are particularly useful when working with mixed Scala and Java codebases, as they simplify the process of converting between collection types and building collections of the desired type.\n\nThe `Collections` object contains the following methods:\n\n1. `javaCollectionToVector`: This method takes a Java `Collection` and converts it to a Scala `Vector`. This can be useful when working with Java libraries that return collections that need to be used in Scala code. For example:\n\n```scala\nimport java.util.ArrayList\nimport sigmastate.kiama.util.Collections._\n\nval javaList = new ArrayList[String]()\njavaList.add(\"Hello\")\njavaList.add(\"World\")\n\nval scalaVector = javaCollectionToVector(javaList)\n```\n\n2. `mapToJavaMap`: This method takes a Scala `Map` and converts it to a Java `Map`. This can be useful when working with Java libraries that require Java maps as input. For example:\n\n```scala\nimport java.util.Map\nimport sigmastate.kiama.util.Collections._\n\nval scalaMap = Map(\"one\" -> 1, \"two\" -> 2)\nval javaMap: Map[String, Integer] = mapToJavaMap(scalaMap)\n```\n\n3. `seqToJavaList`: This method takes a Scala `Seq` and converts it to a Java `List`. This can be useful when working with Java libraries that require Java lists as input. For example:\n\n```scala\nimport java.util.List\nimport sigmastate.kiama.util.Collections._\n\nval scalaSeq = Seq(\"one\", \"two\", \"three\")\nval javaList: List[String] = seqToJavaList(scalaSeq)\n```\n\n4. `newBuilder`: This method creates a new `Builder` instance for a given collection type. There are two overloads for this method:\n\n   - The first overload takes a `Factory` instance, which is used to create a new collection of the desired type. For example:\n\n     ```scala\n     import scala.collection.mutable.ArrayBuffer\n     import sigmastate.kiama.util.Collections._\n\n     val factory = ArrayBuffer\n     val builder = newBuilder(factory)\n     ```\n\n   - The second overload takes a `CanBuildFrom` instance, which is used to create a new collection of the desired type from an existing collection. For example:\n\n     ```scala\n     import scala.collection.immutable.Vector\n     import sigmastate.kiama.util.Collections._\n\n     val canBuildFrom = implicitly[CanBuildFrom[Vector[Int], Int, Vector[Int]]]\n     val builder = newBuilder(canBuildFrom)\n     ```\n\nIn summary, the utility functions provided in the `Collections.scala` file can be used to simplify working with collections in mixed Scala and Java codebases. They provide a convenient way to convert between collection types and build collections of the desired type.",
  "questions": ""
}