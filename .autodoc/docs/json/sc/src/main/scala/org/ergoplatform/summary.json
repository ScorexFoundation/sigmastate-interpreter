{
  "folderName": "ergoplatform",
  "folderPath": ".autodoc/docs/json/sc/src/main/scala/org/ergoplatform",
  "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/.autodoc/docs/json/sc/src/main/scala/org/ergoplatform",
  "files": [
    {
      "fileName": "ErgoScriptPredef.scala",
      "filePath": "sc/src/main/scala/org/ergoplatform/ErgoScriptPredef.scala",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/sc/src/main/scala/org/ergoplatform/ErgoScriptPredef.scala",
      "summary": "The ErgoScriptPredef object contains two methods that are used in the larger Ergo platform project. The first method, `compileWithCosting`, takes in a `ScriptEnv`, a string of code, and a `NetworkPrefix` and returns a `Value[SType]`. This method compiles the given code using the `SigmaCompiler` and returns the resulting compiled code as a `Value[SType]`. The `IRContext` is an implicit parameter that is used by the `SigmaCompiler` to compile the code.\n\nThe second method, `tokenThresholdScript`, takes in a `tokenId`, a `thresholdAmount`, and a `NetworkPrefix` and returns a `SigmaPropValue`. This method generates a script that can be used to determine if a given box can be spent by a transaction that contains at least `thresholdAmount` of the specified `tokenId`. The script is generated by compiling the provided code using the `compileWithCosting` method. The code for the script is a combination of three different versions, each of which uses different methods to calculate the sum of the token amounts. The resulting script checks if the sum of the token amounts is greater than or equal to the `thresholdAmount` and returns a `SigmaPropValue` that can be used to verify the script.\n\nHere is an example of how the `tokenThresholdScript` method can be used:\n\n```\nval tokenId: Array[Byte] = Array(1, 2, 3)\nval thresholdAmount: Long = 1000\nval networkPrefix: NetworkPrefix = NetworkPrefix.MainnetPrefix\n\nval script: SigmaPropValue = ErgoScriptPredef.tokenThresholdScript(tokenId, thresholdAmount, networkPrefix)\n```\n\nThis code generates a script that can be used to verify if a given box can be spent by a transaction that contains at least 1000 of the token with ID 010203. The resulting script is stored in the `script` variable as a `SigmaPropValue`.",
      "questions": "1. What is the purpose of the `ErgoScriptPredef` object?\n- The `ErgoScriptPredef` object contains a method for compiling a script with costing and a method for generating a proposition for a box that can be spent by a transaction with a certain token threshold.\n\n2. What is the significance of the `tokenId` and `thresholdAmount` parameters in the `tokenThresholdScript` method?\n- The `tokenId` parameter specifies the ID of the token that is being checked for in the box inputs, while the `thresholdAmount` parameter specifies the minimum amount of that token required for the box to be spendable.\n\n3. What is the purpose of the `sigmaProp` function in the `tokenThresholdScript` method?\n- The `sigmaProp` function is used to generate a `SigmaPropValue` that represents the proposition for the spendable box, based on the total amount of the specified token in the input boxes meeting the threshold requirement."
    }
  ],
  "folders": [
    {
      "folderName": "dsl",
      "folderPath": ".autodoc/docs/json/sc/src/main/scala/org/ergoplatform/dsl",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/.autodoc/docs/json/sc/src/main/scala/org/ergoplatform/dsl",
      "files": [
        {
          "fileName": "ContractSpec.scala",
          "filePath": "sc/src/main/scala/org/ergoplatform/dsl/ContractSpec.scala",
          "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/sc/src/main/scala/org/ergoplatform/dsl/ContractSpec.scala",
          "summary": "The code defines a set of traits and objects that can be used to specify and interact with smart contracts on the Ergo blockchain platform. The `ContractSpec` trait is the main entry point, and it defines several sub-traits and objects that can be used to specify the various components of a smart contract.\n\nThe `PropositionSpec` trait represents the logical proposition that must be satisfied in order to spend a given box on the blockchain. It defines a `name` field, which is a human-readable name for the proposition, a `dslSpec` field, which is a specification of the proposition in the Sigma programming language, and a `scriptSpec` field, which is a specification of the proposition in the ErgoScript language. It also defines an `ergoTree` field, which is the compiled form of the proposition that can be included in a transaction.\n\nThe `ProvingParty` trait represents a participant in a blockchain scenario who can generate a proof for a given input box. It defines a `pubKey` field, which is the public key of the party represented as a Sigma protocol proposition, and a `prove` method, which generates a proof for the given input box.\n\nThe `VerifyingParty` trait represents a participant in a blockchain scenario who can verify a proof generated by a `ProvingParty`. It defines a `verify` method, which takes an input box and a prover result and returns a boolean indicating whether the proof is valid.\n\nThe `InputBox` trait represents an input box in a transaction. It defines a `tx` field, which is the transaction candidate that contains the box, a `utxoBox` field, which is the output box that the input box is spending, a `runDsl` method, which evaluates the proposition of the input box in the given context, and a `toErgoContext` method, which converts the input box to an ErgoLikeContext that can be used in the ErgoScript language.\n\nThe `OutBox` trait represents an output box in a transaction. It defines an `id` field, which is the identifier of the box, a `tx` field, which is the transaction candidate that contains the box, a `boxIndex` field, which is the index of the box in the transaction, a `value` field, which is the value of the box in nanoErgs, a `propSpec` field, which is the specification of the proposition that must be satisfied to spend the box, a `withTokens` method, which adds tokens to the box, a `withRegs` method, which adds registers to the box, a `token` method, which retrieves a token from the box, and an `ergoBox` field, which is the compiled form of the box that can be included in a transaction.\n\nThe `TransactionCandidate` trait represents a transaction that is being constructed. It defines a `block` field, which is the block candidate that contains the transaction, `dataInputs` and `inputs` fields, which are the input boxes of the transaction, `outputs` field, which are the output boxes of the transaction, an `inBox` method, which retrieves an input box from the transaction given its output box, an `outBox` method, which creates a new output box for the transaction, a `spending` method, which adds input boxes to the transaction, and a `withDataInputs` method, which adds data input boxes to the transaction.\n\nThe `ChainTransaction` trait represents a transaction that has been confirmed on the blockchain. It defines an `outputs` field, which are the output boxes of the transaction.\n\nThe `ChainBlock` trait represents a block that has been confirmed on the blockchain. It defines a `getTransactions` method, which retrieves the transactions in the block.\n\nFinally, the code defines a `MinErgValue` constant, which is the minimum value that can be stored in an Ergo box, and an `error` method, which throws an exception with the given message.",
          "questions": "1. What is the purpose of this code?\n- This code defines traits and objects for a blockchain scenario (protocol) and provides functionality for creating and manipulating input and output boxes, transactions, and blocks.\n\n2. What external libraries or dependencies does this code use?\n- This code imports classes and objects from the `org.ergoplatform`, `sigmastate`, `scalan`, and `special.sigma` packages.\n\n3. What is the significance of the `ProvingParty` and `VerifyingParty` traits?\n- These traits represent participants in the blockchain scenario who can generate and verify proofs for input boxes, respectively. They both extend the `ProtocolParty` trait, which defines a human-readable name for the participant."
        },
        {
          "fileName": "ContractSyntax.scala",
          "filePath": "sc/src/main/scala/org/ergoplatform/dsl/ContractSyntax.scala",
          "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/sc/src/main/scala/org/ergoplatform/dsl/ContractSyntax.scala",
          "summary": "The code defines a set of methods and classes to be used in contract implementations based on SigmaContract. The ContractSyntax trait defines the methods that can be used in the implementation of SigmaContract. The trait extends SigmaContract and overrides the builder method to return a CostingSigmaDslBuilder. It also defines a contract environment that should be defined in SigmaContract implementations. The trait provides a helper method to support Scala <-> ErgoScript equivalence. The proposition method is used to define propositions in SigmaContract implementations. It takes the name of the proposition, a Scala lambda of type Proposition which defines contract semantics and can be executed directly, and the ErgoScript representation of the contract. It returns a proposition specification with compiled ErgoTree. The Env method creates a new environment with the given named constants.\n\nThe SigmaContractSyntax trait extends SigmaContract and ContractSyntax. It defines two implicit classes that provide logical AND and OR between Boolean and SigmaProp values.\n\nThis code can be used in the larger project to define and implement contracts based on SigmaContract. The ContractSyntax trait provides a set of methods that can be used to define and implement contracts. The SigmaContractSyntax trait extends ContractSyntax and provides additional methods to define contracts. The code can be used to define and implement contracts in the project, which can be used to verify transactions. The code can also be used to create new environments with named constants.",
          "questions": "1. What is the purpose of the `ContractSyntax` trait and how is it used in the project?\n- The `ContractSyntax` trait defines methods to be used in contract implementations based on `SigmaContract`. It is used as a mixin trait with `SigmaContractSyntax` to provide additional functionality to `SigmaContract`.\n\n2. What is the purpose of the `proposition` method and how is it used?\n- The `proposition` method is used to define propositions in `SigmaContract` implementations. It takes in a name, a Scala lambda of type `Proposition`, a string representation of the contract in ErgoScript, and an optional script version. It returns a proposition specification with a compiled ErgoTree.\n\n3. What is the purpose of the `BooleanSyntax` class and how is it used?\n- The `BooleanSyntax` class provides logical AND and OR operations between a Boolean on the left and a `SigmaProp` value on the right. It is used as an implicit class in `SigmaContractSyntax` to provide additional syntax for `SigmaProp` operations."
        },
        {
          "fileName": "ErgoContractSpec.scala",
          "filePath": "sc/src/main/scala/org/ergoplatform/dsl/ErgoContractSpec.scala",
          "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/sc/src/main/scala/org/ergoplatform/dsl/ErgoContractSpec.scala",
          "summary": "The ErgoContractSpec class is a part of the Ergo Platform DSL (Domain Specific Language) project. This class provides a set of methods and traits that can be used to define and interact with Ergo contracts. \n\nThe ErgoContractSpec class extends the ContractSpec trait and imports several classes and traits from other packages. The class defines a case class called ErgoOutBox, which extends the OutBox trait. The ErgoOutBox class represents an output box in an Ergo transaction. It contains information about the transaction candidate, the index of the box in the transaction, the value of the box, and the proposition specification. The ErgoOutBox class also provides methods to manipulate the box's tokens and registers.\n\nThe ErgoContractSpec class also defines a trait called TransactionContext, which provides methods to interact with an Ergo transaction. The trait has three methods: block, attachProof, and submit. The block method returns the block candidate associated with the transaction. The attachProof method attaches proofs to the transaction. The submit method submits the transaction to the network.\n\nThe ErgoContractSpec class also provides several utility methods to interact with the Ergo blockchain. The getBlock method returns the block candidate at a given height. The getBoxesByParty method returns a sequence of output boxes associated with a given protocol party. The getBoxById method returns an output box with a given ID.\n\nFinally, the ErgoContractSpec class overrides two methods from the ContractSpec trait: mkPropositionSpec and mkProvingParty. The mkPropositionSpec method creates a proposition specification from a DSL specification and an ErgoScript. The mkProvingParty method creates a proving party with a given name. \n\nOverall, the ErgoContractSpec class provides a set of methods and traits that can be used to define and interact with Ergo contracts. It provides utility methods to interact with the Ergo blockchain and defines a case class to represent output boxes in Ergo transactions.",
          "questions": "1. What is the purpose of this code and what project is it a part of?\n- This code is a part of a project called `org.ergoplatform.dsl` and it defines classes and traits related to Ergo contracts and transactions.\n\n2. What is the `ErgoOutBox` class and what methods does it override?\n- `ErgoOutBox` is a case class that represents an output box in an Ergo transaction. It overrides methods for getting the box ID, adding tokens and registers to the box, getting a specific token, and getting the underlying Ergo box.\n\n3. What is the purpose of the `TransactionContext` trait and what methods does it define?\n- The `TransactionContext` trait defines methods for accessing the current block, attaching proofs to input boxes, and submitting the transaction. It is used to manage the context of a transaction being constructed."
        },
        {
          "fileName": "StdContracts.scala",
          "filePath": "sc/src/main/scala/org/ergoplatform/dsl/StdContracts.scala",
          "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/sc/src/main/scala/org/ergoplatform/dsl/StdContracts.scala",
          "summary": "The code above defines a trait called `StdContracts` which provides two methods for transferring assets in a transaction. The trait extends another trait called `ContractSyntax` which is not shown in this code snippet. \n\nThe first method, `transferErgWithChange`, takes in a `TransactionCandidate` object, an `OutBox` object representing the source of the Ergs, a `PropositionSpec` object representing the destination of the Ergs, and a `Long` value representing the amount of Ergs to transfer. The method returns a tuple containing an `OutBox` object representing the destination box and an optional `OutBox` object representing the change box. \n\nThe method first calculates the amount of Erg change that will be returned to the source box after the transfer. If the change is negative, an error is thrown indicating that there are not enough Ergs in the source box to complete the transfer. If the change is positive, a new `OutBox` object is created to represent the change box. \n\nThe destination box is then created using the `outBox` method of the `TransactionCandidate` object with the specified Erg amount and destination `PropositionSpec`. The method returns the destination box and the change box (if it exists). \n\nThe second method, `transferTokenWithChange`, is similar to the first method but also includes the transfer of a specified token amount. The method takes in a `Token` object representing the token to transfer in addition to the other parameters. \n\nThe method first calculates the amount of token change that will be returned to the source box after the transfer. If the change is negative, an error is thrown indicating that there are not enough tokens in the source box to complete the transfer. The method then calculates the amount of Erg change that will be returned to the source box after the transfer. If the Erg change is less than the minimum Erg value, an error is thrown indicating that there are not enough Ergs in the source box to create two boxes. \n\nThe destination box is then created using the `outBox` method of the `TransactionCandidate` object with the minimum Erg value and destination `PropositionSpec`. The token amount is added to the destination box using the `withTokens` method. If there is Erg change, a new `OutBox` object is created to represent the change box. The method returns the destination box and the change box (if it exists). \n\nThese methods can be used in the larger project to facilitate the transfer of Ergs and tokens between boxes in a transaction. The methods provide a convenient way to calculate the change that will be returned to the source box after the transfer. Developers can use these methods to simplify the process of creating transactions that involve the transfer of assets. \n\nExample usage:\n\n```\nval tx = new TransactionCandidate()\nval fromBox = new OutBox(...)\nval toSpec = new PropositionSpec(...)\nval ergAmt = 1000000L\nval tokenAmt = new Token(...)\nval (destBox, changeBox) = transferTokenWithChange(tx, fromBox, toSpec, tokenAmt)\n```",
          "questions": "1. What is the purpose of the `StdContracts` trait?\n- The `StdContracts` trait defines two methods for transferring Erg and tokens between `OutBox`es in a `TransactionCandidate`.\n\n2. What is the role of the `ContractSyntax` trait?\n- The `ContractSyntax` trait is a dependency of `StdContracts` and provides access to the `spec` object used in the transfer methods.\n\n3. What is the significance of the `error` method calls in the transfer methods?\n- The `error` method calls are used to throw an exception if there are insufficient funds or tokens to complete the transfer, preventing the transaction from being included in the blockchain."
        }
      ],
      "folders": [],
      "summary": "The `.autodoc/docs/json/sc/src/main/scala/org/ergoplatform/dsl` folder contains Scala code for defining and interacting with smart contracts on the Ergo blockchain platform. The code is organized into several files, each focusing on a specific aspect of contract interaction.\n\n`ContractSpec.scala` provides the main entry point for specifying and interacting with smart contracts. It defines several traits and objects, such as `PropositionSpec`, `ProvingParty`, `VerifyingParty`, `InputBox`, `OutBox`, `TransactionCandidate`, `ChainTransaction`, and `ChainBlock`. These traits and objects represent various components of a smart contract and provide methods for specifying, proving, verifying, and interacting with input and output boxes in transactions.\n\n`ContractSyntax.scala` extends the `SigmaContract` and provides methods and classes for contract implementations. It defines the `ContractSyntax` trait, which offers methods for creating propositions and environments. The `SigmaContractSyntax` trait extends `ContractSyntax` and provides additional methods for defining contracts using logical AND and OR operations between Boolean and SigmaProp values.\n\n`ErgoContractSpec.scala` extends the `ContractSpec` trait and provides methods and traits for defining and interacting with Ergo contracts. It defines the `ErgoOutBox` case class, which represents an output box in an Ergo transaction, and the `TransactionContext` trait, which provides methods for interacting with Ergo transactions. Additionally, it offers utility methods for interacting with the Ergo blockchain, such as `getBlock`, `getBoxesByParty`, and `getBoxById`.\n\n`StdContracts.scala` defines the `StdContracts` trait, which provides methods for transferring assets (Ergs and tokens) in a transaction. The methods `transferErgWithChange` and `transferTokenWithChange` facilitate the transfer of Ergs and tokens between boxes in a transaction while calculating the change returned to the source box.\n\nExample usage:\n\n```scala\nval tx = new TransactionCandidate()\nval fromBox = new OutBox(...)\nval toSpec = new PropositionSpec(...)\nval ergAmt = 1000000L\nval tokenAmt = new Token(...)\nval (destBox, changeBox) = transferTokenWithChange(tx, fromBox, toSpec, tokenAmt)\n```\n\nIn summary, this folder contains code for defining and interacting with smart contracts on the Ergo blockchain platform. Developers can use the provided traits, objects, and methods to create, prove, verify, and interact with Ergo contracts and transactions. The code also offers utility methods for transferring assets and interacting with the Ergo blockchain.",
      "questions": ""
    }
  ],
  "summary": "The code in the `ErgoScriptPredef.scala` file provides utility methods for compiling ErgoScript code and generating a script to check if a given box can be spent by a transaction containing a specific token amount. These methods are useful for developers working with the Ergo platform, as they simplify the process of creating and verifying scripts for transactions.\n\nThe `compileWithCosting` method takes a `ScriptEnv`, a string of code, and a `NetworkPrefix` as input and returns a `Value[SType]`. It compiles the given code using the `SigmaCompiler` and returns the resulting compiled code as a `Value[SType]`. The `IRContext` is an implicit parameter used by the `SigmaCompiler` to compile the code. This method can be used to compile ErgoScript code for various purposes, such as creating custom spending conditions for boxes.\n\nThe `tokenThresholdScript` method takes a `tokenId`, a `thresholdAmount`, and a `NetworkPrefix` as input and returns a `SigmaPropValue`. It generates a script that can be used to determine if a given box can be spent by a transaction containing at least `thresholdAmount` of the specified `tokenId`. The script is generated by compiling the provided code using the `compileWithCosting` method. The code for the script is a combination of three different versions, each of which uses different methods to calculate the sum of the token amounts. The resulting script checks if the sum of the token amounts is greater than or equal to the `thresholdAmount` and returns a `SigmaPropValue` that can be used to verify the script.\n\nExample usage:\n\n```scala\nval tokenId: Array[Byte] = Array(1, 2, 3)\nval thresholdAmount: Long = 1000\nval networkPrefix: NetworkPrefix = NetworkPrefix.MainnetPrefix\n\nval script: SigmaPropValue = ErgoScriptPredef.tokenThresholdScript(tokenId, thresholdAmount, networkPrefix)\n```\n\nThis code generates a script that can be used to verify if a given box can be spent by a transaction containing at least 1000 of the token with ID 010203. The resulting script is stored in the `script` variable as a `SigmaPropValue`.\n\nThe `.autodoc/docs/json/sc/src/main/scala/org/ergoplatform/dsl` folder contains code for defining and interacting with smart contracts on the Ergo blockchain platform. It provides traits, objects, and methods for specifying, proving, verifying, and interacting with input and output boxes in transactions. Developers can use the provided code to create, prove, verify, and interact with Ergo contracts and transactions, as well as transfer assets and interact with the Ergo blockchain.",
  "questions": ""
}