{
  "folderName": "eval",
  "folderPath": ".autodoc/docs/json/sc/src/main/scala/sigmastate/eval",
  "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/.autodoc/docs/json/sc/src/main/scala/sigmastate/eval",
  "files": [
    {
      "fileName": "IRContext.scala",
      "filePath": "sc/src/main/scala/sigmastate/eval/IRContext.scala",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/sc/src/main/scala/sigmastate/eval/IRContext.scala",
      "summary": "The code provided is a part of the SigmaState project and defines an IRContext trait and two classes, RuntimeIRContext and CompiletimeIRContext, that extend it. The IRContext trait provides methods and values that are used to build and manipulate SigmaState's intermediate representation (IR) of smart contracts. \n\nThe IRContext trait extends two other traits, TreeBuilding and GraphBuilding, which provide methods for building and manipulating the IR's abstract syntax tree and control flow graph, respectively. The trait also imports the SigmaProp object, which contains methods for creating and manipulating SigmaState's signature propositions. \n\nThe trait defines a builder value that is used to construct the IR, and a lazy value that defines a pass configuration that turns off constant propagation. The trait also defines two methods, findIsProven and verifyIsProven, that are used to check if a given lambda expression contains a call to the SigmaProp.isProven method and to verify that the call is the last operation in the lambda's schedule. \n\nThe RuntimeIRContext and CompiletimeIRContext classes extend the IRContext trait and are used in different contexts. The RuntimeIRContext is used by blockchain nodes to validate transactions, while the CompiletimeIRContext is used by script development tools to compile ErgoScript into ErgoTree bytecode. \n\nOverall, the code provides a set of tools and methods for building and manipulating SigmaState's IR, which is used to represent smart contracts in the Ergo blockchain. The IRContext trait and its subclasses are essential components of the SigmaState project and are used extensively throughout the codebase. \n\nExample usage:\n\n```\nval context = new RuntimeIRContext()\nval lambda = context.builder.lambda { (ctx: Context) =>\n  val input = ctx.INPUTS(0)\n  val output = ctx.OUTPUTS(0)\n  SigmaProp.isProven(input.propositionBytes) && !SigmaProp.isProven(output.propositionBytes)\n}\ncontext.verifyIsProven(lambda) // returns Success(())\n```",
      "questions": "1. What is the purpose of the `IRContext` trait and its two subclasses `RuntimeIRContext` and `CompiletimeIRContext`?\n   \n   The `IRContext` trait defines methods and values related to building and manipulating Sigma protocols. `RuntimeIRContext` is used for validating transactions on the blockchain, while `CompiletimeIRContext` is used for compiling ErgoScript into ErgoTree bytecode during script development.\n\n2. What is the purpose of the `noConstPropagationPass` value?\n   \n   `noConstPropagationPass` is a configuration value used to turn off constant propagation during a pass. It is used in the `beginPass` method to disable constant propagation for a specific pass.\n\n3. What is the purpose of the `verifyIsProven` method?\n   \n   `verifyIsProven` checks that if `SigmaProp.isProven` method calls exist in the given Lambda's schedule, then it is the last operation. This is important for ensuring that the proof system is used correctly."
    },
    {
      "fileName": "TreeBuilding.scala",
      "filePath": "sc/src/main/scala/sigmastate/eval/TreeBuilding.scala",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/sc/src/main/scala/sigmastate/eval/TreeBuilding.scala",
      "summary": "The `TreeBuilding` trait is responsible for transforming a graph-based intermediate representation (IR) of a function into an ErgoTree expression. ErgoTree is a language used in Ergo Platform to represent complex spending conditions for a transaction output. This trait is a part of the SigmaState project, which is a core component of the Ergo Platform.\n\nThe main function of this trait is `buildTree`, which takes a function `f` from graph-based IR and an optional `constantsProcessing` parameter. If `constantsProcessing` is specified, each constant is segregated, and a placeholder is inserted in the resulting expression. The `buildTree` function returns an ErgoTree expression that corresponds to the input function `f`.\n\nThe trait contains several helper objects and methods to process different types of operations, such as arithmetic, relational, logical, and context property operations. These helper objects and methods are used in the recursive process of building the ErgoTree expression.\n\nThe `processAstGraph` method is responsible for transforming an AstGraph node (Lambda or Thunk) into the corresponding ErgoTree node. It is mutually recursive with the `buildValue` method, which transforms a given graph node into the corresponding ErgoTree node. These two methods form the core of the recursive algorithm required by the `buildTree` method.\n\nIn summary, the `TreeBuilding` trait is a crucial component in the SigmaState project, as it enables the conversion of graph-based IR functions into ErgoTree expressions, which are used to represent complex spending conditions in the Ergo Platform.",
      "questions": "1. **Question**: What is the purpose of the `TreeBuilding` trait and how does it work?\n   \n   **Answer**: The `TreeBuilding` trait is responsible for transforming a given function from a graph-based intermediate representation (IR) to an ErgoTree expression. It does this by recursively processing the graph nodes and building the corresponding ErgoTree nodes using various helper methods and pattern matching.\n\n2. **Question**: What is the role of the `buildValue` method in the `TreeBuilding` trait?\n\n   **Answer**: The `buildValue` method is responsible for transforming a given graph node into the corresponding ErgoTree node. It is mutually recursive with the `processAstGraph` method and is part of the recursive algorithms required by the `buildTree` method.\n\n3. **Question**: How does the `constantsProcessing` parameter affect the behavior of the `buildTree` method?\n\n   **Answer**: The `constantsProcessing` parameter, when set to `Some(store)`, segregates each constant in the resulting expression and inserts a placeholder for it. This is useful for optimizing the resulting ErgoTree expression by separating constants from the main expression."
    }
  ],
  "folders": [],
  "summary": "The `.autodoc/docs/json/sc/src/main/scala/sigmastate/eval` folder contains essential components for building and manipulating SigmaState's intermediate representation (IR) of smart contracts in the Ergo blockchain. The folder includes two files: `IRContext.scala` and `TreeBuilding.scala`.\n\n`IRContext.scala` defines the `IRContext` trait, which provides methods and values for building and manipulating the IR of smart contracts. It extends two other traits, `TreeBuilding` and `GraphBuilding`, which provide methods for building and manipulating the IR's abstract syntax tree and control flow graph, respectively. The trait also imports the `SigmaProp` object, which contains methods for creating and manipulating SigmaState's signature propositions.\n\nThe `IRContext` trait is extended by two classes, `RuntimeIRContext` and `CompiletimeIRContext`, which are used in different contexts. The `RuntimeIRContext` is used by blockchain nodes to validate transactions, while the `CompiletimeIRContext` is used by script development tools to compile ErgoScript into ErgoTree bytecode.\n\nExample usage:\n\n```scala\nval context = new RuntimeIRContext()\nval lambda = context.builder.lambda { (ctx: Context) =>\n  val input = ctx.INPUTS(0)\n  val output = ctx.OUTPUTS(0)\n  SigmaProp.isProven(input.propositionBytes) && !SigmaProp.isProven(output.propositionBytes)\n}\ncontext.verifyIsProven(lambda) // returns Success(())\n```\n\n`TreeBuilding.scala` contains the `TreeBuilding` trait, which is responsible for transforming a graph-based IR of a function into an ErgoTree expression. ErgoTree is a language used in Ergo Platform to represent complex spending conditions for a transaction output. The main function of this trait is `buildTree`, which takes a function `f` from graph-based IR and an optional `constantsProcessing` parameter. If `constantsProcessing` is specified, each constant is segregated, and a placeholder is inserted in the resulting expression. The `buildTree` function returns an ErgoTree expression that corresponds to the input function `f`.\n\nThe trait contains several helper objects and methods to process different types of operations, such as arithmetic, relational, logical, and context property operations. These helper objects and methods are used in the recursive process of building the ErgoTree expression.\n\nIn summary, the code in this folder provides a set of tools and methods for building and manipulating SigmaState's IR, which is used to represent smart contracts in the Ergo blockchain. The `IRContext` trait and its subclasses, along with the `TreeBuilding` trait, are essential components of the SigmaState project and are used extensively throughout the codebase.",
  "questions": ""
}