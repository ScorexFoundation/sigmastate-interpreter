{
  "folderName": "lang",
  "folderPath": ".autodoc/docs/json/sc/src/main/scala/sigmastate/lang",
  "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/.autodoc/docs/json/sc/src/main/scala/sigmastate/lang",
  "files": [
    {
      "fileName": "SigmaBinder.scala",
      "filePath": "sc/src/main/scala/sigmastate/lang/SigmaBinder.scala",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/sc/src/main/scala/sigmastate/lang/SigmaBinder.scala",
      "summary": "The code in this file is part of the Sigma programming language implementation and provides a class called `SigmaBinder` that is responsible for resolving references to global names and inferring their types. The class takes an instance of `ScriptEnv`, `SigmaBuilder`, `NetworkPrefix`, and `PredefinedFuncRegistry` as input parameters. The `ScriptEnv` is a map of global names to their values, while `SigmaBuilder` is used to construct the AST of the program. `NetworkPrefix` is used to decode an Ergo address from a string, and `PredefinedFuncRegistry` is a registry of predefined functions.\n\nThe `SigmaBinder` class has a single public method called `bind` that takes an `SValue` as input and returns a new `SValue` with all references to global names resolved and their types inferred. The `bind` method calls the private `eval` method to perform the actual rewriting of the AST. The `eval` method uses the Kiama library to traverse the AST and apply a set of rules to rewrite it. The rules include resolving references to global names, inferring their types, and rewriting lambda expressions, collections, and other constructs.\n\nThe `SigmaBinder` class also includes an object called `SrcCtxCallbackRewriter` that extends the `CallbackRewriter` trait. This object is used to rewrite the source context of an `SValue` when it is replaced by a new `SValue`. This is done to preserve the source context of the original `SValue` in the new `SValue`.\n\nOverall, the `SigmaBinder` class is an important component of the Sigma programming language implementation that is used to resolve references to global names and infer their types. It is used extensively throughout the Sigma compiler and runtime to ensure that programs are well-typed and free of errors.",
      "questions": "1. What is the purpose of the `SigmaBinder` class?\n- The `SigmaBinder` class is used to rewrite the AST with respect to the environment to resolve all references to global names and infer their types.\n\n2. What is the purpose of the `SrcCtxCallbackRewriter` object?\n- The `SrcCtxCallbackRewriter` object is used to rewrite the source context of a new term to match the source context of the old term.\n\n3. What are some of the predefined global names that can be referenced in the `eval` method of the `SigmaBinder` class?\n- Some of the predefined global names that can be referenced in the `eval` method of the `SigmaBinder` class include `HEIGHT`, `MinerPubkey`, `INPUTS`, `OUTPUTS`, `LastBlockUtxoRootHash`, `EmptyByteArray`, `SELF`, `CONTEXT`, `Global`, and `None`."
    },
    {
      "fileName": "SigmaCompiler.scala",
      "filePath": "sc/src/main/scala/sigmastate/lang/SigmaCompiler.scala",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/sc/src/main/scala/sigmastate/lang/SigmaCompiler.scala",
      "summary": "The `SigmaCompiler` class in the `sigmastate.lang` package is responsible for compiling ErgoScript source code into executable code. The class takes in a `CompilerSettings` object that specifies the network prefix, builder, and whether to lower method calls. The `SigmaCompiler` class has several methods that parse, typecheck, and compile ErgoScript code.\n\nThe `parse` method takes in a string of ErgoScript source code and returns an expression tree. The `typecheck` method takes in a `ScriptEnv` object and a parsed expression tree and assigns types to all sub-expressions. The `compile` method takes in a `ScriptEnv` object and a string of ErgoScript source code and returns a `CompilerResult` object that contains the compiled code, the compiled graph, and the expression tree obtained from the graph created by `GraphBuilding`. The `compileTyped` method takes in a `ScriptEnv` object and a typed expression and returns a `CompilerResult` object that contains the compiled code, the compiled graph, and the expression tree obtained from the graph created by `GraphBuilding`.\n\nThe `unlowerMethodCalls` method is used to lower MethodCall nodes to ErgoTree nodes. This is done when `lowerMethodCalls` is set to true in the `CompilerSettings` object. The method takes in an expression tree and returns a modified expression tree where MethodCall nodes have been replaced with ErgoTree nodes.\n\nThe `SigmaCompiler` class is used in the larger project to compile ErgoScript source code into executable code. It is used by other classes and methods in the project that need to execute ErgoScript code. For example, it may be used by a smart contract that needs to execute ErgoScript code to validate a transaction. \n\nExample usage:\n\n```\nval settings = CompilerSettings(NetworkPrefix.Testnet)\nval compiler = SigmaCompiler(settings)\nval env = ScriptEnv.Empty\nval code = \"HEIGHT > 1000\"\nval result = compiler.compile(env, code)\nval compiledCode = result.code\nval compiledGraph = result.compiledGraph\nval buildTree = result.buildTree\n```",
      "questions": "1. What is the purpose of the `SigmaCompiler` class?\n- The `SigmaCompiler` class is used to parse, typecheck, and compile ErgoScript source code, and to unlower method calls.\n\n2. What is the significance of the `CompilerSettings` case class?\n- The `CompilerSettings` case class contains settings for the `SigmaCompiler`, such as the network prefix, builder, and whether to lower method calls.\n\n3. What is the purpose of the `unlowerMethodCalls` method?\n- The `unlowerMethodCalls` method is used to convert lowered method calls back into their original form, such as converting a `MapCollection` node to a `MethodCall` node with the `MapMethod`."
    },
    {
      "fileName": "SigmaTyper.scala",
      "filePath": "sc/src/main/scala/sigmastate/lang/SigmaTyper.scala",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/sc/src/main/scala/sigmastate/lang/SigmaTyper.scala",
      "summary": "The `SigmaTyper` class is responsible for type inference and analysis of Sigma expressions. It takes a `SigmaBuilder`, `PredefinedFuncRegistry`, and a `lowerMethodCalls` flag as input parameters. The main function of this class is `assignType`, which takes an environment, a bound value, and an optional expected type as input parameters. It recursively traverses the input expression tree and assigns types to each node, checking for type consistency and correctness.\n\nThe `assignType` function handles various cases, such as:\n\n- `Block`: It processes a block of expressions, updating the environment with new variable bindings and their types.\n- `Tuple`: It assigns types to each element of the tuple.\n- `ConcreteCollection`: It assigns types to each element of the collection and ensures that all elements have the same type.\n- `Ident`: It looks up the type of the identifier in the environment or the global method registry.\n- `Select`: It assigns types to the object and its fields, handling method calls and property access.\n- `Lambda`: It assigns types to the lambda function's arguments and body, ensuring that the declared return type matches the inferred type of the body.\n- `Apply`: It assigns types to the function and its arguments, ensuring that the function's argument types match the expected types.\n- `ApplyTypes`: It assigns types to the input expression and checks that the number of type arguments matches the expected number of type parameters.\n- `If`: It assigns types to",
      "questions": "1. **Question**: What is the purpose of the `SigmaTyper` class?\n   **Answer**: The `SigmaTyper` class is responsible for type inference and analysis for Sigma expressions. It checks constituent names and types, and uses the environment map to resolve bound variables and their types.\n\n2. **Question**: How does the `assignType` method work?\n   **Answer**: The `assignType` method takes an environment, a bound value, and an optional expected type as input. It recursively processes the bound value based on its structure and assigns appropriate types to its constituents, using the environment to resolve variables and their types.\n\n3. **Question**: What is the role of the `predefinedEnv` variable in the `SigmaTyper` class?\n   **Answer**: The `predefinedEnv` variable is a map that holds the predefined functions and their corresponding types. It is used by the `assignType` method to resolve variables and their types during type inference and analysis."
    }
  ],
  "folders": [],
  "summary": "The `sigmastate.lang` package in the `.autodoc/docs/json/sc/src/main/scala` folder contains essential components for the Sigma programming language implementation, focusing on compiling, type inference, and binding of global names.\n\n`SigmaBinder.scala` provides the `SigmaBinder` class, which resolves references to global names and infers their types. It takes a `ScriptEnv`, `SigmaBuilder`, `NetworkPrefix`, and `PredefinedFuncRegistry` as input parameters. The `bind` method is the main public method that takes an `SValue` as input and returns a new `SValue` with resolved references and inferred types. This class is crucial for ensuring that Sigma programs are well-typed and error-free.\n\n`SigmaCompiler.scala` is responsible for compiling ErgoScript source code into executable code. It takes a `CompilerSettings` object as input and provides methods for parsing, typechecking, and compiling ErgoScript code. The `compile` method returns a `CompilerResult` object containing the compiled code, graph, and expression tree. This class is used by other parts of the project that need to execute ErgoScript code, such as smart contracts validating transactions.\n\nExample usage:\n\n```scala\nval settings = CompilerSettings(NetworkPrefix.Testnet)\nval compiler = SigmaCompiler(settings)\nval env = ScriptEnv.Empty\nval code = \"HEIGHT > 1000\"\nval result = compiler.compile(env, code)\nval compiledCode = result.code\nval compiledGraph = result.compiledGraph\nval buildTree = result.buildTree\n```\n\n`SigmaTyper.scala` handles type inference and analysis of Sigma expressions. It takes a `SigmaBuilder`, `PredefinedFuncRegistry`, and a `lowerMethodCalls` flag as input parameters. The main function, `assignType`, recursively traverses the input expression tree, assigns types to each node, and checks for type consistency and correctness. This class is essential for ensuring that Sigma programs are well-typed and error-free.\n\nIn summary, the `sigmastate.lang` package provides essential components for the Sigma programming language implementation, focusing on compiling, type inference, and binding of global names. These components are used extensively throughout the Sigma compiler and runtime to ensure that programs are well-typed and free of errors.",
  "questions": ""
}