{
  "folderName": "utxo",
  "folderPath": ".autodoc/docs/json/interpreter/shared/src/main/scala/sigmastate/utxo",
  "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/.autodoc/docs/json/interpreter/shared/src/main/scala/sigmastate/utxo",
  "files": [
    {
      "fileName": "ComplexityTable.scala",
      "filePath": "interpreter/shared/src/main/scala/sigmastate/utxo/ComplexityTable.scala",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/interpreter/shared/src/main/scala/sigmastate/utxo/ComplexityTable.scala",
      "summary": "The `ComplexityTable` object in the `sigmastate.utxo` package is used to store the complexity values of various operations and method calls in the ErgoScript language. These complexity values are used to estimate the computational cost of executing a given ErgoScript, which is important for ensuring that scripts do not consume excessive resources during execution.\n\nThe `ComplexityTable` object contains two maps: `OpCodeComplexity` and `MethodCallComplexity`. The `OpCodeComplexity` map stores the complexity values for various operations, such as arithmetic, logical, and collection operations. The keys in this map are the operation codes (`OpCode`), and the values are the corresponding complexity values. The `MethodCallComplexity` map stores the complexity values for method calls on specific types, such as `AvlTree`, `SCollection`, and `Context`. The keys in this map are tuples of two bytes, where the first byte represents the type identifier and the second byte represents the method identifier. The values are the corresponding complexity values.\n\nFor example, the complexity of the `Fold` operation is 4034, and the complexity of the `AvlTree.update` method call is 3911. These values are used by the ErgoScript interpreter to estimate the total complexity of a given script, which can then be used to determine if the script is within acceptable resource limits for execution.\n\nHere's an example of how the complexity values might be used:\n\n```scala\nval scriptComplexity = script.operations.map(op => ComplexityTable.OpCodeComplexity(op.opCode)).sum +\n                       script.methodCalls.map(mc => ComplexityTable.MethodCallComplexity((mc.typeId, mc.methodId))).sum\nif (scriptComplexity > maxAllowedComplexity) {\n  // Reject the script as too complex\n} else {\n  // Execute the script\n}\n```\n\nIn this example, the complexity values for all operations and method calls in the script are summed up, and the total complexity is compared against a predefined maximum allowed complexity. If the script's complexity exceeds the maximum, it is rejected; otherwise, it is executed.",
      "questions": "1. **Question**: What is the purpose of the `ComplexityTable` object in this code?\n   **Answer**: The `ComplexityTable` object contains two maps, `OpCodeComplexity` and `MethodCallComplexity`, which store the complexity values for various opcodes and method calls used in the project. These values can be used to estimate the computational complexity of certain operations in the code.\n\n2. **Question**: How are the complexity values in the `OpCodeComplexity` and `MethodCallComplexity` maps determined?\n   **Answer**: The complexity values in the maps are hard-coded and seem to be based on some pre-determined analysis or benchmarking of the operations. The comments next to each entry indicate the count of occurrences for each operation, which might have been used to calculate the complexity values.\n\n3. **Question**: What is the significance of the `MinimalComplexity` constant in the code?\n   **Answer**: The `MinimalComplexity` constant is set to 100 and represents the minimum complexity value that can be assigned to an operation. This can be used as a baseline for comparing the complexity of different operations in the code."
    },
    {
      "fileName": "ComplexityTableStat.scala",
      "filePath": "interpreter/shared/src/main/scala/sigmastate/utxo/ComplexityTableStat.scala",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/interpreter/shared/src/main/scala/sigmastate/utxo/ComplexityTableStat.scala",
      "summary": "The `ComplexityTableStat` object contains methods for tracking and reporting the execution times of op codes and method calls in the `sigmastate.utxo` package. \n\nThe `StatItem` class is a private mutable class that stores the count and sum of execution times for a given operation. The `opStat` and `mcStat` mutable hash maps store the execution times for op codes and method calls, respectively. \n\nThe `addOpTime` method takes an op code and execution time as input and updates the corresponding `StatItem` in `opStat`. If the op code is not already in `opStat`, a new `StatItem` is created and added to the map. \n\nThe `addMcTime` method takes a type ID, method ID, and execution time as input and updates the corresponding `StatItem` in `mcStat`. If the type ID and method ID are not already in `mcStat`, a new `StatItem` is created and added to the map. \n\nThe `complexityTableString` method generates a string representation of the execution times for op codes and method calls. It first generates a list of tuples containing the op code or method call name, ID, average execution time, and count. It then sorts the list by execution time in descending order. \n\nThe method then generates two separate lists of strings, one for op codes and one for method calls. Each string in the list contains the name or ID of the op code or method call, the average execution time in microseconds, and the count of executions. \n\nThe final output is a string containing the two lists of op codes and method calls, separated by a line of dashes. \n\nThis code can be used to analyze the performance of different operations and method calls in the `sigmastate.utxo` package. By calling the `addOpTime` and `addMcTime` methods at various points in the code, developers can track the execution times of specific operations and method calls. The `complexityTableString` method can then be used to generate a report of the execution times, which can be used to identify performance bottlenecks and optimize the code. \n\nExample usage:\n\n```\n// track execution time of an op code\nval startTime = System.nanoTime()\n// execute op code\nval endTime = System.nanoTime()\nval elapsedTime = endTime - startTime\nComplexityTableStat.addOpTime(opCode, elapsedTime)\n\n// track execution time of a method call\nval startTime = System.nanoTime()\n// call method\nval endTime = System.nanoTime()\nval elapsedTime = endTime - startTime\nComplexityTableStat.addMcTime(typeId, methodId, elapsedTime)\n\n// generate report of execution times\nval report = ComplexityTableStat.complexityTableString\n```",
      "questions": "1. What is the purpose of the `ComplexityTableStat` object?\n- The `ComplexityTableStat` object is used to collect and store timing statistics for op codes and method calls in the `sigmastate` package.\n\n2. What data structures are used to store the timing statistics?\n- The timing statistics for op codes and method calls are stored in mutable hash maps called `opStat` and `mcStat`, respectively.\n\n3. What is the output format of the `complexityTableString` method?\n- The `complexityTableString` method outputs a formatted string that displays the average execution time and count for each op code and method call, sorted by decreasing execution time. The op codes and method calls are displayed separately in two sections, each with their own header and divider lines."
    },
    {
      "fileName": "transformers.scala",
      "filePath": "interpreter/shared/src/main/scala/sigmastate/utxo/transformers.scala",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/interpreter/shared/src/main/scala/sigmastate/utxo/transformers.scala",
      "summary": "This code is part of the SigmaState UTXO package and provides a set of transformers and operations that can be applied to collections, boxes, and other data structures in the Ergo platform. These transformers are used to manipulate and extract information from data structures, such as filtering, mapping, and folding over collections, as well as extracting specific fields from tuples and boxes.\n\nFor example, the `MapCollection` case class takes an input collection and a mapper function, and applies the function to each element of the collection, creating a new collection with the transformed elements. Similarly, the `Filter` case class takes an input collection and a condition function, and returns a new collection containing only the elements that satisfy the condition.\n\nOther transformers in this code include `Append`, `Slice`, `Exists`, `ForAll`, `Fold`, `ByIndex`, `SelectField`, `SigmaPropIsProven`, `SigmaPropBytes`, and various `Extract` operations for extracting specific fields from boxes, such as `ExtractAmount`, `ExtractScriptBytes`, `ExtractBytes`, `ExtractBytesWithNoRef`, `ExtractId`, and `ExtractCreationInfo`.\n\nAdditionally, there are operations for working with optional values, such as `OptionGet`, `OptionGetOrElse`, and `OptionIsDefined`, as well as operations for deserializing and working with context variables, like `DeserializeContext`, `DeserializeRegister`, and `GetVar`.\n\nThese transformers and operations are essential for processing and manipulating data within the Ergo platform, and they can be used in various parts of the project to perform complex data transformations and validations.",
      "questions": "1. **What is the purpose of the `Transformer` trait?**\n\n   The `Transformer` trait is used to represent operations that transform some input value of type `IV` into an output value of type `OV`. It is mainly used to simplify the implementation and avoid code duplication.\n\n2. **How does the `MapCollection` case class work?**\n\n   The `MapCollection` case class represents an operation that applies a given function `mapper` to all elements of an input collection and returns a new collection with the results. It takes an input collection of type `SCollection[IV]` and a mapper function of type `SFunc`, and returns a new collection of type `SCollection[OV]`.\n\n3. **What is the purpose of the `BooleanTransformer` trait?**\n\n   The `BooleanTransformer` trait is used to represent operations that transform a collection of values into a boolean value. It is a subtype of the `Transformer` trait and has an input of type `SCollection[IV]` and an output of type `SBoolean.type`. Examples of such operations are `Exists` and `ForAll`, which test whether a predicate holds for at least one element or all elements of a collection, respectively."
    }
  ],
  "folders": [],
  "summary": "The code in the `.autodoc/docs/json/interpreter/shared/src/main/scala/sigmastate/utxo` folder is part of the SigmaState UTXO package and is responsible for handling the complexity estimation and execution of ErgoScript operations and method calls, as well as providing a set of transformers and operations for manipulating data structures within the Ergo platform.\n\n`ComplexityTable.scala` contains the `ComplexityTable` object, which stores the complexity values of various operations and method calls in the ErgoScript language. These values are used to estimate the computational cost of executing a given ErgoScript, ensuring that scripts do not consume excessive resources during execution. For example:\n\n```scala\nval scriptComplexity = script.operations.map(op => ComplexityTable.OpCodeComplexity(op.opCode)).sum +\n                       script.methodCalls.map(mc => ComplexityTable.MethodCallComplexity((mc.typeId, mc.methodId))).sum\nif (scriptComplexity > maxAllowedComplexity) {\n  // Reject the script as too complex\n} else {\n  // Execute the script\n}\n```\n\n`ComplexityTableStat.scala` provides methods for tracking and reporting the execution times of op codes and method calls in the `sigmastate.utxo` package. Developers can use this code to analyze the performance of different operations and method calls, identify performance bottlenecks, and optimize the code. Example usage:\n\n```scala\n// track execution time of an op code\nval startTime = System.nanoTime()\n// execute op code\nval endTime = System.nanoTime()\nval elapsedTime = endTime - startTime\nComplexityTableStat.addOpTime(opCode, elapsedTime)\n\n// track execution time of a method call\nval startTime = System.nanoTime()\n// call method\nval endTime = System.nanoTime()\nval elapsedTime = endTime - startTime\nComplexityTableStat.addMcTime(typeId, methodId, elapsedTime)\n\n// generate report of execution times\nval report = ComplexityTableStat.complexityTableString\n```\n\n`transformers.scala` provides a set of transformers and operations that can be applied to collections, boxes, and other data structures in the Ergo platform. These transformers are used to manipulate and extract information from data structures, such as filtering, mapping, and folding over collections, as well as extracting specific fields from tuples and boxes. For example:\n\n```scala\n// map a collection using a custom function\nval inputCollection: SCollection[Int] = ...\nval mapperFunction: SFunc = ...\nval mappedCollection = MapCollection(inputCollection, mapperFunction)\n\n// filter a collection based on a condition\nval inputCollection: SCollection[Int] = ...\nval conditionFunction: SFunc = ...\nval filteredCollection = Filter(inputCollection, conditionFunction)\n```\n\nThese transformers and operations are essential for processing and manipulating data within the Ergo platform and can be used in various parts of the project to perform complex data transformations and validations.",
  "questions": ""
}