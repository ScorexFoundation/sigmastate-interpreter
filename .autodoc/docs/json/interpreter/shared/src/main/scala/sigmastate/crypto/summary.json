{
  "folderName": "crypto",
  "folderPath": ".autodoc/docs/json/interpreter/shared/src/main/scala/sigmastate/crypto",
  "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/.autodoc/docs/json/interpreter/shared/src/main/scala/sigmastate/crypto",
  "files": [
    {
      "fileName": "BigIntegers.scala",
      "filePath": "interpreter/shared/src/main/scala/sigmastate/crypto/BigIntegers.scala",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/interpreter/shared/src/main/scala/sigmastate/crypto/BigIntegers.scala",
      "summary": "The `BigIntegers` object in the `sigmastate.crypto` package provides utility functions for working with `BigInteger` objects in Scala. \n\nThe `createRandom` method generates a random byte array of length `nBytes` (calculated from the input `bitLength`), and then strips off any excess bits in the most significant byte to ensure that the resulting `BigInteger` has the desired bit length. This method is used internally by the other methods in the object to generate random `BigInteger` values.\n\nThe `createRandomBigInteger` method generates a random `BigInteger` with the specified bit length using the `createRandom` method. The resulting `BigInteger` is guaranteed to be positive.\n\nThe `createRandomInRange` method generates a random `BigInteger` between the specified `min` and `max` values (inclusive) using the `createRandomBigInteger` method. If `min` is greater than `max`, the method throws an `IllegalArgumentException`. If `min` has a bit length greater than half of `max`'s bit length, the method recursively calls itself with `min` set to 0 and `max` set to `max - min`, and then adds `min` to the resulting `BigInteger`. This is done to avoid bias in the random number generation when the range is small compared to the maximum possible value of a `BigInteger`. If the maximum number of iterations is reached without finding a suitable `BigInteger`, the method falls back to a faster (but less secure) method of generating a random `BigInteger`.\n\nThe `asUnsignedByteArray` methods convert a `BigInteger` to an unsigned byte array of the specified length. The first method pads the resulting byte array with leading zeros as necessary, while the second method removes any leading zero byte that may be present in the signed encoding of the `BigInteger`.\n\nOverall, the `BigIntegers` object provides convenient methods for generating and manipulating random `BigInteger` values in a secure and unbiased manner. These methods may be used in various cryptographic protocols and applications that require the use of large integers. \n\nExample usage:\n\n```scala\nimport sigmastate.crypto.BigIntegers\nimport scala.util.Random\n\nval random = new Random()\n\n// Generate a random 256-bit positive BigInteger\nval randomBigInt = BigIntegers.createRandomBigInteger(256, random)\n\n// Generate a random BigInteger between 100 and 200 (inclusive)\nval min = new BigInteger(\"100\")\nval max = new BigInteger(\"200\")\nval randomInRange = BigIntegers.createRandomInRange(min, max, random)\n\n// Convert a BigInteger to an unsigned byte array of length 32\nval byteArray = BigIntegers.asUnsignedByteArray(32, randomBigInt)\n```",
      "questions": "1. What is the purpose of this code?\n- This code provides utility functions for working with BigIntegers in the context of cryptography, including generating random BigIntegers and converting them to byte arrays.\n\n2. What is the significance of the MAX_ITERATIONS constant?\n- The MAX_ITERATIONS constant is used as a limit for the number of attempts to generate a random BigInteger within a specified range. If the limit is reached without finding a suitable value, a fallback method is used.\n\n3. Why is the asUnsignedByteArray method necessary?\n- The asUnsignedByteArray method is necessary because the toByteArray method of BigInteger includes a leading sign bit, which may cause issues when working with cryptographic protocols that require unsigned byte arrays. This method removes the sign bit and pads the resulting byte array with leading zeros as necessary."
    },
    {
      "fileName": "CryptoContext.scala",
      "filePath": "interpreter/shared/src/main/scala/sigmastate/crypto/CryptoContext.scala",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/interpreter/shared/src/main/scala/sigmastate/crypto/CryptoContext.scala",
      "summary": "The code above defines an abstract class called CryptoContext, which serves as a blueprint for implementing cryptographic operations in a larger project. The class contains several abstract methods that must be implemented by any concrete class that extends it. \n\nThe first two methods, getModulus and getOrder, return BigInteger values that represent the modulus and order of the elliptic curve used in the cryptographic operations. These values are important for ensuring the security of the cryptographic system. \n\nThe next three methods, validatePoint, getInfinity, and decodePoint, all deal with elliptic curve points. The validatePoint method takes two BigInteger values, x and y, and returns an Ecp object that represents a point on the elliptic curve. This method is used to validate that a given point is indeed on the curve. The getInfinity method returns an Ecp object that represents the point at infinity on the elliptic curve. Finally, the decodePoint method takes an array of bytes that represents a point on the curve and returns an Ecp object that represents that point. \n\nThe last method, getGenerator, returns an Ecp object that represents the generator point of the elliptic curve. This point is used in various cryptographic operations, such as key generation and signature verification. \n\nOverall, the CryptoContext class provides a high-level interface for performing cryptographic operations using elliptic curves. Concrete classes that extend this class can implement the abstract methods to provide specific functionality for a particular elliptic curve. \n\nExample usage:\n\n```\n// create a concrete class that extends CryptoContext\nclass MyCryptoContext extends CryptoContext {\n  def getModulus: BigInteger = ...\n\n  def getOrder: BigInteger = ...\n\n  def validatePoint(x: BigInteger, y: BigInteger): Ecp = ...\n\n  def getInfinity(): Ecp = ...\n\n  def decodePoint(encoded: Array[Byte]): Ecp = ...\n\n  def getGenerator: Ecp = ...\n}\n\n// use the concrete class to perform cryptographic operations\nval context = new MyCryptoContext()\nval point = context.validatePoint(x, y)\nval generator = context.getGenerator()\n```",
      "questions": "1. What is the purpose of this `CryptoContext` class?\n   - The `CryptoContext` class is an abstract class that defines methods for working with elliptic curve cryptography, including getting the modulus and order, validating points, getting the infinity point, decoding points, and getting the generator.\n\n2. What is the `Ecp` class and how is it related to this `CryptoContext` class?\n   - The `Ecp` class is likely a class that represents a point on an elliptic curve. It is related to the `CryptoContext` class because several of the methods in `CryptoContext` take `Ecp` objects as parameters or return them.\n\n3. What is the expected input and output of the `validatePoint` method?\n   - The `validatePoint` method takes two `BigInteger` parameters (`x` and `y`) that likely represent the coordinates of a point on an elliptic curve. It returns an `Ecp` object, which may represent the same point if it is valid, or throw an exception if it is not valid."
    },
    {
      "fileName": "CryptoFacade.scala",
      "filePath": "interpreter/shared/src/main/scala/sigmastate/crypto/CryptoFacade.scala",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/interpreter/shared/src/main/scala/sigmastate/crypto/CryptoFacade.scala",
      "summary": "The `CryptoFacade` object in the `sigmastate.crypto` package provides a set of utility functions for cryptographic operations used in the larger project. \n\nThe object defines several constants, including `Encoding`, which is set to \"UTF-8\", `SecretKeyLength`, which is set to 32, and `BitcoinSeed`, which is an array of bytes representing the string \"Bitcoin seed\". It also defines `Pbkdf2Algorithm`, which is set to \"PBKDF2WithHmacSHA512\", `Pbkdf2Iterations`, which is set to 2048, and `Pbkdf2KeyLength`, which is set to 512. These constants are used in various functions defined in the object.\n\nThe object defines several utility functions for elliptic curve cryptography (ECC) operations, including `normalizePoint`, `negatePoint`, `isInfinityPoint`, `exponentiatePoint`, `multiplyPoints`, `showPoint`, `testBitZeroOfFieldElem`, `getEncodedOfFieldElem`, `getEncodedPoint`, `getXCoord`, `getYCoord`, `getAffineXCoord`, and `getAffineYCoord`. These functions take as input and output various ECC-related data types, such as `Ecp` and `ECFieldElem`. These functions are used to perform ECC operations in the larger project.\n\nThe object also defines several utility functions for generating and manipulating cryptographic keys and random numbers, including `createSecureRandom`, `hashHmacSHA512`, and `generatePbkdf2Key`. These functions are used to generate and manipulate cryptographic keys and random numbers in the larger project.\n\nFinally, the object defines a function `normalizeChars` that normalizes a sequence of char values using NFKD normalization form. This function is used to normalize mnemonic phrases and passwords before generating a PBKDF2 key.\n\nOverall, the `CryptoFacade` object provides a set of utility functions for performing various cryptographic operations used in the larger project, including ECC operations, key generation and manipulation, and random number generation.",
      "questions": "1. What is the purpose of the CryptoFacade object?\n- The CryptoFacade object provides various utility functions related to cryptography, such as point operations, random number generation, and key derivation.\n\n2. What is the significance of the BitcoinSeed constant?\n- The BitcoinSeed constant is used as the key parameter for the hashHmacSHA512 function, which is used in key derivation.\n\n3. What is the role of the Platform object in this code?\n- The Platform object provides an abstraction layer for platform-specific implementations of cryptographic operations, allowing the code to be used across different platforms."
    },
    {
      "fileName": "GF2_192_Poly.scala",
      "filePath": "interpreter/shared/src/main/scala/sigmastate/crypto/GF2_192_Poly.scala",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/interpreter/shared/src/main/scala/sigmastate/crypto/GF2_192_Poly.scala",
      "summary": "The GF2_192_Poly class is a polynomial class that represents a polynomial over the finite field GF(2^192). The class provides methods for constructing a polynomial from its byte array representation, evaluating the polynomial at a given point, adding a monic polynomial to this polynomial, multiplying this polynomial by a monomial, and converting the polynomial to a byte array representation. \n\nThe constructor GF2_192_Poly(coeff0, moreCoeffs) constructs the polynomial given the byte array representation of the coefficients. The coefficient of degree zero is given separately, and each coefficient should be given as a 24-byte representation of a GF2_192 value. Coefficient of degree 1 should start at moreCoeffs[0]. \n\nThe method evaluate(x) evaluates the polynomial at a given point x. The method addMonicTimesConstantTo(p, r) adds r*p to this polynomial, assuming p is monic, c.length>p.deg, and (p.deg == this.deg+1, or this==0 and p==1). The method monicTimesMonomial(r) multiplies this polynomial by (x+r), assuming this is monic of degree deg (i.e. assumed c[deg]==1). \n\nThe method toByteArray(coeff0) returns a byte array that contains the concatenation of all the coefficients (except possibly the degree-0 coefficient, which is omitted if coeff0 is false). The lowest-degree coefficient (0 or 1 depending on coeff0) starts at index 0 of the returned array. Each coefficient takes 24 bytes, for a total of degree*24 bytes if coeff0 is false, or (degree+1)*24 bytes if coeff0 is true. \n\nThe method interpolate(points, values, valueAt0) interpolates the polynomial at given points (and at point 0, if valueAt0!=null). If points are not all distinct, or if 0 is in the points array and valueAt0!=null, behavior is undefined. valueAt0 is separated only for efficiency reason; the caller can treat 0 like any other point instead (i.e., the points array can include 0 if valueAt0==null, but computation will be slightly less efficient). If points is null, or values is null, or if lengths of points and values arrays differ, or if the arrays are 0 length and valueAt0 is null, returns null. The method returns the unique lowest-degree polynomial p such that for every i, p(points[i]) = values[i] and p(0)=valueAt0 (if valueAt0!=null). \n\nOverall, the GF2_192_Poly class provides a useful tool for working with polynomials over the finite field GF(2^192) and can be used in cryptographic applications that require polynomial interpolation and evaluation.",
      "questions": "1. What is the purpose of the GF2_192_Poly class?\n- The GF2_192_Poly class represents a polynomial with coefficients in the finite field GF(2^192). It provides methods for constructing, evaluating, and manipulating such polynomials.\n\n2. What is the format of the byte arrays used to represent the polynomial coefficients?\n- Each coefficient is represented as a 24-byte array, which is the byte representation of a GF2_192 value. The byte arrays for the coefficients are concatenated to form a larger byte array.\n\n3. What is the purpose of the interpolate method in the GF2_192_Poly object?\n- The interpolate method takes in arrays of distinct points and their corresponding values, and returns the unique lowest-degree polynomial that passes through those points. If a value is provided for the point x=0, the resulting polynomial will also evaluate to that value at x=0."
    }
  ],
  "folders": [],
  "summary": "The `sigmastate.crypto` package in the `.autodoc/docs/json/interpreter/shared/src/main/scala` folder provides utility functions and classes for cryptographic operations used in the larger project. It contains several files that deal with different aspects of cryptography, such as working with large integers, elliptic curve cryptography, and polynomial operations over finite fields.\n\n`BigIntegers.scala` provides utility functions for working with `BigInteger` objects in Scala. It includes methods for generating random `BigInteger` values with specified bit lengths and ranges, as well as converting `BigInteger` objects to unsigned byte arrays. These methods can be used in various cryptographic protocols and applications that require the use of large integers.\n\n```scala\nimport sigmastate.crypto.BigIntegers\nimport scala.util.Random\n\nval random = new Random()\n\n// Generate a random 256-bit positive BigInteger\nval randomBigInt = BigIntegers.createRandomBigInteger(256, random)\n\n// Generate a random BigInteger between 100 and 200 (inclusive)\nval min = new BigInteger(\"100\")\nval max = new BigInteger(\"200\")\nval randomInRange = BigIntegers.createRandomInRange(min, max, random)\n\n// Convert a BigInteger to an unsigned byte array of length 32\nval byteArray = BigIntegers.asUnsignedByteArray(32, randomBigInt)\n```\n\n`CryptoContext.scala` defines an abstract class called `CryptoContext`, which serves as a blueprint for implementing cryptographic operations using elliptic curves. Concrete classes that extend this class can implement the abstract methods to provide specific functionality for a particular elliptic curve.\n\n```scala\n// create a concrete class that extends CryptoContext\nclass MyCryptoContext extends CryptoContext {\n  def getModulus: BigInteger = ...\n\n  def getOrder: BigInteger = ...\n\n  def validatePoint(x: BigInteger, y: BigInteger): Ecp = ...\n\n  def getInfinity(): Ecp = ...\n\n  def decodePoint(encoded: Array[Byte]): Ecp = ...\n\n  def getGenerator: Ecp = ...\n}\n\n// use the concrete class to perform cryptographic operations\nval context = new MyCryptoContext()\nval point = context.validatePoint(x, y)\nval generator = context.getGenerator()\n```\n\n`CryptoFacade.scala` provides a set of utility functions for cryptographic operations, including elliptic curve cryptography (ECC) operations, key generation and manipulation, and random number generation. These functions can be used throughout the larger project for various cryptographic tasks.\n\n`GF2_192_Poly.scala` defines a polynomial class that represents a polynomial over the finite field GF(2^192). The class provides methods for constructing a polynomial from its byte array representation, evaluating the polynomial at a given point, adding a monic polynomial to this polynomial, multiplying this polynomial by a monomial, and converting the polynomial to a byte array representation. This class can be used in cryptographic applications that require polynomial interpolation and evaluation.\n\nOverall, the `sigmastate.crypto` package provides a collection of utility functions and classes for performing various cryptographic operations, which can be used throughout the larger project to ensure the security and correctness of the implemented protocols and applications.",
  "questions": ""
}