{
  "folderName": "lang",
  "folderPath": ".autodoc/docs/json/interpreter/shared/src/main/scala/sigmastate/lang",
  "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/.autodoc/docs/json/interpreter/shared/src/main/scala/sigmastate/lang",
  "files": [
    {
      "fileName": "SigmaPredef.scala",
      "filePath": "interpreter/shared/src/main/scala/sigmastate/lang/SigmaPredef.scala",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/interpreter/shared/src/main/scala/sigmastate/lang/SigmaPredef.scala",
      "summary": "This code is part of the SigmaState language implementation and provides a set of predefined functions that can be used in ErgoScript, a language for writing smart contracts on the Ergo platform. These functions are organized into global, infix, unary, and special functions, and are used to perform various operations such as logical, arithmetic, and bitwise operations, as well as working with collections, authenticated dictionaries (AVL trees), and cryptographic primitives.\n\nFor example, the `AllOfFunc` function checks if all elements in a collection are true, while the `Blake2b256Func` function calculates the Blake2b hash of a given input byte array. These predefined functions are organized in a `PredefinedFuncRegistry` class, which maps function names to their corresponding implementations and metadata.\n\nThe code also provides a way to create and manipulate ErgoTree nodes, which represent the structure of a smart contract. This is done through the `IrBuilderFunc` type, which is a partial function that takes an `SValue` and a sequence of `SValue`s as input and returns an `SValue`. The `PredefFuncInfo` case class holds the metadata for a predefined function, including its `IrBuilderFunc`.\n\nHere's an example of using a predefined function in ErgoScript:\n\n```\n{\n  val conditions = Coll(\n    OUTPUTS.exists { (outBox: Box) => outBox.value >= 1000 },\n    HEIGHT > 5000\n  )\n  allOf(conditions)\n}\n```\n\nIn this example, the `allOf` function is used to check if all conditions in the `conditions` collection are true. If they are, the script evaluates to true, and the transaction is considered valid.",
      "questions": "1. **Question**: What is the purpose of the `SigmaPredef` object and its related classes and functions?\n   **Answer**: The `SigmaPredef` object contains the definitions and metadata for predefined functions in the Sigma language. It provides a registry of global, infix, unary, and special functions, along with their corresponding IR builders, which are used to generate the intermediate representation of the code during compilation.\n\n2. **Question**: How are the predefined functions organized and categorized within the `SigmaPredef` object?\n   **Answer**: Predefined functions are organized into several categories: global functions, infix functions, unary functions, and special functions. Each category is represented as a separate map within the `PredefinedFuncRegistry` class, and the functions are stored as instances of the `PredefinedFunc` case class.\n\n3. **Question**: How can a developer add a new predefined function to the `SigmaPredef` object?\n   **Answer**: To add a new predefined function, a developer needs to create a new instance of the `PredefinedFunc` case class with the appropriate metadata, such as the function name, declaration, IR builder, and documentation. Then, the new function should be added to the corresponding map (global, infix, unary, or special) within the `PredefinedFuncRegistry` class."
    },
    {
      "fileName": "SourceContext.scala",
      "filePath": "interpreter/shared/src/main/scala/sigmastate/lang/SourceContext.scala",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/interpreter/shared/src/main/scala/sigmastate/lang/SourceContext.scala",
      "summary": "The code in this file defines a case class and an object that provide functionality for creating and manipulating source code contexts. A source code context is a representation of the location of a piece of code within a larger source file, including the line number, column number, and the text of the line itself.\n\nThe `SourceContext` case class defines a context object with three fields: `line`, `column`, and `sourceLine`. The `line` and `column` fields represent the location of the code within the source file, while the `sourceLine` field contains the text of the line of code.\n\nThe `SourceContext` object provides two methods for creating `SourceContext` objects. The first method, `fromParserIndex`, takes an index and an input string as arguments and returns a `SourceContext` object representing the location of the code at the given index within the input string. This method works by splitting the input string into lines, scanning through the lines to determine the start and end indices of each line, and then finding the line containing the given index. If the index is not found within any line, the method returns a `SourceContext` object representing the last character of the last line.\n\nThe second method, `fromParserFailure`, takes a `Failure` object as an argument and returns a `SourceContext` object representing the location of the code that caused the failure. This method simply calls `fromParserIndex` with the index and input string from the `Failure` object.\n\nOverall, this code provides a useful tool for working with source code contexts in a larger project. For example, it could be used by a compiler or interpreter to provide more detailed error messages that include the location of the error within the source file. Here is an example of how this code could be used:\n\n```\nval input = \"val x = 42\\nval y = x + 1\\nprintln(y)\"\nval index = 10\nval context = SourceContext.fromParserIndex(index, input)\nprintln(s\"Error at line ${context.line}, column ${context.column}: ${context.sourceLine}\")\n```\n\nThis code would output: `Error at line 2, column 5: val y = x + 1`.",
      "questions": "1. What is the purpose of the `SourceContext` case class?\n- The `SourceContext` case class is used to store information about the location of a piece of code in the source file, including the line number, column number, and the source code on that line.\n\n2. What is the `fromParserIndex` method used for?\n- The `fromParserIndex` method is used to create a `SourceContext` object based on the index of a parsed piece of code and the input source file. It calculates the line and column numbers of the parsed code and returns a `SourceContext` object with that information.\n\n3. What is the `fromParserFailure` method used for?\n- The `fromParserFailure` method is used to create a `SourceContext` object based on a parsing failure. It takes in a `Failure` object and returns a `SourceContext` object with the line and column numbers of the failed code and the source code on that line."
    },
    {
      "fileName": "Terms.scala",
      "filePath": "interpreter/shared/src/main/scala/sigmastate/lang/Terms.scala",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/interpreter/shared/src/main/scala/sigmastate/lang/Terms.scala",
      "summary": "This code is part of the SigmaState language module and provides an implementation of various frontend and intermediate representation (IR) nodes for ErgoTree, a language used to express conditions for spending Ergo coins. The code defines several case classes and objects that represent different types of nodes in the ErgoTree language, such as `Block`, `ZKProofBlock`, `Val`, `Select`, `Ident`, `Apply`, `Lambda`, and `MethodCall`.\n\nThe `Block` case class represents a block of value definitions, while `ZKProofBlock` represents an explicit Zero Knowledge scope in ErgoTree. The `Val` trait and its case class `ValNode` represent value definitions, and `Select` is a frontend node to select a field from an object. The `Ident` case class represents variable names parsed in the source code, and `Apply` represents the application of a function to given arguments.\n\nThe `Lambda` case class represents frontend implementation of lambdas, which should be transformed to `FuncValue`. The `MethodCall` case class represents an invocation of a method of an object with arguments in ErgoTree.\n\nThe code also provides utility functions for type unification, substitution, and finding the most specific generalized type of a sequence of types. These functions are used during the compilation and type checking of ErgoTree expressions.\n\nOverall, this code is essential for the proper functioning of the ErgoTree language, as it defines the structure and behavior of various nodes and provides utility functions for type manipulation.",
      "questions": "1. **What is the purpose of the `ZKProofBlock` case class?**\n\n   The `ZKProofBlock` case class represents an explicit Zero Knowledge scope in ErgoTree. The compiler checks Zero Knowledge properties and issues error messages in case of violations. It is used when the user wants to ensure Zero Knowledge of a specific set of operations.\n\n2. **What is the role of the `Val` trait and its related case classes?**\n\n   The `Val` trait represents a block of Val definitions in the frontend representation. It is used to form a program structure and is not part of ErgoTree. The related case classes, such as `ValNode`, provide implementations for the `Val` trait.\n\n3. **How does the `MethodCall` case class work in ErgoTree?**\n\n   The `MethodCall` case class represents an invocation of a method of an object with arguments in ErgoTree. It ensures that all ErgoTree instances are monomorphic by construction. During evaluation, it invokes the method on the object with the given arguments and returns the result."
    }
  ],
  "folders": [],
  "summary": "The code in the `.autodoc/docs/json/interpreter/shared/src/main/scala/sigmastate/lang` folder is part of the SigmaState language implementation, which is used for writing smart contracts on the Ergo platform using ErgoScript. The folder contains three main files: `SigmaPredef.scala`, `SourceContext.scala`, and `Terms.scala`.\n\n`SigmaPredef.scala` provides a set of predefined functions that can be used in ErgoScript for various operations such as logical, arithmetic, and bitwise operations, as well as working with collections, authenticated dictionaries (AVL trees), and cryptographic primitives. These functions are organized into global, infix, unary, and special functions and are stored in a `PredefinedFuncRegistry` class. Here's an example of using a predefined function in ErgoScript:\n\n```scala\n{\n  val conditions = Coll(\n    OUTPUTS.exists { (outBox: Box) => outBox.value >= 1000 },\n    HEIGHT > 5000\n  )\n  allOf(conditions)\n}\n```\n\n`SourceContext.scala` defines a case class and an object for creating and manipulating source code contexts, which represent the location of a piece of code within a larger source file. This can be useful for providing more detailed error messages in a compiler or interpreter. Here's an example of how this code could be used:\n\n```scala\nval input = \"val x = 42\\nval y = x + 1\\nprintln(y)\"\nval index = 10\nval context = SourceContext.fromParserIndex(index, input)\nprintln(s\"Error at line ${context.line}, column ${context.column}: ${context.sourceLine}\")\n```\n\n`Terms.scala` provides an implementation of various frontend and intermediate representation (IR) nodes for ErgoTree, a language used to express conditions for spending Ergo coins. The code defines several case classes and objects that represent different types of nodes in the ErgoTree language, such as `Block`, `ZKProofBlock`, `Val`, `Select`, `Ident`, `Apply`, `Lambda`, and `MethodCall`. The code also provides utility functions for type unification, substitution, and finding the most specific generalized type of a sequence of types, which are used during the compilation and type checking of ErgoTree expressions.\n\nOverall, the code in this folder is essential for the proper functioning of the ErgoTree language and the Ergo platform, as it defines the structure and behavior of various nodes, provides utility functions for type manipulation, and offers predefined functions for common operations in ErgoScript.",
  "questions": ""
}