{
  "fileName": "ComplexityTableStat.scala",
  "filePath": "interpreter/shared/src/main/scala/sigmastate/utxo/ComplexityTableStat.scala",
  "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/interpreter/shared/src/main/scala/sigmastate/utxo/ComplexityTableStat.scala",
  "summary": "The `ComplexityTableStat` object contains methods for tracking and reporting the execution times of op codes and method calls in the `sigmastate.utxo` package. \n\nThe `StatItem` class is a private mutable class that stores the count and sum of execution times for a given operation. The `opStat` and `mcStat` mutable hash maps store the execution times for op codes and method calls, respectively. \n\nThe `addOpTime` method takes an op code and execution time as input and updates the corresponding `StatItem` in `opStat`. If the op code is not already in `opStat`, a new `StatItem` is created and added to the map. \n\nThe `addMcTime` method takes a type ID, method ID, and execution time as input and updates the corresponding `StatItem` in `mcStat`. If the type ID and method ID are not already in `mcStat`, a new `StatItem` is created and added to the map. \n\nThe `complexityTableString` method generates a string representation of the execution times for op codes and method calls. It first generates a list of tuples containing the op code or method call name, ID, average execution time, and count. It then sorts the list by execution time in descending order. \n\nThe method then generates two separate lists of strings, one for op codes and one for method calls. Each string in the list contains the name or ID of the op code or method call, the average execution time in microseconds, and the count of executions. \n\nThe final output is a string containing the two lists of op codes and method calls, separated by a line of dashes. \n\nThis code can be used to analyze the performance of different operations and method calls in the `sigmastate.utxo` package. By calling the `addOpTime` and `addMcTime` methods at various points in the code, developers can track the execution times of specific operations and method calls. The `complexityTableString` method can then be used to generate a report of the execution times, which can be used to identify performance bottlenecks and optimize the code. \n\nExample usage:\n\n```\n// track execution time of an op code\nval startTime = System.nanoTime()\n// execute op code\nval endTime = System.nanoTime()\nval elapsedTime = endTime - startTime\nComplexityTableStat.addOpTime(opCode, elapsedTime)\n\n// track execution time of a method call\nval startTime = System.nanoTime()\n// call method\nval endTime = System.nanoTime()\nval elapsedTime = endTime - startTime\nComplexityTableStat.addMcTime(typeId, methodId, elapsedTime)\n\n// generate report of execution times\nval report = ComplexityTableStat.complexityTableString\n```",
  "questions": "1. What is the purpose of the `ComplexityTableStat` object?\n- The `ComplexityTableStat` object is used to collect and store timing statistics for op codes and method calls in the `sigmastate` package.\n\n2. What data structures are used to store the timing statistics?\n- The timing statistics for op codes and method calls are stored in mutable hash maps called `opStat` and `mcStat`, respectively.\n\n3. What is the output format of the `complexityTableString` method?\n- The `complexityTableString` method outputs a formatted string that displays the average execution time and count for each op code and method call, sorted by decreasing execution time. The op codes and method calls are displayed separately in two sections, each with their own header and divider lines."
}