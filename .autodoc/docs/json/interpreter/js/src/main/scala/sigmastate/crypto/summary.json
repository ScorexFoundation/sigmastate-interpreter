{
  "folderName": "crypto",
  "folderPath": ".autodoc/docs/json/interpreter/js/src/main/scala/sigmastate/crypto",
  "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/.autodoc/docs/json/interpreter/js/src/main/scala/sigmastate/crypto",
  "files": [
    {
      "fileName": "Imported.scala",
      "filePath": "interpreter/js/src/main/scala/sigmastate/crypto/Imported.scala",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/interpreter/js/src/main/scala/sigmastate/crypto/Imported.scala",
      "summary": "The code provided is a Scala.js implementation of cryptographic functions for the Sigma protocol. The code is contained in the `sigmastate.crypto` package and is dependent on the `sigmajs-crypto-facade` library. \n\nThe `CryptoContextJs` class provides methods for working with elliptic curve cryptography. The `getModulus()` and `getOrder()` methods return the modulus and order of the elliptic curve, respectively. The `validatePoint()` method takes two `BigInt` values as input and returns a `Platform.Point` object if the point is valid on the elliptic curve. The `getInfinity()` method returns the point at infinity on the elliptic curve. The `decodePoint()` method takes a string as input and returns a `Platform.Point` object. The `getGenerator()` method returns the generator point of the elliptic curve.\n\nThe `CryptoFacadeJs` object provides various cryptographic functions. The `normalizePoint()` method takes a `Platform.Point` object as input and returns a normalized point. The `createCryptoContext()` method returns a new instance of the `CryptoContextJs` class. The `negatePoint()` method takes a `Platform.Point` object as input and returns the negation of the point. The `isInfinityPoint()` method takes a `Platform.Point` object as input and returns a boolean indicating whether the point is the point at infinity. The `multiplyPoint()` method takes a `Platform.Point` object and a `BigInt` scalar as input and returns the result of scalar multiplication. The `addPoint()` method takes two `Platform.Point` objects as input and returns the sum of the points. The `showPoint()` method takes a `Platform.Point` object as input and returns a string representation of the point. The `testBitZeroOfFieldElem()` method takes a `BigInt` value as input and returns a boolean indicating whether the least significant bit is set. The `getEncodedOfFieldElem()` method takes a `BigInt` value as input and returns a `Uint8Array` containing the encoded value. The `getXCoord()` and `getYCoord()` methods take a `Platform.Point` object as input and return the x and y coordinates, respectively. The `getAffineXCoord()` and `getAffineYCoord()` methods take a `Platform.Point` object as input and return the affine x and y coordinates, respectively. The `hashHmacSHA512()` method takes two `Uint8Array` values as input and returns the HMAC-SHA512 hash. The `generatePbkdf2Key()` method takes two strings as input and returns a `Uint8Array` containing the PBKDF2 key.\n\nThe `Point` object provides methods for working with elliptic curve points. The `fromHex()` method takes a string as input and returns a `Platform.Point` object. The `ZERO` property returns the point at infinity.\n\nThe `utils` object provides utility functions for working with byte arrays and hex strings. The `bytesToHex()` method takes a `Uint8Array` as input and returns a hex string. The `hexToBytes()` method takes a hex string as input and returns a `Uint8Array`.\n\nOverall, this code provides a set of cryptographic functions for working with elliptic curve cryptography in the Sigma protocol. These functions can be used to perform various cryptographic operations such as point multiplication, point addition, and hashing. The code is dependent on the `sigmajs-crypto-facade` library and is written in Scala.js.",
      "questions": "1. What is the purpose of this code and what problem does it solve?\n   This code provides a set of functions for cryptographic operations on elliptic curve points, including point addition, multiplication, and validation, as well as hashing and key generation.\n\n2. What external dependencies does this code have?\n   This code depends on the \"sigmajs-crypto-facade\" library, which provides the implementation of the elliptic curve operations and other cryptographic functions.\n\n3. What is the expected input and output format for the functions in this code?\n   The input and output formats vary depending on the function, but generally involve BigInts, Uint8Arrays, and Platform.Points, which represent elliptic curve points. Some functions also take or return strings or Booleans. The documentation for each function should provide more details on the expected input and output formats."
    },
    {
      "fileName": "Platform.scala",
      "filePath": "interpreter/js/src/main/scala/sigmastate/crypto/Platform.scala",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/interpreter/js/src/main/scala/sigmastate/crypto/Platform.scala",
      "summary": "The `Platform` object in the `sigmastate.crypto` package provides a JVM-specific implementation of various cryptographic methods used in the larger project. The purpose of this code is to provide a set of utility functions for working with elliptic curve cryptography, hashing, and random number generation. \n\nThe `Platform` object contains several methods for working with elliptic curve points and field elements. These methods include `getXCoord`, `getYCoord`, `getAffineXCoord`, `getAffineYCoord`, `getEncodedOfFieldElem`, `testBitZeroOfFieldElem`, `normalizePoint`, `showPoint`, `multiplyPoints`, `exponentiatePoint`, `isInfinityPoint`, and `negatePoint`. These methods take `Ecp` and `ECFieldElem` objects as input and return new `Ecp` and `ECFieldElem` objects as output. These methods are used to perform various operations on elliptic curve points and field elements, such as getting the x and y coordinates of a point, encoding a field element, and multiplying two points together.\n\nThe `Platform` object also contains methods for working with byte arrays and JavaScript typed arrays. These methods include `Uint8ArrayToBytes`, `bytesToJsShorts`, and `jsShortsToBytes`. These methods are used to convert between byte arrays and JavaScript typed arrays.\n\nThe `Platform` object also contains methods for working with cryptographic contexts, random number generation, and hashing. These methods include `createContext`, `createSecureRandom`, `hashHmacSHA512`, and `generatePbkdf2Key`. These methods are used to create cryptographic contexts, generate random numbers, and perform hashing operations.\n\nFinally, the `Platform` object contains a method for checking the type of a value against a given type descriptor. This method is called `isCorrectType` and takes a value and a type descriptor as input. It returns a boolean indicating whether the value has the correct type. This method is used to perform type checking in various parts of the larger project.\n\nOverall, the `Platform` object provides a set of utility functions for working with elliptic curve cryptography, hashing, and random number generation in the larger project. These functions are implemented in a JVM-specific way and are used to perform various operations on cryptographic objects and data.",
      "questions": "1. What is the purpose of the `Platform` object?\n- The `Platform` object provides a JVM-specific implementation of various cryptographic methods.\n\n2. What is the purpose of the `Ecp` and `ECFieldElem` classes?\n- The `Ecp` class represents an elliptic curve point, while the `ECFieldElem` class represents an element of the underlying field of the elliptic curve.\n\n3. What is the purpose of the `isCorrectType` method?\n- The `isCorrectType` method checks whether a given value has the expected type according to a given `SType` descriptor. This is used for type checking in various parts of the codebase."
    }
  ],
  "folders": [],
  "summary": "The code in the `sigmastate.crypto` package provides a set of cryptographic functions for working with elliptic curve cryptography in the Sigma protocol. These functions can be used to perform various cryptographic operations such as point multiplication, point addition, and hashing. The code is dependent on the `sigmajs-crypto-facade` library and is written in Scala.js.\n\nIn `Imported.scala`, the `CryptoContextJs` class provides methods for working with elliptic curve cryptography, such as getting the modulus and order of the elliptic curve, validating points, and decoding points from strings. The `CryptoFacadeJs` object provides various cryptographic functions, such as normalizing points, negating points, multiplying points, and adding points. The `Point` object provides methods for working with elliptic curve points, and the `utils` object provides utility functions for working with byte arrays and hex strings.\n\nIn `Platform.scala`, the `Platform` object provides a JVM-specific implementation of various cryptographic methods used in the larger project. It contains several methods for working with elliptic curve points and field elements, such as getting the x and y coordinates of a point, encoding a field element, and multiplying two points together. The `Platform` object also contains methods for working with byte arrays and JavaScript typed arrays, cryptographic contexts, random number generation, and hashing.\n\nHere's an example of how this code might be used:\n\n```scala\nimport sigmastate.crypto._\n\n// Create a new cryptographic context\nval cryptoContext = CryptoFacadeJs.createCryptoContext()\n\n// Get the generator point of the elliptic curve\nval generator = cryptoContext.getGenerator()\n\n// Multiply the generator point by a scalar\nval scalar = BigInt(\"1234567890\")\nval result = CryptoFacadeJs.multiplyPoint(generator, scalar)\n\n// Add two points together\nval point1 = cryptoContext.decodePoint(\"abcdef\")\nval point2 = cryptoContext.decodePoint(\"123456\")\nval sum = CryptoFacadeJs.addPoint(point1, point2)\n\n// Check if a point is the point at infinity\nval isInfinity = CryptoFacadeJs.isInfinityPoint(sum)\n\n// Perform HMAC-SHA512 hashing\nval data = utils.hexToBytes(\"abcdef\")\nval key = utils.hexToBytes(\"123456\")\nval hash = CryptoFacadeJs.hashHmacSHA512(data, key)\n```\n\nOverall, the code in this folder provides a set of cryptographic functions for working with elliptic curve cryptography in the Sigma protocol. These functions can be used to perform various cryptographic operations such as point multiplication, point addition, and hashing. The code is dependent on the `sigmajs-crypto-facade` library and is written in Scala.js.",
  "questions": ""
}