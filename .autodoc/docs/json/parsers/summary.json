{
  "folderName": "parsers",
  "folderPath": ".autodoc/docs/json/parsers",
  "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/.autodoc/docs/json/parsers",
  "files": [],
  "folders": [
    {
      "folderName": "shared",
      "folderPath": ".autodoc/docs/json/parsers/shared",
      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/.autodoc/docs/json/parsers/shared",
      "files": [],
      "folders": [
        {
          "folderName": "src",
          "folderPath": ".autodoc/docs/json/parsers/shared/src",
          "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/.autodoc/docs/json/parsers/shared/src",
          "files": [],
          "folders": [
            {
              "folderName": "main",
              "folderPath": ".autodoc/docs/json/parsers/shared/src/main",
              "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/.autodoc/docs/json/parsers/shared/src/main",
              "files": [],
              "folders": [
                {
                  "folderName": "scala",
                  "folderPath": ".autodoc/docs/json/parsers/shared/src/main/scala",
                  "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/.autodoc/docs/json/parsers/shared/src/main/scala",
                  "files": [],
                  "folders": [
                    {
                      "folderName": "sigmastate",
                      "folderPath": ".autodoc/docs/json/parsers/shared/src/main/scala/sigmastate",
                      "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/.autodoc/docs/json/parsers/shared/src/main/scala/sigmastate",
                      "files": [],
                      "folders": [
                        {
                          "folderName": "lang",
                          "folderPath": ".autodoc/docs/json/parsers/shared/src/main/scala/sigmastate/lang",
                          "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/.autodoc/docs/json/parsers/shared/src/main/scala/sigmastate/lang",
                          "files": [
                            {
                              "fileName": "SigmaParser.scala",
                              "filePath": "parsers/shared/src/main/scala/sigmastate/lang/SigmaParser.scala",
                              "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/parsers/shared/src/main/scala/sigmastate/lang/SigmaParser.scala",
                              "summary": "# SigmaParser Code Explanation\n\nThe `SigmaParser` object is the main facade to the ErgoScript parser implementation. It provides methods to parse ErgoScript code into ErgoTree expressions and SType (Sigma Type) objects. \n\nThe `SigmaParser` object imports several classes and objects from the `sigmastate.lang` package, including `Values`, `Nullable`, `Terms`, `Core`, and `Exprs`. It also imports `fastparse.internal.Logger` and `scala.collection.mutable` packages.\n\nThe `SigmaParser` object extends the `Exprs` trait, which defines methods for parsing ErgoScript expressions, and the `Types` trait, which defines methods for parsing ErgoScript types. It also extends the `Core` trait, which defines methods for constructing ErgoTree nodes.\n\nThe `SigmaParser` object overrides the `atSrcPos` and `srcCtx` methods from the `Exprs` trait. The `atSrcPos` method takes a parser index and a thunk and returns the result of the thunk with the current source context set to the source context at the given parser index. The `srcCtx` method takes a parser index and returns the source context at the given parser index.\n\nThe `SigmaParser` object defines the `ValVarDef` and `BlockDef` methods, which parse variable and block definitions, respectively. The `ValVarDef` method takes an index, a binding pattern, an optional type, and an expression, and returns a `Val` node with the given name, type, and body. The `BlockDef` method calls the `Dcl` method, which is defined in the `Core` trait.\n\nThe `SigmaParser` object defines the `mkUnaryOp` and `mkBinaryOp` methods, which construct ErgoTree nodes for unary and binary operations, respectively. The `mkUnaryOp` method takes an operator name and an argument and returns the result of applying the operator to the argument. The `mkBinaryOp` method takes a left operand, an operator name, and a right operand, and returns the result of applying the operator to the operands.\n\nThe `SigmaParser` object defines the `parseType` method, which takes a string representation of a type in ErgoScript syntax and returns an SType object. The `parseType` method calls the `parsedType` method, which parses the string into an SType object.\n\nThe `SigmaParser` object defines the `apply` method, which takes a string representation of ErgoScript code and returns a parsed ErgoTree expression. The `apply` method calls the `parse` method, which parses the code into an ErgoTree expression.\n\nOverall, the `SigmaParser` object provides a high-level interface for parsing ErgoScript code into ErgoTree expressions and SType objects. It can be used in the larger project to parse ErgoScript code and construct ErgoTree nodes. \n\nExample usage:\n\n```\nval code = \"1 + 2\"\nval parsed = SigmaParser(code)\nval tree = parsed.get.value\n```",
                              "questions": "1. What is the purpose of the `SigmaParser` object?\n- The `SigmaParser` object is the main facade to ErgoScript parser implementation.\n\n2. What types of operations are supported by the `mkUnaryOp` and `mkBinaryOp` methods?\n- The `mkUnaryOp` method supports prefix operations such as `-`, `!`, and `~`, while the `mkBinaryOp` method supports binary operations such as `==`, `!=`, `>=`, `>`, `<=`, `<`, `-`, `|`, `&`, `/`, and `%`.\n\n3. What is the purpose of the `parseType` method?\n- The `parseType` method parses a string representation of a type in ErgoScript syntax into an `SType`."
                            },
                            {
                              "fileName": "Types.scala",
                              "filePath": "parsers/shared/src/main/scala/sigmastate/lang/Types.scala",
                              "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/parsers/shared/src/main/scala/sigmastate/lang/Types.scala",
                              "summary": "## Code Explanation: Types.scala\n\nThe `Types` trait provides parsers for type terms that can produce values of `SType`. The `SType` is a type of values in the ErgoTree IR. The parsers are used to parse type expressions in the ErgoScript language.\n\nThe trait defines the following parsers:\n\n- `TypeExpr`: Parses a typed expression and returns an expression of ErgoTree IR.\n- `ValVarDef`: Parses `name = expr` syntax and returns an instance of `ValNode`.\n- `Dcl`: Parses `val name = expr` syntax and returns an instance of `ValNode`.\n- `PostfixType`: Parses a postfix type expression and returns an instance of `SType`.\n- `Type`: Parses a type expression and returns an instance of `SType`.\n- `InfixType`: Parses an infix type expression and returns an instance of `SType`.\n- `CompoundType`: Parses a compound type expression and returns an instance of `SType`.\n- `AnnotType`: Parses an annotated type expression and returns an instance of `SType`.\n- `TypeId`: Parses a type identifier and returns an instance of `SType`.\n- `TypeArgs`: Parses type arguments and returns an instance of `SType`.\n- `SimpleType`: Parses a simple type expression and returns an instance of `SType`.\n- `FunSig`: Parses a function signature and returns a sequence of function arguments.\n- `DottyExtMethodSubj`: Parses an extension method subject.\n- `Annot`: Parses an annotation with optional arguments.\n\nThe trait also defines a `predefTypes` map that maps predefined type names to their corresponding `SType` instances. The `typeFromName` method is used to lookup a predefined type by name.\n\nThe `Types` trait is used in the larger project to parse type expressions in ErgoScript code. The parsed type expressions are used to type-check ErgoScript code and to generate ErgoTree IR. \n\nExample usage:\n\n```scala\nval input = \"Int => Boolean\"\nval result = parse(input, Type(_))\nresult.get // returns SFunc(Array(SInt), SBoolean)\n```",
                              "questions": "1. What is the purpose of the `Types` trait?\n- The `Types` trait defines parsers for type terms that can produce values of `SType`, which is used in the ErgoTree IR.\n\n2. What is the `predefTypes` map used for?\n- The `predefTypes` map is used to lookup pre-defined types by name.\n\n3. What is the purpose of the `InfixType` parser?\n- The `InfixType` parser is used to parse infix types, which are types that use infix operators such as `+` or `:`. It checks the associativity of the operators and builds the corresponding `SType` object."
                            }
                          ],
                          "folders": [
                            {
                              "folderName": "syntax",
                              "folderPath": ".autodoc/docs/json/parsers/shared/src/main/scala/sigmastate/lang/syntax",
                              "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/.autodoc/docs/json/parsers/shared/src/main/scala/sigmastate/lang/syntax",
                              "files": [
                                {
                                  "fileName": "Basic.scala",
                                  "filePath": "parsers/shared/src/main/scala/sigmastate/lang/syntax/Basic.scala",
                                  "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/parsers/shared/src/main/scala/sigmastate/lang/syntax/Basic.scala",
                                  "summary": "The code provided is a Scala implementation of basic lexical parsers for ErgoScript, a scripting language used in the Ergo blockchain platform. The purpose of this code is to provide parsers for various types of tokens in ErgoScript, such as numbers, operators, and keywords. These parsers are used in the larger project to parse ErgoScript code and generate an abstract syntax tree (AST) that can be executed on the Ergo blockchain.\n\nThe `Basic` object contains parsers for various types of tokens. The `Digit` parser matches a decimal digit, while the `HexDigit` parser matches a hexadecimal digit. The `UnicodeEscape` parser matches a Unicode escape sequence, which is used to represent Unicode characters in ErgoScript. The `HexNum` parser matches a positive hexadecimal number, while the `DecNum` parser matches a positive decimal number. The `Exp` parser matches the exponent part of a floating-point number. The `FloatType` parser matches the type suffix of a floating-point number. The `WSChars` parser matches a sequence of whitespace characters, while the `Newline` parser matches a newline character. The `Semi` parser matches a semicolon or one or more newline characters.\n\nThe `OpChar` parser matches a single operation character, which is any character that can be used as an operator in ErgoScript. The `isOpChar` function defines the set of characters that are allowed as operators in ErgoScript. The `LetterDigitDollarUnderscore` parser matches any character that is allowed in an identifier in ErgoScript. The `Lower` parser matches a lowercase letter, dollar sign, or underscore, while the `Upper` parser matches an uppercase letter.\n\nThe `error` function is used to throw a `ParserException` when a parsing error occurs. The `ParserException` class extends `CompilerException` and is used to represent errors that occur during parsing.\n\nThe `Key` object contains parsers for ErgoScript keywords and key-operators. The `W` parser matches a keyword and ensures that subsequent characters do not match in order for it to be a keyword. The `O` parser matches a key-operator and stops early if it is followed by a comment so that the comment can be parsed separately.\n\nOverall, this code provides the basic building blocks for parsing ErgoScript code and generating an AST. It is an essential part of the larger project and enables the execution of ErgoScript contracts on the Ergo blockchain.",
                                  "questions": "1. What is the purpose of this code file?\n- This code file contains basic lexical parsers for ErgoScript.\n\n2. What are some examples of characters allowed in identifiers and operations?\n- Identifiers can contain letters, digits, dollar signs, and underscores. Operations can contain various symbols such as exclamation marks, percentages, and mathematical symbols.\n\n3. What is the purpose of the ParserException class?\n- The ParserException class is used to throw an exception when there is an error in parsing the code, with an error message and source context descriptor."
                                },
                                {
                                  "fileName": "Core.scala",
                                  "filePath": "parsers/shared/src/main/scala/sigmastate/lang/syntax/Core.scala",
                                  "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/parsers/shared/src/main/scala/sigmastate/lang/syntax/Core.scala",
                                  "summary": "The code provided is a part of the Sigmastate project and defines a trait called \"Core\". This trait contains a set of keywords and identifiers used in expressions. The purpose of this trait is to provide a set of common aliases and keywords that can be used in almost every parser in the file. \n\nThe trait contains two methods, \"mkUnaryOp\" and \"mkBinaryOp\", which are used to construct ErgoTree unary and binary operations, respectively. These methods take an operation name and one or two values of SType, respectively, and return a value of SType. \n\nThe trait also contains a set of aliases for common things such as keywords and symbols. These aliases are used in almost every parser in the file, so it makes sense to keep them short. For example, the keyword \"type\" is aliased as \"type[_:P]\", and the symbol \"=>\" is aliased as \"`=>`[_:P]\". \n\nThe trait also defines several parsers for identifiers, literals, and other constructs used in expressions. For example, the parser \"Id[_:P]\" parses an identifier, and the parser \"ExprLiteral[_:P]\" parses an expression literal. \n\nOverall, the \"Core\" trait provides a set of common aliases and parsers that can be used throughout the project to simplify the parsing and construction of expressions. Here is an example of how the \"mkUnaryOp\" method might be used in the larger project:\n\n```\nval opName = \"NOT\"\nval arg = builder.mkIdent(\"x\", SBoolean)\nval result = mkUnaryOp(opName, arg)\n```\n\nThis code constructs a unary operation with the name \"NOT\" and the argument \"x\" of type SBoolean. The resulting value is of type SBoolean and can be used in further expressions.",
                                  "questions": "1. What is the purpose of the `Core` trait?\n- The `Core` trait defines keywords and identifiers used in expressions and provides constructors for ErgoTree unary and binary operations.\n\n2. What is the purpose of the `PostDotCheck` method?\n- The `PostDotCheck` method is used to whitelist a few suffixes that come after a `.` select. Everything else is considered illegal.\n\n3. What is the purpose of the `StableId` method?\n- The `StableId` method defines a parser for stable identifiers, which are used to represent paths to objects and values in the program."
                                },
                                {
                                  "fileName": "Exprs.scala",
                                  "filePath": "parsers/shared/src/main/scala/sigmastate/lang/syntax/Exprs.scala",
                                  "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/parsers/shared/src/main/scala/sigmastate/lang/syntax/Exprs.scala",
                                  "summary": "This code defines a set of parsers for ErgoScript expressions, which are part of the Ergo blockchain platform. ErgoScript is a language used to write smart contracts on the Ergo platform. The parsers are implemented using the FastParse library and are organized in a trait called `Exprs`, which extends the `Core` and `Types` traits.\n\nThe `Exprs` trait contains several parsers for different types of expressions, such as `BlockDef`, `If`, `Fun`, and `LambdaRhs`. These parsers are used to parse various ErgoScript constructs like variable definitions, if-else expressions, function definitions, and lambda expressions. The trait also provides utility methods like `mkInfixTree`, `applySuffix`, and `block` to build the abstract syntax tree (AST) for the parsed expressions.\n\nThe code also defines a `WsCtx` class, which represents the parsing context for expressions. It has three derived classes: `StatCtx`, `ExprCtx`, and `FreeCtx`. These classes are used to handle different parsing scenarios, such as expressions used as statements, expressions nested within other expressions, and expressions directly within a `val x = ...` or `def x = ...`.\n\nAn example of using these parsers in a larger project would be to parse ErgoScript code and generate an AST, which can then be used for further processing, such as type checking, optimization, or code generation.\n\nHere's an example of how the `Expr` parser can be used:\n\n```scala\nval input = \"if (x > 0) x * 2 else x / 2\"\nval parsedExpr = fastparse.parse(input, Exprs.Expr(_))\n```\n\nThis code snippet would parse the input string containing an ErgoScript expression and return a parsed expression in the form of an AST.",
                                  "questions": "1. **Question**: What is the purpose of the `WsCtx` class and its parameters `semiInference` and `arrowTypeAscriptions`?\n   **Answer**: The `WsCtx` class represents the parsing context of expressions. The `semiInference` parameter determines whether semicolon inference is enabled, and the `arrowTypeAscriptions` parameter determines whether arrow-type ascriptions like `i: a => b` are allowed in the current context.\n\n2. **Question**: How does the `mkInfixTree` function handle operator precedence when constructing the expression tree?\n   **Answer**: The `mkInfixTree` function uses a tail-recursive algorithm to build the expression tree while respecting operator precedence. It maintains a stack of waiting operations and iteratively processes the input list of operations, comparing the precedence of the current operation with the next one to decide whether to apply the current operation or push it onto the stack.\n\n3. **Question**: What is the purpose of the `priorityList` and `priorityMap` variables in the code?\n   **Answer**: The `priorityList` variable defines the precedence levels of infix operators based on their first character, with characters on the same line having the same precedence. The `priorityMap` variable is a derived map that associates each operator character with its precedence level, making it easier to look up the precedence of a given operator during expression tree construction."
                                },
                                {
                                  "fileName": "Identifiers.scala",
                                  "filePath": "parsers/shared/src/main/scala/sigmastate/lang/syntax/Identifiers.scala",
                                  "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/parsers/shared/src/main/scala/sigmastate/lang/syntax/Identifiers.scala",
                                  "summary": "The `Identifiers` object in the `sigmastate.lang.syntax` package provides functionality for parsing and identifying identifiers and keywords in the Sigma programming language. \n\nThe `Identifiers` object defines several parsers for different types of identifiers. The `VarId` parser matches variable names, which must start with a lowercase letter and can contain letters, digits, and underscores. The `UppercaseId` parser matches type names, which must start with an uppercase letter and can contain letters, digits, and underscores. The `PlainId` parser matches any identifier that is not enclosed in backticks, including variable names, type names, and operators. The `PlainIdNoDollar` parser matches the same identifiers as `PlainId`, but does not allow dollar signs in variable names. The `BacktickId` parser matches any identifier enclosed in backticks, allowing it to contain any characters except backticks.\n\nThe `Identifiers` object also defines parsers for operators and keywords. The `Operator` parser matches any operator symbol that is not a keyword, including arithmetic operators, comparison operators, and logical operators. The `Keywords` parser matches any keyword in the Sigma language, including `case`, `else`, `false`, `function`, `if`, `match`, `return`, `then`, and `true`. \n\nOverall, the `Identifiers` object is an important part of the Sigma language parser, allowing it to identify and parse different types of identifiers and keywords. It can be used in conjunction with other parsers in the `sigmastate.lang.syntax` package to parse Sigma code and generate an abstract syntax tree. \n\nExample usage:\n```\nimport fastparse._\nimport sigmastate.lang.syntax.Identifiers._\n\nval result = parse(\"x + y\", PlainId(_))\n// result: Parsed.Success[Unit] = Success((), 5)\n\nval result2 = parse(\"if (x > y) then x else y\", Keywords(_))\n// result2: Parsed.Failure = Failure(\"if (x > y) then x else y\", 0)\n```",
                                  "questions": "1. What is the purpose of the `Identifiers` object?\n- The `Identifiers` object defines parsers for identifiers and keywords in the syntax of a programming language.\n\n2. What is the difference between `VarId` and `PlainId`?\n- `VarId` matches an identifier that starts with a lowercase letter, while `PlainId` matches an identifier that starts with an uppercase letter or an operator.\n\n3. What is the purpose of the `NamedFunction` case class?\n- The `NamedFunction` case class is a helper wrapper that captures the name of the use site and provides a custom `toString` method for debugging purposes. It is used to define a function that takes a character and returns a boolean value."
                                },
                                {
                                  "fileName": "Literals.scala",
                                  "filePath": "parsers/shared/src/main/scala/sigmastate/lang/syntax/Literals.scala",
                                  "url": "sigmastate-interpreterhttps://github.com/ScorexFoundation/sigmastate-interpreter/parsers/shared/src/main/scala/sigmastate/lang/syntax/Literals.scala",
                                  "summary": "## Code Explanation: sigmastate.lang.syntax.Literals\n\nThe `Literals` trait is a collection of parsers for literal expressions used in the Sigma programming language. The trait defines a set of methods that parse different types of literals, including integers, booleans, strings, and null values. The trait also defines a set of methods that parse different types of whitespace, including newlines, semicolons, and comments.\n\nThe trait is designed to be mixed in with other traits and classes that define parsers for different parts of the Sigma language. The `builder` field is an instance of the `SigmaBuilder` trait, which is used by the parsers to create ErgoTree expressions. The `atSrcPos` method sets the current source position (dynamic variable) and executes the given thunk. The `srcCtx` method creates a `SourceContext` object using the current input string and the given index.\n\nThe `Block` method parses simple blocks of code enclosed in curly braces. The `Pattern` method parses patterns used in variable declarations. The `WS` method parses all whitespace, excluding newlines. The `WL0` method parses whitespace, including newlines. The `WL` method is a cut version of `WL0`. The `Semi` method parses semicolons. The `Semis` method parses one or more semicolons followed by whitespace. The `Newline` method parses newlines. The `NotNewline` method looks ahead for whitespace, but not newlines. The `OneNLMax` method parses one or more newlines followed by whitespace. The `TrailingComma` method parses an optional trailing comma.\n\nThe `Int` method parses decimal or hex integers or longs. The `Bool` method parses boolean values. The `CommentChunk` method parses chunks of comments. The `MultilineComment` method parses multiline comments. The `SameLineCharChunks` method parses chunks of characters on the same line. The `LineComment` method parses line comments. The `Comment` method parses either multiline or line comments. The `Null` method parses null values. The `OctalEscape` method parses octal escape sequences. The `Escape` method parses escape sequences. The `Symbol` method parses symbols. The `Char` method parses character literals.\n\nThe `InterpCtx` class is a helper class that defines methods for parsing interpolated strings. The `Literal` method parses literals used in interpolated strings. The `Interp` method parses interpolated expressions. The `TQ` method parses triple quotes. The `StringChars` method parses chunks of characters in a string. The `NonTripleQuoteChar` method parses non-triple quote characters. The `TripleChars` method parses chunks of characters in a triple-quoted string. The `TripleTail` method parses the tail of a triple-quoted string. The `SingleChars` method parses chunks of characters in a single-quoted string. The `String` method parses strings, including interpolated strings and triple-quoted strings.\n\nOverall, the `Literals` trait provides a set of parsers for literal expressions and whitespace that are used in other parts of the Sigma language. The trait is designed to be mixed in with other traits and classes that define parsers for different parts of the language.",
                                  "questions": "1. What is the purpose of the `Literals` object?\n- The `Literals` object contains parsers for various literal expressions such as integers, booleans, and strings.\n\n2. What is the role of the `SigmaBuilder` instance in this code?\n- The `SigmaBuilder` instance is used by the parsers in the `Literals` object to create ErgoTree expressions.\n\n3. What is the difference between `WL` and `WS` in this code?\n- `WL` parses whitespace including newlines, while `WS` parses all whitespace excluding newlines."
                                }
                              ],
                              "folders": [],
                              "summary": "The `.autodoc/docs/json/parsers/shared/src/main/scala/sigmastate/lang/syntax` folder contains Scala code for parsing ErgoScript, a scripting language used in the Ergo blockchain platform. The code is organized into several files, each providing specific functionality for parsing different aspects of the language.\n\n`Basic.scala` provides parsers for basic lexical elements, such as numbers, operators, and keywords. These parsers are essential building blocks for parsing ErgoScript code and generating an abstract syntax tree (AST).\n\n`Core.scala` defines a trait called \"Core\" that contains common aliases and keywords used in almost every parser in the file. It also provides methods for constructing ErgoTree unary and binary operations.\n\n`Exprs.scala` defines a set of parsers for ErgoScript expressions, organized in a trait called `Exprs`. These parsers are used to parse various ErgoScript constructs and build the AST for the parsed expressions.\n\n`Identifiers.scala` provides functionality for parsing and identifying identifiers and keywords in the Sigma programming language. It defines several parsers for different types of identifiers, operators, and keywords.\n\n`Literals.scala` is a collection of parsers for literal expressions used in the Sigma programming language. It defines methods for parsing different types of literals, including integers, booleans, strings, and null values, as well as whitespace and comments.\n\nHere's an example of how the `Expr` parser from `Exprs.scala` can be used:\n\n```scala\nval input = \"if (x > 0) x * 2 else x / 2\"\nval parsedExpr = fastparse.parse(input, Exprs.Expr(_))\n```\n\nThis code snippet would parse the input string containing an ErgoScript expression and return a parsed expression in the form of an AST.\n\nOverall, the code in this folder is crucial for parsing ErgoScript code and generating an AST, which can then be used for further processing, such as type checking, optimization, or code generation. The parsers are implemented using the FastParse library and are designed to work together to handle the various constructs and expressions found in ErgoScript.",
                              "questions": ""
                            }
                          ],
                          "summary": "The `.autodoc/docs/json/parsers/shared/src/main/scala/sigmastate/lang` folder contains Scala code for parsing ErgoScript, a scripting language used in the Ergo blockchain platform. The code is organized into several files, each providing specific functionality for parsing different aspects of the language.\n\n`SigmaParser.scala` is the main facade to the ErgoScript parser implementation. It provides methods to parse ErgoScript code into ErgoTree expressions and SType (Sigma Type) objects. The `SigmaParser` object extends several traits, including `Exprs`, `Types`, and `Core`, which define methods for parsing ErgoScript expressions, types, and constructing ErgoTree nodes, respectively. Example usage:\n\n```scala\nval code = \"1 + 2\"\nval parsed = SigmaParser(code)\nval tree = parsed.get.value\n```\n\n`Types.scala` provides parsers for type terms that can produce values of `SType`. The parsed type expressions are used to type-check ErgoScript code and to generate ErgoTree IR. Example usage:\n\n```scala\nval input = \"Int => Boolean\"\nval result = parse(input, Type(_))\nresult.get // returns SFunc(Array(SInt), SBoolean)\n```\n\nThe `syntax` subfolder contains several files for parsing ErgoScript:\n\n- `Basic.scala`: Provides parsers for basic lexical elements, such as numbers, operators, and keywords.\n- `Core.scala`: Defines a trait called \"Core\" that contains common aliases and keywords used in almost every parser in the file. It also provides methods for constructing ErgoTree unary and binary operations.\n- `Exprs.scala`: Defines a set of parsers for ErgoScript expressions, organized in a trait called `Exprs`. Example usage:\n\n  ```scala\n  val input = \"if (x > 0) x * 2 else x / 2\"\n  val parsedExpr = fastparse.parse(input, Exprs.Expr(_))\n  ```\n\n- `Identifiers.scala`: Provides functionality for parsing and identifying identifiers and keywords in the Sigma programming language.\n- `Literals.scala`: A collection of parsers for literal expressions used in the Sigma programming language.\n\nOverall, the code in this folder is crucial for parsing ErgoScript code and generating an AST, which can then be used for further processing, such as type checking, optimization, or code generation. The parsers are implemented using the FastParse library and are designed to work together to handle the various constructs and expressions found in ErgoScript.",
                          "questions": ""
                        }
                      ],
                      "summary": "The code in the `.autodoc/docs/json/parsers/shared/src/main/scala/sigmastate` folder is responsible for parsing ErgoScript, a scripting language used in the Ergo blockchain platform. The main entry point for parsing is the `SigmaParser.scala` file, which provides methods to parse ErgoScript code into ErgoTree expressions and SType (Sigma Type) objects. The `SigmaParser` object extends several traits, including `Exprs`, `Types`, and `Core`, which define methods for parsing ErgoScript expressions, types, and constructing ErgoTree nodes, respectively.\n\nFor example, to parse a simple ErgoScript expression, you can use the following code:\n\n```scala\nval code = \"1 + 2\"\nval parsed = SigmaParser(code)\nval tree = parsed.get.value\n```\n\nThe `Types.scala` file provides parsers for type terms that can produce values of `SType`. The parsed type expressions are used to type-check ErgoScript code and to generate ErgoTree IR. Example usage:\n\n```scala\nval input = \"Int => Boolean\"\nval result = parse(input, Type(_))\nresult.get // returns SFunc(Array(SInt), SBoolean)\n```\n\nThe `lang` subfolder contains several files for parsing ErgoScript:\n\n- `Basic.scala`: Provides parsers for basic lexical elements, such as numbers, operators, and keywords.\n- `Core.scala`: Defines a trait called \"Core\" that contains common aliases and keywords used in almost every parser in the file. It also provides methods for constructing ErgoTree unary and binary operations.\n- `Exprs.scala`: Defines a set of parsers for ErgoScript expressions, organized in a trait called `Exprs`. Example usage:\n\n  ```scala\n  val input = \"if (x > 0) x * 2 else x / 2\"\n  val parsedExpr = fastparse.parse(input, Exprs.Expr(_))\n  ```\n\n- `Identifiers.scala`: Provides functionality for parsing and identifying identifiers and keywords in the Sigma programming language.\n- `Literals.scala`: A collection of parsers for literal expressions used in the Sigma programming language.\n\nOverall, the code in this folder is crucial for parsing ErgoScript code and generating an AST, which can then be used for further processing, such as type checking, optimization, or code generation. The parsers are implemented using the FastParse library and are designed to work together to handle the various constructs and expressions found in ErgoScript.",
                      "questions": ""
                    }
                  ],
                  "summary": "The code in the `.autodoc/docs/json/parsers/shared/src/main/scala` folder is responsible for parsing ErgoScript, a scripting language used in the Ergo blockchain platform. The main entry point for parsing is the `SigmaParser.scala` file, which provides methods to parse ErgoScript code into ErgoTree expressions and SType (Sigma Type) objects. The `SigmaParser` object extends several traits, including `Exprs`, `Types`, and `Core`, which define methods for parsing ErgoScript expressions, types, and constructing ErgoTree nodes, respectively.\n\nFor example, to parse a simple ErgoScript expression, you can use the following code:\n\n```scala\nval code = \"1 + 2\"\nval parsed = SigmaParser(code)\nval tree = parsed.get.value\n```\n\nThe `Types.scala` file provides parsers for type terms that can produce values of `SType`. The parsed type expressions are used to type-check ErgoScript code and to generate ErgoTree IR. Example usage:\n\n```scala\nval input = \"Int => Boolean\"\nval result = parse(input, Type(_))\nresult.get // returns SFunc(Array(SInt), SBoolean)\n```\n\nThe `lang` subfolder contains several files for parsing ErgoScript:\n\n- `Basic.scala`: Provides parsers for basic lexical elements, such as numbers, operators, and keywords.\n- `Core.scala`: Defines a trait called \"Core\" that contains common aliases and keywords used in almost every parser in the file. It also provides methods for constructing ErgoTree unary and binary operations.\n- `Exprs.scala`: Defines a set of parsers for ErgoScript expressions, organized in a trait called `Exprs`. Example usage:\n\n  ```scala\n  val input = \"if (x > 0) x * 2 else x / 2\"\n  val parsedExpr = fastparse.parse(input, Exprs.Expr(_))\n  ```\n\n- `Identifiers.scala`: Provides functionality for parsing and identifying identifiers and keywords in the Sigma programming language.\n- `Literals.scala`: A collection of parsers for literal expressions used in the Sigma programming language.\n\nOverall, the code in this folder is crucial for parsing ErgoScript code and generating an AST, which can then be used for further processing, such as type checking, optimization, or code generation. The parsers are implemented using the FastParse library and are designed to work together to handle the various constructs and expressions found in ErgoScript.",
                  "questions": ""
                }
              ],
              "summary": "The code in the `.autodoc/docs/json/parsers/shared/src/main` folder is responsible for parsing ErgoScript, a scripting language used in the Ergo blockchain platform. The main entry point for parsing is the `SigmaParser.scala` file, which provides methods to parse ErgoScript code into ErgoTree expressions and SType (Sigma Type) objects. The `SigmaParser` object extends several traits, including `Exprs`, `Types`, and `Core`, which define methods for parsing ErgoScript expressions, types, and constructing ErgoTree nodes, respectively.\n\nFor example, to parse a simple ErgoScript expression, you can use the following code:\n\n```scala\nval code = \"1 + 2\"\nval parsed = SigmaParser(code)\nval tree = parsed.get.value\n```\n\nThe `Types.scala` file provides parsers for type terms that can produce values of `SType`. The parsed type expressions are used to type-check ErgoScript code and to generate ErgoTree IR. Example usage:\n\n```scala\nval input = \"Int => Boolean\"\nval result = parse(input, Type(_))\nresult.get // returns SFunc(Array(SInt), SBoolean)\n```\n\nThe `lang` subfolder contains several files for parsing ErgoScript:\n\n- `Basic.scala`: Provides parsers for basic lexical elements, such as numbers, operators, and keywords.\n- `Core.scala`: Defines a trait called \"Core\" that contains common aliases and keywords used in almost every parser in the file. It also provides methods for constructing ErgoTree unary and binary operations.\n- `Exprs.scala`: Defines a set of parsers for ErgoScript expressions, organized in a trait called `Exprs`. Example usage:\n\n  ```scala\n  val input = \"if (x > 0) x * 2 else x / 2\"\n  val parsedExpr = fastparse.parse(input, Exprs.Expr(_))\n  ```\n\n- `Identifiers.scala`: Provides functionality for parsing and identifying identifiers and keywords in the Sigma programming language.\n- `Literals.scala`: A collection of parsers for literal expressions used in the Sigma programming language.\n\nOverall, the code in this folder is crucial for parsing ErgoScript code and generating an AST, which can then be used for further processing, such as type checking, optimization, or code generation. The parsers are implemented using the FastParse library and are designed to work together to handle the various constructs and expressions found in ErgoScript.",
              "questions": ""
            }
          ],
          "summary": "The code in the `.autodoc/docs/json/parsers/shared/src` folder plays a crucial role in parsing ErgoScript, a scripting language used in the Ergo blockchain platform. The main entry point for parsing is the `SigmaParser.scala` file, which provides methods to parse ErgoScript code into ErgoTree expressions and SType (Sigma Type) objects. The `SigmaParser` object extends several traits, including `Exprs`, `Types`, and `Core`, which define methods for parsing ErgoScript expressions, types, and constructing ErgoTree nodes, respectively.\n\nFor example, to parse a simple ErgoScript expression, you can use the following code:\n\n```scala\nval code = \"1 + 2\"\nval parsed = SigmaParser(code)\nval tree = parsed.get.value\n```\n\nThe `Types.scala` file provides parsers for type terms that can produce values of `SType`. The parsed type expressions are used to type-check ErgoScript code and to generate ErgoTree IR. Example usage:\n\n```scala\nval input = \"Int => Boolean\"\nval result = parse(input, Type(_))\nresult.get // returns SFunc(Array(SInt), SBoolean)\n```\n\nThe `lang` subfolder contains several files for parsing ErgoScript:\n\n- `Basic.scala`: Provides parsers for basic lexical elements, such as numbers, operators, and keywords.\n- `Core.scala`: Defines a trait called \"Core\" that contains common aliases and keywords used in almost every parser in the file. It also provides methods for constructing ErgoTree unary and binary operations.\n- `Exprs.scala`: Defines a set of parsers for ErgoScript expressions, organized in a trait called `Exprs`. Example usage:\n\n  ```scala\n  val input = \"if (x > 0) x * 2 else x / 2\"\n  val parsedExpr = fastparse.parse(input, Exprs.Expr(_))\n  ```\n\n- `Identifiers.scala`: Provides functionality for parsing and identifying identifiers and keywords in the Sigma programming language.\n- `Literals.scala`: A collection of parsers for literal expressions used in the Sigma programming language.\n\nOverall, the code in this folder is crucial for parsing ErgoScript code and generating an AST, which can then be used for further processing, such as type checking, optimization, or code generation. The parsers are implemented using the FastParse library and are designed to work together to handle the various constructs and expressions found in ErgoScript.",
          "questions": ""
        }
      ],
      "summary": "The code in the `.autodoc/docs/json/parsers/shared` folder is essential for parsing ErgoScript, a scripting language used in the Ergo blockchain platform. The main entry point for parsing is the `SigmaParser.scala` file, which provides methods to parse ErgoScript code into ErgoTree expressions and SType (Sigma Type) objects. The `SigmaParser` object extends several traits, including `Exprs`, `Types`, and `Core`, which define methods for parsing ErgoScript expressions, types, and constructing ErgoTree nodes, respectively.\n\nFor example, to parse a simple ErgoScript expression, you can use the following code:\n\n```scala\nval code = \"1 + 2\"\nval parsed = SigmaParser(code)\nval tree = parsed.get.value\n```\n\nThe `Types.scala` file provides parsers for type terms that can produce values of `SType`. The parsed type expressions are used to type-check ErgoScript code and to generate ErgoTree IR. Example usage:\n\n```scala\nval input = \"Int => Boolean\"\nval result = parse(input, Type(_))\nresult.get // returns SFunc(Array(SInt), SBoolean)\n```\n\nThe `lang` subfolder contains several files for parsing ErgoScript:\n\n- `Basic.scala`: Provides parsers for basic lexical elements, such as numbers, operators, and keywords.\n- `Core.scala`: Defines a trait called \"Core\" that contains common aliases and keywords used in almost every parser in the file. It also provides methods for constructing ErgoTree unary and binary operations.\n- `Exprs.scala`: Defines a set of parsers for ErgoScript expressions, organized in a trait called `Exprs`. Example usage:\n\n  ```scala\n  val input = \"if (x > 0) x * 2 else x / 2\"\n  val parsedExpr = fastparse.parse(input, Exprs.Expr(_))\n  ```\n\n- `Identifiers.scala`: Provides functionality for parsing and identifying identifiers and keywords in the Sigma programming language.\n- `Literals.scala`: A collection of parsers for literal expressions used in the Sigma programming language.\n\nOverall, the code in this folder is crucial for parsing ErgoScript code and generating an AST, which can then be used for further processing, such as type checking, optimization, or code generation. The parsers are implemented using the FastParse library and are designed to work together to handle the various constructs and expressions found in ErgoScript.",
      "questions": ""
    }
  ],
  "summary": "The `.autodoc/docs/json/parsers` folder contains essential code for parsing ErgoScript, a scripting language used in the Ergo blockchain platform. The main entry point for parsing is the `SigmaParser.scala` file, which provides methods to parse ErgoScript code into ErgoTree expressions and SType (Sigma Type) objects. The `SigmaParser` object extends several traits, including `Exprs`, `Types`, and `Core`, which define methods for parsing ErgoScript expressions, types, and constructing ErgoTree nodes, respectively.\n\nFor example, to parse a simple ErgoScript expression, you can use the following code:\n\n```scala\nval code = \"1 + 2\"\nval parsed = SigmaParser(code)\nval tree = parsed.get.value\n```\n\nThe `Types.scala` file provides parsers for type terms that can produce values of `SType`. The parsed type expressions are used to type-check ErgoScript code and to generate ErgoTree IR. Example usage:\n\n```scala\nval input = \"Int => Boolean\"\nval result = parse(input, Type(_))\nresult.get // returns SFunc(Array(SInt), SBoolean)\n```\n\nThe `shared/lang` subfolder contains several files for parsing ErgoScript:\n\n- `Basic.scala`: Provides parsers for basic lexical elements, such as numbers, operators, and keywords.\n- `Core.scala`: Defines a trait called \"Core\" that contains common aliases and keywords used in almost every parser in the file. It also provides methods for constructing ErgoTree unary and binary operations.\n- `Exprs.scala`: Defines a set of parsers for ErgoScript expressions, organized in a trait called `Exprs`. Example usage:\n\n  ```scala\n  val input = \"if (x > 0) x * 2 else x / 2\"\n  val parsedExpr = fastparse.parse(input, Exprs.Expr(_))\n  ```\n\n- `Identifiers.scala`: Provides functionality for parsing and identifying identifiers and keywords in the Sigma programming language.\n- `Literals.scala`: A collection of parsers for literal expressions used in the Sigma programming language.\n\nOverall, the code in this folder is crucial for parsing ErgoScript code and generating an AST, which can then be used for further processing, such as type checking, optimization, or code generation. The parsers are implemented using the FastParse library and are designed to work together to handle the various constructs and expressions found in ErgoScript.",
  "questions": ""
}