 116 & \hyperref[sec:serialization:operation:SubstConstants]{\lst{SubstConstants}} & See~\ref{sec:appendix:primops:SubstConstants} \\
 \hline
          122 & \hyperref[sec:serialization:operation:LongToByteArray]{\lst{LongToByteArray}} & Converts \lst{Long} value to big-endian bytes representation. See~\ref{sec:appendix:primops:LongToByteArray} \\
 \hline
          123 & \hyperref[sec:serialization:operation:ByteArrayToBigInt]{\lst{ByteArrayToBigInt}} & Convert big-endian bytes representation (Coll[Byte]) to BigInt value. See~\ref{sec:appendix:primops:ByteArrayToBigInt} \\
 \hline
          124 & \hyperref[sec:serialization:operation:ByteArrayToLong]{\lst{ByteArrayToLong}} & Convert big-endian bytes representation (Coll[Byte]) to Long value. See~\ref{sec:appendix:primops:ByteArrayToLong} \\
 \hline
          125 & \hyperref[sec:serialization:operation:Downcast]{\lst{Downcast}} & Cast this numeric value to a smaller type (e.g. Long to Int). Throws exception if overflow. See~\ref{sec:appendix:primops:Downcast} \\
 \hline
          126 & \hyperref[sec:serialization:operation:Upcast]{\lst{Upcast}} & Cast this numeric value to a bigger type (e.g. Int to Long) See~\ref{sec:appendix:primops:Upcast} \\
 \hline
          140 & \hyperref[sec:serialization:operation:SelectField]{\lst{SelectField}} & Select tuple field by its 1-based index. E.g. \lst{input._1} is transformed to \lst{SelectField(input, 1)} See~\ref{sec:appendix:primops:SelectField} \\
 \hline
          143 & \hyperref[sec:serialization:operation:LT]{\lst{LT}} & Returns \lst{true} is the left operand is less then the right operand, \lst{false} otherwise. See~\ref{sec:appendix:primops:LT} \\
 \hline
          144 & \hyperref[sec:serialization:operation:LE]{\lst{LE}} & Returns \lst{true} is the left operand is less then or equal to the right operand, \lst{false} otherwise. See~\ref{sec:appendix:primops:LE} \\
 \hline
          145 & \hyperref[sec:serialization:operation:GT]{\lst{GT}} & Returns \lst{true} is the left operand is greater then the right operand, \lst{false} otherwise. See~\ref{sec:appendix:primops:GT} \\
 \hline
          146 & \hyperref[sec:serialization:operation:GE]{\lst{GE}} & Returns \lst{true} is the left operand is greater then or equal to the right operand, \lst{false} otherwise. See~\ref{sec:appendix:primops:GE} \\
 \hline
          147 & \hyperref[sec:serialization:operation:EQ]{\lst{EQ}} & Compare equality of \lst{left} and \lst{right} arguments See~\ref{sec:appendix:primops:EQ} \\
 \hline
          148 & \hyperref[sec:serialization:operation:NEQ]{\lst{NEQ}} & Compare inequality of \lst{left} and \lst{right} arguments See~\ref{sec:appendix:primops:NEQ} \\
 \hline
          149 & \hyperref[sec:serialization:operation:If]{\lst{If}} & Compute condition, if true then compute trueBranch else compute falseBranch See~\ref{sec:appendix:primops:If} \\
 \hline
          150 & \hyperref[sec:serialization:operation:AND]{\lst{AND}} & Returns true if \emph{all} the elements in collection are \lst{true}. See~\ref{sec:appendix:primops:AND} \\
 \hline
          151 & \hyperref[sec:serialization:operation:OR]{\lst{OR}} & Returns true if \emph{any} the elements in collection are \lst{true}. See~\ref{sec:appendix:primops:OR} \\
 \hline
          152 & \hyperref[sec:serialization:operation:AtLeast]{\lst{AtLeast}} & See~\ref{sec:appendix:primops:AtLeast} \\
 \hline
          153 & \hyperref[sec:serialization:operation:Minus]{\lst{Minus}} & Returns a result of subtracting second numeric operand from the first. See~\ref{sec:appendix:primops:Minus} \\
 \hline
          154 & \hyperref[sec:serialization:operation:Plus]{\lst{Plus}} & Returns a sum of two numeric operands See~\ref{sec:appendix:primops:Plus} \\
 \hline
          155 & \hyperref[sec:serialization:operation:Xor]{\lst{Xor}} & Byte-wise XOR of two collections of bytes. Example: \lst{xs | ys}. See~\ref{sec:appendix:primops:Xor} \\
 \hline
          156 & \hyperref[sec:serialization:operation:Multiply]{\lst{Multiply}} & Returns a multiplication of two numeric operands See~\ref{sec:appendix:primops:Multiply} \\
 \hline
          157 & \hyperref[sec:serialization:operation:Division]{\lst{Division}} & Integer division of the first operand by the second operand. See~\ref{sec:appendix:primops:Division} \\
 \hline
          158 & \hyperref[sec:serialization:operation:Modulo]{\lst{Modulo}} & Reminder from division of the first operand by the second operand. See~\ref{sec:appendix:primops:Modulo} \\
 \hline
          161 & \hyperref[sec:serialization:operation:Min]{\lst{Min}} & Minimum value of two operands. See~\ref{sec:appendix:primops:Min} \\
 \hline
          162 & \hyperref[sec:serialization:operation:Max]{\lst{Max}} & Maximum value of two operands. See~\ref{sec:appendix:primops:Max} \\
 \hline
          203 & \hyperref[sec:serialization:operation:CalcBlake2b256]{\lst{CalcBlake2b256}} & Calculate Blake2b hash from \lst{input} bytes. See~\ref{sec:appendix:primops:CalcBlake2b256} \\
 \hline
          204 & \hyperref[sec:serialization:operation:CalcSha256]{\lst{CalcSha256}} & Calculate Sha256 hash from \lst{input} bytes. See~\ref{sec:appendix:primops:CalcSha256} \\
 \hline
          205 & \hyperref[sec:serialization:operation:CreateProveDlog]{\lst{CreateProveDlog}} & ErgoTree operation to create a new \lst{SigmaProp} value representing public key
 of discrete logarithm signature protocol.
         See~\ref{sec:appendix:primops:CreateProveDlog} \\
 \hline
          206 & \hyperref[sec:serialization:operation:CreateProveDHTuple]{\lst{CreateProveDHTuple}} &  ErgoTree operation to create a new SigmaProp value representing public key
 of Diffie Hellman signature protocol.
 Common input: (g,h,u,v)
         See~\ref{sec:appendix:primops:CreateProveDHTuple} \\
 \hline
          209 & \hyperref[sec:serialization:operation:BoolToSigmaProp]{\lst{BoolToSigmaProp}} & See~\ref{sec:appendix:primops:BoolToSigmaProp} \\
 \hline
          212 & \hyperref[sec:serialization:operation:DeserializeContext]{\lst{DeserializeContext}} & See~\ref{sec:appendix:primops:DeserializeContext} \\
 \hline
          213 & \hyperref[sec:serialization:operation:DeserializeRegister]{\lst{DeserializeRegister}} & See~\ref{sec:appendix:primops:DeserializeRegister} \\
 \hline
          218 & \hyperref[sec:serialization:operation:Apply]{\lst{Apply}} & Apply the function to the arguments.  See~\ref{sec:appendix:primops:Apply} \\
 \hline
          227 & \hyperref[sec:serialization:operation:GetVar]{\lst{GetVar}} & Get context variable with given \lst{varId} and type. See~\ref{sec:appendix:primops:GetVar} \\
 \hline
          234 & \hyperref[sec:serialization:operation:SigmaAnd]{\lst{SigmaAnd}} & Returns sigma proposition which is proven when \emph{all} the elements in collection are proven. See~\ref{sec:appendix:primops:SigmaAnd} \\
 \hline
          235 & \hyperref[sec:serialization:operation:SigmaOr]{\lst{SigmaOr}} & Returns sigma proposition which is proven when \emph{any} of the elements in collection is proven. See~\ref{sec:appendix:primops:SigmaOr} \\
 \hline
          236 & \hyperref[sec:serialization:operation:BinOr]{\lst{BinOr}} & Logical OR of two operands See~\ref{sec:appendix:primops:BinOr} \\
 \hline
          237 & \hyperref[sec:serialization:operation:BinAnd]{\lst{BinAnd}} & Logical AND of two operands See~\ref{sec:appendix:primops:BinAnd} \\
 \hline
          238 & \hyperref[sec:serialization:operation:DecodePoint]{\lst{DecodePoint}} & Convert \lst{Coll[Byte]} to \lst{GroupElement} using \lst{GroupElementSerializer} See~\ref{sec:appendix:primops:DecodePoint} \\
 \hline
          239 & \hyperref[sec:serialization:operation:LogicalNot]{\lst{LogicalNot}} & Logical NOT operation. Returns \lst{true} if input is \lst{false} and \lst{false} if input is \lst{true}. See~\ref{sec:appendix:primops:LogicalNot} \\
 \hline
          240 & \hyperref[sec:serialization:operation:Negation]{\lst{Negation}} & Negates numeric value \lst{x} by returning \lst{-x}. See~\ref{sec:appendix:primops:Negation} \\
 \hline
          244 & \hyperref[sec:serialization:operation:BinXor]{\lst{BinXor}} & Logical XOR of two operands See~\ref{sec:appendix:primops:BinXor} \\
 \hline
          255 & \hyperref[sec:serialization:operation:XorOf]{\lst{XorOf}} & Similar to \lst{allOf}, but performing logical XOR operation between all conditions instead of \lst{&&} See~\ref{sec:appendix:primops:XorOf} \\
 \hline
         