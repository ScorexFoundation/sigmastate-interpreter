\section{Motivations}
\label{sec:appendix:motivation}

\subsection{Type Serialization format rationale}
\label{sec:appendix:motivation:type}

\langname types terms are serialized using special encoding designed for compact
storage yet fast deserialization. In this section we describe the motivation.

Some operations of \ASDag have type parameters, for which concrete types should be
specified (since \ASDag is monomorphic IR). When the operation (such as
\hyperref[sec:serialization:operation:ExtractRegisterAs]{\lst{ExtractRegisterAs}}) is
serialized those type parameters should also be serialized as part of the operation.
The following encoding is designed to minimize a number of bytes required to represent
type in the serialization format of \ASDag. Since most of the scripts will use simple
types so we want them the take a single byte of the storage.

In the intermediate representation of ErgoTree each type is represented by a tree of
nodes where leaves are primitive types and other nodes are type constructors. Simple
(but sub-optimal) way to serialize a type would be to give each primitive type and each
type constructor a unique type code. Then, to serialize a node, we whould need to emit
its code and then perform recursive descent to serialize all children.

However, to save storage space, we use special encoding schema to save bytes
for the types that are used more often.

We assume the most frequently used types are:
\begin{itemize}
    \item primitive types (\lst{Boolean}, \lst{Byte}, \lst{Short}, \lst{Int}, \lst{Long}, \lst{BigInt}, \lst{GroupElement},
    \lst{SigmaProp}, \lst{Box}, \lst{AvlTree})
    \item  Collections of primitive types (\lst{Coll[Byte]} etc)
    \item  Options of primitive types (\lst{Option[Int]} etc.)
    \item Nested arrays of primitive types (\lst{Coll[Coll[Int]]} etc.)
    \item Functions of primitive types (\lst{Box => Boolean} etc.)
    \item First biased pair of types (\lst{(_, Int)} when we know the first
    component is a primitive type).
    \item Second biased pair of types (\lst{(Int, _)} when we know the second
    component is a primitive type)
    \item Symmetric pair of types (\lst{(Int, Int)} when we know both types are
    the same)
\end{itemize}

All the types above should be represented in an optimized way preferably by a single
byte (see examples in Figure~\ref{fig:ser:type:examples}). For other types, we do
recursive descent down the type tree as it is defined in
section~\ref{sec:ser:type:recursive}.

\subsection{Constant Segregation rationale}
\label{sec:appendix:motivation:segregation}

\subsubsection{Massive script validation}
\label{sec:appendix:motivation:segregation:massive}

Consider a transaction \lst{tx} which have \lst{INPUTS} collection of boxes to spend.
Every input box can have a script protecting it (\lst{propostionBytes} property). This
script should be executed in a context of the current transaction. The simplest
transaction have 1 input box. Thus if we want to have a sustained block validation of
1000 transactions per second we need to be able to validate 1000 scripts per second at
minimum. Additionally, the block validation time should be as small as possible so that
a miner can start solving the PoW puzzle as soon as possible to increase the
probability of the successful mining.

For every script (of an input \lst{box}) the following is done in order to
validate it (and should be executed as fast as possible):
\begin{enumerate}
    \item A Context object is created with \lst{SELF} = box
    \item ErgoTree is traversed to build a cost graph - the graph for the cost
    estimation
    \item Cost estimation is computed by evaluating the cost graph with the current
    context 
    \item If the cost within the limit, the ErgoTree is evaluated using the context to
    obtain sigma proposition (see \hyperref[sec:type:SigmaProp]{\lst{SigmaProp}})
    \item Sigma protocol verification procedure is executed
\end{enumerate}

\subsubsection{The Potential Script Processing Optimization}

Before an ErgoScript contract can be stored in a blockchain it should be first compiled
from its source code into ErgoTree and then serialized into byte array. Because the
ErgoTree is purely functional graph-based IR, the compiler may perform various
optimizations for reducing a size of the tree. This will have an effect of
normalization/unification, in which different original scripts may be compiled into the
identical ErgoTrees and as a result the identical serialized bytes.

In many cases two boxes will have the same ErgoTree up to a substitution of constants. 
For example all pay-to-public-key scripts have the same ErgoTree template in which only 
public key (constant of GroupElement type) is replaced. 

Because of normalization, and also because of script template reusability, the number
different scripts templates is much less than the number
of actual ErgoTrees in the UTXO boxes. For example we may have 1000s of
different script templates in a blockchain with millions of UTXO boxes.

The average reusability ratio is 1000 in this case. And even those 1000 different
scripts may have different usage frequency. Having big reusability ratio we can
optimize script evaluation by performing the step 2 from
section~\ref{sec:appendix:motivation:segregation:massive} only once per unique script.

The compiled cost graph can be cached in \lst{Map[Array[Byte], Context =>
Int]}. Every ErgoTree template extracted from an input box can be used as the key
in this map to obtain the graph which is ready to execute.

However, there is an obstacle to the optimization by caching, i.e. the constants
embedded in contracts. In many cases it is natural to
embed constants in the ErgoTree body with the most notable scenario is when public keys
are embedded. As the result two functionally identical scripts are serialized to
the different byte arrays because they have the different embedded constants.

\subsubsection{Templatized ErgoTree}

A solution to the problem with embedded constants is simple, we don't need to embed
constants. Each constant in the body of \ASDag can be replaced with an indexed
placeholder node (see
\hyperref[sec:appendix:primops:ConstantPlaceholder]{\lst{ConstantPlaceholder}}). Each
placeholder have an index of the constant in the \lst{constants} collection of
\lst{ErgoTree}. 

The transformation is part of compilation and is performed ahead of time.
Each \ASDag have an array of all the constants extracted from its body. Each
placeholder refers to the constant by the constant's index in the array.
The index of the placeholder can be assigned by breadth-first topological
order of the graph traversal during compilation of ErgoScript into ErgoTree. Whatever
method is used, a placeholder should always refer to an existing constant.

Thus the format of serialized ErgoTree with is shown in Figure~\ref{fig:ser:ergotree}
which contains:
\begin{enumerate}
    \item The bytes of collection with \emph{segregated constants}
    \item The bytes of script expression with placeholders
\end{enumerate}

The collection of constants contains the serialized constant data (using
\hyperref[sec:ser:const]{\lst{ConstantSerializer}}) one after another. The script
expression is a serialized \hyperref[sec:ser:expr]{\lst{Value}} with placeholders.

Using such script format we can use the script expression bytes as a key in the cache.
The observation is that after the constants are segregated, what remains is the
template. Thus, instead of applying steps 1-2 from
section~\ref{sec:appendix:motivation:segregation:massive} to \emph{constant-full}
scripts we can apply them to \emph{constant-less} templates. 
Before applying the steps 3 - 5 we need to bind placeholders with actual values taken
from the constants collection and then evaluate both cost graph and ErgoTree.