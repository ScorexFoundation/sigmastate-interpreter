\section{Typing}
\label{sec:typing}

\langname is a strictly typed language, in which every term should have a
type in order to be wellformed and evaluated. Typing judgement of the form
$\Der{\Gamma}{e : T}$ say that $e$ is a term of type $T$ in the typing
context $\Gamma$.

\begin{figure}[h]
\input{figures/fig_typing.tex}
\caption{Typing rules of \langname}
\label{fig:typing}
\end{figure}

Note that each well-typed term has exactly one type hence we assume there
exists a funcion $termType: Term \to \mathcal{T}$ which relates each well-typed
term with the corresponding type.

Primitive operations can be parameterized with type variables, for example
addition (\ref{sec:appendix:primops:Plus}) has the signature \lst{def +}$[$\lst{T}$]$(\lst{left}$:$~\lst{T}, \lst{right}$:$~\lst{T}): \lst{T}
where \lst{T} is one of the numeric types (Table~\ref{table:predeftypes}). 
Function $ptype$ returns the type of a primitive operation specialized for the concrete
types of its arguments, for example
$ptype(+,\lst{Int}, \lst{Int}) = (\lst{Int}, \lst{Int}) \to \lst{Int}$.

Similarily, the function $mtype$ returns a type of method specialized for concrete types of the arguments of the \lst{MethodCall} term.

\lst{BlockValue} rule defines a type of well-formed block expression. It
assumes a total ordering on \lst{val} definitions. If a block expression is
not well-formed than it cannot be typed and evaluated.

The rest of the rules are standard for typed lambda calculus.