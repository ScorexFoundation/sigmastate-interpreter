\section{Serialization}
\label{sec:serialization}

This section defines a binary format, which is used to store \langname
contracts in persistent stores, to transfer them over the wire and to enable
cross-platform interoperation.

Terms of the language described in Section~\ref{sec:language} can be
serialized to array of bytes to be stored in Ergo blockchain (e.g. as
\lst{Box.propositionBytes}).

When the guarding script of an input box of a transaction is validated the
\lst{propositionBytes} array is deserialized to an \langname IR (represented by the
\lst{ErgoTree} class), which can be evaluated as it is specified in
Section~\ref{sec:evaluation}.

Here we specify the serialization procedure in general. The serialization format of
\langname types (\lst{SType} class) and nodes (\lst{Value} class) is specified in
section~\ref{sec:ser:type} and Appendix~\ref{sec:appendix:ergotree_serialization}
correspondingly.

Table~\ref{table:ser:limits} shows size limits which are checked during
contract deserialization, which is important to resist malicious script attacks.

\begin{table}[h]
    \caption{Serialization limits}\vspace{-7pt}
    \label{table:ser:limits}
    \footnotesize
\(\begin{tabularx}{\textwidth}{| l | p{2.5cm} | X |}
    \hline
    \bf{Constant}   & \bf{Value} & \bf{Description} \\
    \hline
    $\MaxVlqSize$  & $10$ & Maximum size of VLQ encoded byte sequence (See VLQ formats~\ref{sec:vlq-encoding})  \\
    \hline
    $\MaxTypeSize$ & $100$ & Maximum size of serialized type term (see Type format~\ref{sec:ser:type}) \\
    \hline
    $\MaxDataSize$ & $4Kb$ & Maximum size of serialized data instance (see Data format~\ref{sec:ser:data}) \\
    \hline
    $\MaxConstSize$ & $=\MaxTypeSize+\MaxDataSize$  & Maximum size of serialized data instance (see Const format~\ref{sec:ser:const}) \\
    \hline
    $\MaxExprSize$ & $4Kb$ & Maximum size of serialized \langname term (see Expr format~\ref{sec:ser:expr}) \\
    \hline
    $\MaxErgoTreeSize$ & $4Kb$ & Maximum size of serialized \langname contract (see ErgoTree format~\ref{sec:ser:ergotree}) \\
    \hline
\end{tabularx}\)

\end{table}

All the serialization formats which are uses and defined thoughout this section are
listed in Table~\ref{table:ser:formats} which introduces a name for each format and also
shows the number of bytes each format may occupy in the byte stream.

\begin{table}[H] \scriptsize
\caption{Serialization formats}\vspace{-7pt}
\label{table:ser:formats}
\(\begin{tabularx}{\textwidth}{| l | l | X |}
    \hline
    \bf{Format} & \bf{\#bytes} & \bf{Description} \\
    \hline
    \lst{Byte} & $1$ & 8-bit signed two's-complement integer \\
    \hline
    \lst{Short} & $2$ & 16-bit signed two's-complement integer (big-endian) \\
    \hline    
    \lst{Int} & $4$ & 32-bit signed two's-complement integer (big-endian) \\
    \hline
    \lst{Long} & $8$ & 64-bit signed two's-complement integer (big-endian) \\
    \hline
    \lst{UByte} & $1$ & 8-bit unsigned integer \\
    \hline
    \lst{UShort} & $2$ & 16-bit unsigned integer (big-endian) \\
    \hline    
    \lst{UInt} & $4$ & 32-bit unsigned integer (big-endian) \\
    \hline
    \lst{ULong} & $8$ & 64-bit unsigned integer (big-endian) \\

    \hline
    \lst{VLQ(UShort)} & $[1..3]$ & Encoded unsigned \lst{Short} value using VLQ. See~\cite{VLQWikipedia,VLQRosetta} and~\ref{sec:vlq-encoding} \\
    \hline    
    \lst{VLQ(UInt)} & $[1..5]$ & Encoded unsigned 32-bit integer using VLQ. \\
    \hline
    \lst{VLQ(ULong)} & $[1..\MaxVlqSize]$ & Encoded unsigned 64-bit integer using VLQ. \\

    \hline
    \lst{Bits} & $[1..\MaxBits]$ & A collection of bits packed in a sequence of bytes. \\
    \hline
    \lst{Bytes} & $[1..\MaxBytes]$ & A sequence of bytes, which size is stored elsewhere or wellknown. \\

    \hline
    \lst{Type} & $[1..\MaxTypeSize]$ & Serialized type terms of \langname. See~\ref{sec:ser:type} \\
    \hline
    \lst{Data} & $[1..\MaxDataSize]$ & Serialized data values of \langname. See~\ref{sec:ser:data} \\
    \hline
    \lst{GroupElement} & $33$ & Serialized elements of eliptic curve group. See~\ref{sec:ser:data:groupelement} \\
    \hline
    \lst{SigmaProp} & $[1..\MaxSigmaProp]$ & Serialized sigma propositions. See~\ref{sec:ser:data:sigmaprop} \\
    \hline
    \lst{AvlTree} & $44$ & Serialized dynamic dictionary digest. See~\ref{sec:ser:data:avltree} \\
    \hline
    \lst{Constant} & $[1..\MaxConstSize]$ & Serialized \langname constants (values with types). See~\ref{sec:ser:const} \\
    \hline
    \lst{Expr} & $[1..\MaxExprSize]$ & Serialized expression terms of \langname. See~\ref{sec:ser:expr} \\
    \hline
    \lst{ErgoTree} & $[1..\MaxErgoTreeSize]$ & Serialized instances of \langname contracts. See~\ref{sec:ser:ergotree} \\
    \hline
\end{tabularx}\)
\end{table}

We use $[1..n]$ notation when serialization may produce from 1 to n bytes depending of
actual data instance.

Serialization format of \ASDag is optimized for compact storage and very fast
deserialization. In many cases serialization procedure is data dependent and thus have
branching logic. To express this complex serialization logic in the specification we
use a \emph{pseudo-language} with operators like \lst{for, match, if, optional}. The
language allows to specify a \emph{structure} out of \emph{simple serialization slots}.
Each \emph{slot} specifies a fragment of serialized stream of bytes, whereas
\emph{operators} specifiy how the slots are combined together to form the resulting
stream of bytes. The notation is summarized in Table~\ref{table:ser:notation}.

\begin{table}[h] \footnotesize
\caption{Serialization Notation}
\label{table:ser:notation}
\(\begin{tabularx}{\textwidth}{| l | X |}
    \hline
    \bf{Notation} & \bf{Description} \\
    \hline
    $\Denot{T}$ where $T$ - type & Denotes a set of values of type $T$  \\
    \hline
    $v \in \Denot{T}$ & The value $v$ belongs to the set $\Denot{T}$ \\
    \hline   
    $v : T$ & Same as $v \in \Denot{T}$ \\
    \hline    
    \lst{match} $(t, v)$ & Pattern match on pair $(t, v)$ where $t, v$ - values \\
    \hline    
    \lst{with} $(Unit, v \in \Denot{Unit})$ & Pattern case \\
    \hline    

    \lst{for}~$i=1$~\lst{to}~$len$ & \multirow{3}{=}{Call 
        the given \lst{serialize} function repeatedly. 
        The outputs bytes of all invocations are concatenated and become 
        the output of the \lst{for} statement. } \\
    ~~\lst{serialize(}$v_i$\lst{)} &  \\
    \lst{end for} & \\
    \hline

    \lst{if}~$condition$~\lst{then} & \multirow[t]{5}{=}{Serialize 
        one of the branches depending of the $condition$.  
        The output bytes of the executed branch becomes the output of the \lst{if} statement. } \\
    ~~\lst{serialize1(}$v_1$\lst{)} &  \\
    \lst{else} & \\
    ~~\lst{serialize2(}$v_2$\lst{)} &  \\
    \lst{end if} & \\
    \hline
\end{tabularx}\)
\end{table}

In the next section we describe how types (like \lst{Int}, \lst{Coll[Byte]},
etc.) are serialized, then we define serialization of typed data. This will
give us a basis to describe serialization of Constant nodes of \ASDag. From
that we will proceed to serialization of arbitrary \ASDag trees.

\input{type_serialization.tex}

\input{data_serialization.tex}

\input{const_serialization.tex}

\input{expr_serialization.tex}

\input{ergotree_serialization.tex}

