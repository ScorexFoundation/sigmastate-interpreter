\documentclass[11pt]{article}

\def\shownotes{1}
\def\notesinmargins{0}

\usepackage{fullpage}

\usepackage{mathtools,color,xcolor,hyperref,graphicx,wrapfig,listings,array,xspace}

\usepackage{amsfonts}
% https://tex.stackexchange.com/questions/11719/how-do-i-backcolor-in-verbatim
\usepackage{xcolor}
\usepackage{alltt}
% Compensate for fbox sep:
\newcommand\Hi[2][lightgray]{%
	\hspace*{-\fboxsep}%
	\colorbox{#1}{#2}%
	\hspace*{-\fboxsep}%
}

\ifnum\shownotes=1
\ifnum\notesinmargins=1
\newcommand{\authnote}[2]{\marginpar{\parbox{\marginparwidth}{\tiny %
  \textsf{#1 {\textcolor{blue}{notes: #2}}}}}%
  \textcolor{blue}{\textbf{\dag}}}
\else
\newcommand{\authnote}[2]{
  \textsf{#1 \textcolor{blue}{: #2}}}
\fi
\else
\newcommand{\authnote}[2]{}
\fi

\newcommand{\lnote}[1]{{\authnote{\textcolor{orange}{Leo notes}}{#1}}}
\newcommand{\snote}[1]{{\authnote{\textcolor{yellow}{Scalahub notes}}{#1}}}
\newcommand{\knote}[1]{{\authnote{\textcolor{green}{kushti notes}}{#1}}}
\newcommand{\mnote}[1]{{\authnote{\textcolor{red}{Morphic}}{#1}}}
\newcommand{\dnote}[1]{{\authnote{\textcolor{brown}{Dima notes}}{#1}}}

\newcommand{\ret}{\mathsf{ret}}
\newcommand{\new}{\mathsf{new}}
\newcommand{\hnew}{h_\mathsf{new}}
\newcommand{\old}{\mathsf{old}}
\newcommand{\op}{\mathsf{op}}
\newcommand{\verifier}{\mathcal{V}}
\newcommand{\prover}{\mathcal{P}}
\newcommand{\key}{\mathsf{key}}
\newcommand{\nextkey}{\mathsf{nextKey}}
\newcommand{\node}{\mathsf{t}}
\newcommand{\parent}{\mathsf{p}}
\newcommand{\leaf}{\mathsf{f}}
\newcommand{\vl}{\mathsf{value}}
\newcommand{\balance}{\mathsf{balance}}
\newcommand{\lft}{\mathsf{left}}
\newcommand{\rgt}{\mathsf{right}}
\newcommand{\lbl}{\mathsf{label}}
\newcommand{\direction}{\mathsf{d}}
\newcommand{\oppositedirection}{\bar{\mathsf{d}}}
\newcommand{\found}{\mathsf{found}}
\newcommand{\mypar}[1]{\smallskip\noindent\textbf{#1.}\ \ \ }
\newcommand{\ignore}[1]{}

\newcommand{\langname}{ErgoScript\xspace}
\newcommand{\mixname}{ErgoMix\xspace}

\newcommand{\lst}[1]{\text{\lstinline[basicstyle={\ttfamily}]$#1$}}

\newcommand{\andnode}{\ensuremath{\mathsf{AND}}}
\newcommand{\ornode}{\ensuremath{\mathsf{OR}}}
\newcommand{\tnode}{\ensuremath{\mathsf{THRESHOLD}}}
\newcommand{\GF}{\ensuremath{\mathrm{GF}}}


\begin{document}

\title{Smart Contracts in \langname}

%\title{Protocols in \langname: From Games to Mixers}

\author{authors}


\maketitle


\begin{abstract}
%This article describes \langname via examples. 
We use \langname to create smart contracts for several protocols such as an XOR game, a rock-paper-scissors game, {\em reversible addresses} that have anti-theft features, and {\em \mixname}, a protocol to enhance transaction privacy. 

%We create several protocols using \langname, such as games and mixing protocols. 
\end{abstract}


\section{Introduction}

The Ergo platform\footnote{\url{https://ergoplatform.org/}} is a smart contract platform (i.e., a `programmable blockchain'). It has Bitcoin's UTXO model and Ethereum-like functionality that it provides via a language called \langname. Note that certain smart contracts \langname  (such as \mixname in Section~\ref{mix}) dcannot be easily ported to Ethereum due to its account-based model (as opposed to UTXOs). Ergo is written primarily in Scala and the syntax of \langname is very similar to Scala's. Under the hood, \langname code is compiled to low-level language called ErgoTree, which is what an Ergo node understands. In this article, we give a high-level overview of Ergo and describe \langname using examples.

Similar to Bitcoin, Ergo uses scripts to `protect' funds stored in UTXOs, which are called {\em boxes} in Ergo. A script contains the spending condition for a box and the spender must provide a `proof' of satisfying that condition. A transaction can spend (destroy) and create multiple boxes. While in Bitcoin, the proofs are generally signatures under a public key, in Ergo, these proofs are Non-Interactive Zero-Knowledge (NIZK) proofs, which we describe below.
% created by applying the Fiat-Shamir transform~\cite{fiatshamir} to interactive protocols called a $\Sigma$-protocols. 


\section{Cryptographic Primitives}
 
A key feature of \langname is the use of \emph{$\Sigma$-protocols} (pronounced ``sigma-protocols'') as underlying primitives. A transaction's output is protected by a statement. In order to spend the output, the statement needs to be proven true by attaching a proof. The combination of the statement and the proof forms a $\Sigma$-protocol. We refer the reader to \cite{Dam10} and \cite[Chapter 6]{HL10} for details of $\Sigma$-protocols. %Here we give a brief overview. 

\subsection{$\Sigma$-Protocols}
\label{intro:sigma}

The classic example of a $\Sigma$-protocol is the Schnorr identification scheme~\cite{Sch91}. Let $G$ be a cyclic multiplicative group of prime order $q$ and $g$ a generator of $G$. Assume that computing discrete logarithms in $G$ is hard. Alice has a secret $x \in \mathbb{Z}_q$, which she wants to prove knowledge of to some Bob who knows $u = g^x$.

%The classic example of a $\Sigma$-protocol is the following 3-step identification scheme due to~\cite{Sch91}. Let $G$ be a cyclic multiplicative group of prime order $q$ and $g$ a generator of $G$. Assume that computing discrete logarithms in $G$ is hard. Alice has a secret $x \in \mathbb{Z}_q$, which she wants to prove knowledge of to some Bob who knows $u = g^x$.
\begin{enumerate}
	\item \textbf{Commit:} Alice selects a random $r$, computes $t = g^r$ and sends $t$ to Bob.
	\item \textbf{Challenge:} Bob selects a random $c\in\mathbb{Z}_q$ and sends $c$ to Alice.
	\item \textbf{Response:} Alice computes $z = r + cx$ and sends $z$ to Bob. Bob accepts iff $g^z = t\cdot u^c$.
\end{enumerate}

The above protocol is a proof of knowledge because Bob can extract $x$ if he can get Alice to respond twice for the same $r$ and different $c$. As an example, for $c = 1, 2$, Bob can obtain $r+x$ and $r+2x$, the difference of which gives $x$. This is also called (special) soundness. The above protocol is also (honest verifier) zero-knowledge because anyone can impersonate Alice if the challenge $c$ of Step 2 is known in advance, simply by picking random $z \in\mathbb{Z}_q$ and computing $t = g^z/u^c$. The statement ``I know the discrete log of $u$ to base $g$'' is called the {\em proposition}, which we denote by $\tau$.

Any protocol that has the above 3-move structure (Alice $\stackrel{t}{\rightarrow}$ Bob, Bob $\stackrel{c}{\rightarrow}$ Alice, Alice $\stackrel{z}{\rightarrow}$ Bob), along with zero-knowledge and soundness property is called a $\Sigma$-protocol. 

\subsection{$\Sigma$-Proofs}
For any $\Sigma$-protocol with messages $(t, c, z)$, we can apply the Fiat-Shamir transform~\cite{fiatshamir} to convert it into a non-interactive one by replacing the role of Bob in Step 2 by any hash function $H$ and computing $c$ = $H(t)$. The resulting protocol with messages $(t, H(t), z)$ can be performed by Alice alone. Intuitively, since $c$ depends deterministically on $t$, Bob cannot ``rewind'' Alice and get two different responses for the same $r$. Additionally, Alice cannot know $c$ in advance before deciding $t$ if $H$ behaves like a random oracle. We call such a non-interactive proof a {\em $\Sigma$-proof}~\cite{Cra96} .

Conceptually, $\Sigma$-proofs are generalizations of digital signatures~\cite{CL06}.
In fact, Schnorr signature scheme~\cite{Sch91} (whose more recent version is popularly known as EdDSA \cite{BDLSY12,rfc8032}) is a special case of the above identification protocol with $c = H(t \Vert m)$, where $m$ is the message. The signature proves that the recipient knows the discrete logarithm of the public key (the proof is attached to a specific message, such as a particular transaction, and thus becomes a signature on the message; all $\Sigma$-proofs described here are attached to specific messages). $\Sigma$-proofs exist for proving a variety of properties and, importantly for \langname, elementary $\Sigma$-proofs can be combined into more sophisticated ones using the techniques of \cite{CDS94}. 

\section{Overview of \langname}
Although \langname uses $\Sigma$-protocols, it does so transparently. Developers are not required to understand the cryptography behind such protocols in order to use them. Here we describe \langname ``under the hood'' -- how it works and what primitives it uses.

\subsection{Elementary $\Sigma$-Protocols}

\langname provides as primitives two elementary $\Sigma$-protocols over an elliptic curve group of prime order, written here in multiplicative notation:
\begin{enumerate}
	\item A proof of knowledge of discrete logarithm with respect to a fixed group generator: given a group element $u$, the proof convinces a verifier that the prover knows $x$ such that $u=g^x$, where $g$ is the group generator (also known as base point), without revealing $x$. This is the Schnorr signature with public key $u$ and is essentially the protocol given in Section~\ref{intro:sigma}. 
	We call this primtive \texttt{proveDLog}$(u)$. Note that there is a default generator $g$ in the method. 
	

	\item A proof of equality of discrete logarithms (i.e., a proof of a Diffie-Hellman tuple): given group elements $g, h, u, v$, the prover, Alice convinces a verifier Bob that she knows $x$ such that $u={g}^x$ and $v={h}^x$. This is done by extending the protocol of Section~\ref{intro:sigma} as follows. 
	\begin{enumerate}
		\item \textbf{Commit:} Alice picks $r \stackrel{R}{\leftarrow} \mathbb{Z}_q$, computes $(t_0, t_1) = ({g}^r, {h}^r)$ and sends $(t_0, t_1)$ to Bob.
		\item \textbf{Challenge:} Bob picks $c \stackrel{R}{\leftarrow} \mathbb{Z}_q$ and sends $c$ to Alice.
		\item \textbf{Response:} Alice computes $z = r + cx$ and sends $z$ to Bob, who accepts if ${g}^z = {t_0}\cdot {u}^c$ and $h^z=t_1\cdot v^c$. % for $b \in \{0,1\}$.
	\end{enumerate}
	
	We use the non-interactive variant of this protocol, where $c = H(t_0 \Vert t_1)$. We call this primitive \texttt{proveDHTuple}$(g, h, u, v)$.
	%This can also be used in a DDH-easy group. 
	
\end{enumerate}


\subsection{Complex $\Sigma$-Protocols}

Any two $\Sigma$-protocols of propositions $\tau_0, \tau_1$ with messages $(t_0, c_0, z_0), (t_1, c_1, z_1)$ respectively can be combined into a $\Sigma$-protocol of $\tau_0 \land \tau_1$ with messages $(t, c, z) = (t_0\Vert t_1,c_0\Vert c_1, c_0\Vert c_1)$. We call such a construction an $\andnode$ operator on the protocols. 
More interestingly, as shown in \cite{CDS94},the two protocols can also be used to construct a $\Sigma$-protocol for $\tau_0\lor \tau_1$, where Alice proves knowledge of the witness of one proposition, without revealing which. Let $b\in \{0, 1\}$ be the bit such that Alice knows the witness for $\tau_b$ but not for $\tau_{1-b}$. Alice will run the correct protocol for $\tau_b$ and a simulation for $\tau_{1-b}$. First she generates a random challenge $c_{1-b}$. She then generates $(t_{1-b}, z_{1-b})$ by using the simulator on $c_{1-b}$. She also generates $t_b$ by following the protocol correctly. The pair $(t_0, t_1)$ is sent to Bob, who responds with a challenge $c$. Alice then computes $c_b = c\oplus c_{1-b}$. She computes $z_b$ using $(t_b, c_b)$. Her response to Bob is $((z_0, c_0), (z_1, c_1))$, who accepts if: (1) $c = c_0 \oplus c_1$ and (2) $(t_0, c_0, z_0), (t_1, c_1, z_1)$ are both accepting convesations for $\tau_0, \tau_1$ respectively. We call such a construction an $\ornode$ operator. 

Clearly, both the $\andnode$ and $\ornode$ operators also result in $\Sigma$-protocols that can be further combined or made non-interactive via the Fiat-Shamir transform. 

There is one more operator that we need called $\tnode$, which allows us to construct a $k$-out-of-$n$ $\Sigma$-protocol~\cite{CDS94} as follows. Given $n$ propositions, Alice can prove knowledge of witnesses for at least $k$ propositions without revealing which. 

\langname gives the ability to build more sophisticated $\Sigma$-protocols using the connectives $\andnode$, $\ornode$, and $\tnode$. 
Crucially, the proof for an $\ornode$ and a $\tnode$ connective does not reveal which of the relevant values the prover knows. For example, in \langname a ring signature by public keys $u_1, \dots, u_n$ can be specified as an $\ornode$ of $\Sigma$-protocols for proving knowledge of discrete logarithms of $u_1, \dots, u_n$. The proof can be constructed with the knowledge of just one such discrete logarithm, and does not reveal which one was used in its construction. 

\subsection{Other Features of \langname} 

%Rich context, enabling self-replication
In addition to $\Sigma$-protocols, \langname allows for predicates over the state of the blockchain and the current transaction. These predicates can be combined, via Boolean connectives, with $\Sigma$-statements, and are used during transaction validation. The set of predicates is richer than in Bitcoin, but still lean in order to allow for efficient processing even by light clients. Like in Bitcoin, we allow the use of current height of the blockchain; unlike Bitcoin, we also allow the use of information contained in the spending transaction, such as inputs it is trying to spend and outputs it is trying to create. This feature enables self-replication and sophisticated (even Turing-complete) long-term script behaviour, as described in examples below.

%\langname is statically typed (with compile-time type checking) and allows the usual operations, such as integer arithmetic.

%\snote{This seems incomplete. In particular, we should describe all context variables and operations allowed, possibly using BNF or some grammar.}


%\paragraph{Running time estimation and safety checks}
%\lnote{someone should fill this in, because I know very little about it}
%See Section \ref{sec:safety} for more details.

The most fundamental primitive in \langname is a \emph{box}, which is roughly like a UTXO of Bitcoin. Each transaction spends (destroys) some boxes by using them as inputs and creates new boxes as outputs. A box is a data structure made of upto ten {\em registers} labelled $R_0, R_1,\ldots R_9$, four of which are mandatory. 
$R_0$ contains the monetary value of the box. $R_1$ contains the script protecting the box, $R_2$ contains assets 

The following sections present \langname examples in Scala. The full code corresponding to the snippets below is available at the \langname code repository~\cite{langrepo}. 
Since \langname syntax is identical to Scala's, \langname code is highlighted like \Hi{\texttt{this}} to avoid confusion. 
%The examples use the protocol concepts defined in Appendix~\ref{ergo:internals}. 
%To do: add appendix explaining box structure, how a tx is formed, etc. For now refer to yellow paper
\section{Basic Examples: Addressing Bitcoin's Limitations}
We present some examples showing how \langname is superior to Bitcoin's script. The examples use P2SH address and each example highlights a limitation of Bitcoin. 

\subsection{Short-lived Unconfirmed Transactions: Paying for Coffee}

%We give another application of \langname contracts by constructing {\em timed payments}. 
Suppose you are paying for coffee using cryptocurrency. You make a payment but it is taking a long time for the transaction to confirm. You decide to pay using cash and leave. However, you are worried that your original payment will eventually confirm and then you will either lose it or have to ask for a refund. In bitcoin, you can try to double spend the transaction, which is not very convenient or sure, even if using {\em replace-by-fee}. \langname has a better solution using {\em timed-payments} so that if the transaction is not confirmed before a certain height, it is no longer valid. Timed-payments require that funds be stored in a {\em timed address}, which is created as follows. 

%Assume \texttt{bob} is the coffee shop public key and Alice is the customer paying for coffee.
Alice encodes her public key \texttt{alice} inside environment \texttt{env} and creates a script \texttt{aliceScript}:
\begin{alltt}
	val aliceScript = compile(env, """ \Hi{\{alice && HEIGHT <= getVar[Int](1).get\}}""")
\end{alltt}

Alice's address is computed as: \texttt{val aliceAddress = Pay2SHAddress(aliceScript)}. Any funds deposited to \texttt{aliceAddress} can only be spent if the spending transaction satisfies following:
\begin{enumerate}
	\item Context variable with id 1 of the box being spent must contain an integer, say $i$.
	\item The height at mining should be less than or equal to $i$. 
\end{enumerate}

Observe that if the transaction is not mined before height $i$ then the transaction becomes invalid. When paying at a coffee shop, for example, Alice can set $i$ close to the height $h$ at the time of broadcast, for instance, $i = h + 10$. 
Alice can still send non-timed payments by making $i$ very large. Since the context variables are part of the message in constructing the zero-knowledge proof, a miner cannot change it (to make this transaction valid). 

\subsection{Preventing Theft using Reversible Addresses}

We create a useful primitives called {\em reversible addresses}, which have anti-theft features in the following sense:
any funds sent to a reversible address can only be spent using a {\em reversible transaction}. That is, transactions spending funds from such an address must create outputs that allow funds to be reversed for a certain time. The idea was proposed for Bitcoin~\cite{raddress} (using the moniker {\em R-addresses}) and requires a hardfork. In \langname, however, this can be done natively.

To motivate this feature, consider managing the hot-wallet of a mining pool or an exchange. Funds withdrawn by customers originate from this hot-wallet. Being a hot-wallet, its private is succeptible to compromise. One day you discover several unauthorized transactions from the hot-wallet, indicating a breach. You wish there was a way to reverse the transactions and cancel the withdraws but alas this is not the case. In general there is no way to recover the lost funds once the transaction is mined, even if the breach was discovered within minutes. The irreversibility of fund transfers, usually considered a feature, has now become a bug.

We would like that in the event of such a compromise, we are able to save all funds stored in this wallet and move them to another address, provided that the breach is discovered within a specified time (such as 24 hours) of the first unauthorized withdraw. 

To achieve this, we require that all coins sent from the hot-wallet (both legitimate and by the attacker)
have a 24 hour cooling-off period, during which the created UTXOs are ``locked'' and can only be spent by a trusted private key that is was selected {\em before} the compromise occurred. This trusted key must be different from the hot-wallet private key and should ideally be in cold storage. 
After 24 hours, these UTXOs become `normal' and can only be spent by the receiver.

This is done by storing the hot-wallet funds in a special type of address denoted as {\em reversible}. Assume that \texttt{alice} is the public key of the hot-wallet and \texttt{carol} is the public key of the trusted party.\footnote{The trusted party must be decided at the time of address generation and cannot be changed later. To use a different trusted party, a new address has to be generated.} Let \texttt{blocksIn24h} be the estimated number of blocks in a 24 hour period. A reversible address is a P2SH\footnote{As in Bitcoin, a P2SH (Pay to Script Hash) address is created from the hash of a script encoding spending conditions for any UTXOs controlled by that address.} address whose script encodes the following conditions:   
\begin{enumerate}
	\item This input box can only be spent by \texttt{alice}.
	\item Any output box created by spending this input box must have in its register \texttt{R5} a number at least \texttt{blocksIn24h} more than the current height. 
	\item Any output box created by spending this input box must be protected by a script requring the following: 	
	\begin{enumerate}
		\item Its register \texttt{R4} must have an arbitrary public key called \texttt{bob}.'' 
		\item Its register \texttt{R5} must have an arbitrary integer called \texttt{bobDeadline}.'' 
		\item It can only be spent spent by \texttt{carol} if \texttt{HEIGHT $\leq$ bobDeadline}.''
		\item It can only be spent by \texttt{bob} if \texttt{HEIGHT $>$ bobDeadline}.''	
	\end{enumerate}  
\end{enumerate}

Thus, all funds sent from such addresses have a temporary lock of \texttt{blocksIn24h} blocks. This can be replaced by any other desired value but it must be decided at the time of address generation. All hot-wallet funds must be stored in and sent from the above safe address only. 

Let \texttt{bob} be the public key of a customer who is withdrawing. The sender (\texttt{alice}) must ensure that register \texttt{R4} of the created UTXO contains \texttt{bob}. In the normal scenario, \texttt{bob} will be able to spend the UTXO after \texttt{blocksIn24h} blocks (with the exact number depending on \texttt{bobDeadline}). 

If an unauthorized transaction is detected from \texttt{alice}, an ``abort procedure'' is triggered via \texttt{carol}: all funds sent from \texttt{alice} currently in the locked state are suspect and need to diverted elsewhere. Additionally, UTXOs currently controlled by \texttt{alice} also need to be sent secure addresses. 

Note that such reversible addresses are designed for storing large amount of funds needed for automated withdraws (such as an exchange hot-wallet). They are not designed for storing funds for personal use (such as paying for a coffee). 

Concretely, such an address is created as follows. First hardcode \texttt{carol} inside \texttt{withdrawEnv}. Then create a script and compile it to get its binary version called \texttt{withdrawScript}:
\begin{alltt}
val withdrawScript = compile(withdrawEnv, """ \Hi{\{}
  \Hi{val bob         = SELF.R4[SigmaProp].get // public key of customer withdrawing}
  \Hi{val bobDeadline = SELF.R5[Int].get       // max locking height}
  \Hi{(bob && HEIGHT > bobDeadline) || (carol && HEIGHT <= bobDeadline) \}} """)
\end{alltt}

Let \texttt{feePropositionBytes} be the script for a box that pays mining fee and \texttt{maxFee} be the maximum fee allowed in one transaction. 
Compute \texttt{hash = Blake2b256(withdrawScript)}. Set these values along with \texttt{alice} and \texttt{blocksIn24h} in \texttt{depositEnv} to create a compiled script: % called \texttt{depositScript}:

%\begin{alltt}
%	val depositScript = compile(depositEnv, """ \Hi{\{}
%  \Hi{val validChange = \{(out:Box) => out.propositionBytes == SELF.propositionBytes\}}
%  \Hi{val validWithdraw = \{(out:Box) => out.R5[Int].get >= HEIGHT + blocksIn24h && }
%                                    \Hi{blake2b256(out.propositionBytes) == hash\}}
%  \Hi{val validOut = \{(out:Box) => validChange(out) || validWithdraw(out)\}}
%  \Hi{alice && OUTPUTS.forall(validOut) \}} """)
%\end{alltt}
%
%
%val isChange = {(b:Box) => b.propositionBytes == SELF.propositionBytes}
%val isWithdraw = {(b:Box) => b.R5[Int].get >= HEIGHT + blocksIn24h &&
%	blake2b256(b.propositionBytes) == withdrawScriptHash}
%val isFee = {(b:Box) => b.propositionBytes == feePropositionBytes}
%val isValidOut = {(b:Box) => isChange(b) || isWithdraw(b) || isFee(b)}
%
%val totalFee = OUTPUTS.fold(0L, {(acc:Long, b:Box) => if (b.propositionBytes == feePropositionBytes) acc + b.value else acc })
%val totalFeeAlt = OUTPUTS.fold(0L, {(acc:Long, b:Box) => if (isFee(b)) acc + b.value else acc })
%
%// alice && OUTPUTS.forall(isValidOut) && totalFee <= maxFee // works
%alice && OUTPUTS.forall(isValidOut) && totalFeeAlt <= maxFee // gives error

\begin{alltt}
val depositScript = compile(depositEnv, """ \Hi{\{}
  \Hi{val isChange = \{(out:Box) => out.propositionBytes == SELF.propositionBytes\}}
  \Hi{val isWithdraw = \{(out:Box) => out.R5[Int].get >= HEIGHT + blocksIn24h &&}
                                 \Hi{blake2b256(out.propositionBytes) == hash\}}
  \Hi{val isFee = \{(out:Box) => out.propositionBytes == feePropositionBytes\}}
  \Hi{val isValid = {(out:Box) => isChange(out) || isWithdraw(out) || isFee(out)}}
  \Hi{val fee = OUTPUTS.fold(0L, \{(x:Long, b:Box) => if (isFee(b)) x + b.value else x \})}
  \Hi{alice && OUTPUTS.forall(isValid) && totalFee <= maxFee \}} """)
\end{alltt}

Finally, the reversible address is computed as: \texttt{Pay2SHAddress(depositScript)}.

\subsection{Cold-Wallet Contracts}

Assume an address is protected by 2 private keys, corresponding to the public keys \texttt{alice} and \texttt{bob}. For security, we want the following conditions to hold:

\begin{enumerate}
	\item One key can spend at most 1\% or 100 Ergs (whichever is higher) in one day.
	\item If both keys are spending then there are no restrictions. 
\end{enumerate}

Let \texttt{blocksIn24h} be the number of blocks in 24 hours. Instead of hardwiring 1\% and 100 Ergs, we will use the variables \texttt{percent} and \texttt{minSpend} respectively. Set all these parameters in environment \texttt{env} along with the public keys \texttt{alice} and \texttt{bob} to get a compiled script:
\begin{alltt}
val script = compile(env, """ \Hi{\{}
  \Hi{val depth = HEIGHT - SELF.creationInfo._1 // number of confirmations}
  \Hi{val start = min(depth, SELF.R4[Int].get) // block at which the period started}
  \Hi{val notExpired = HEIGHT - start <= blocksIn24h // expired if 24 hrs passed}  
  \Hi{val min = SELF.R5[Long].get // min Balance needed in this period}

  \Hi{val ours:Long = SELF.value - SELF.value * percent / 100}
  \Hi{val keep = if (ours > minSpend) ours else 0L // topup should keep min >= keep}  
  \Hi{val nStart:Int = if (notExpired) start else HEIGHT}
  \Hi{val nMin:Long = if (notExpired) min else keep}
  
  \Hi{val valid = INPUTS.size == 1 && OUTPUTS.exists(\{(out:Box) =>}
    \Hi{out.propositionBytes == SELF.propositionBytes &&}
    \Hi{out.value >= nMin && out.R4[Int].get >= nStart && out.R5[Long].get == nMin\})}
    
  \Hi{(alice && bob) || (min >= keep && (alice || bob) && (nMin == 0 || valid))\}} """)

\end{alltt}
 
Finally compute the deposit address of the wallet as \texttt{val address = Pay2SHAddress(script)}. %Any funds deposited to this address can only be spent using the script given above. 
Spending from this address is done in periods of 24 hours or more (but never less) such that in any one period, the maximum spendable is a fixed fraction of the amount at the beginning of the period. We do this requiring the spending transaction to have an output paying back to the address with value greater than the minumum (stored in \texttt{R5}). The start of the current period is stored in \texttt{R4}. Both registers are copied to the new output within the same period and get new values for if the current period has expired.


%\subsection{Advanced Cold-Wallet Contracts}
%
%We can extend the 2-party cold-wallet contract by adding a third party and the following conditions:
%
%\begin{enumerate}
%	\item One key can spend at most 1\% or 100 Ergs (whichever is higher) in one day.
%	\item For two keys the amount is 10\% or 1000 Ergs (whichever is higher).
%	\item If all three two keys are spending then there are no restrictions. 
%\end{enumerate}


\section{Advanced Examples: Two-party Protocols}

We focus on two-round, two-party protocols. %That is, protocols with two parties that can be performed in two transactions. 
In the first round, the first party, Alice, initiates the protocol by creating a box  protected by a script encoding the protocol rules. In the second round, the second party, Bob, completes the protocol by spending Alice's box usually with one of his own and creating additional boxes that encode the final state of the protocol. 

All the protocols here allow the first round to be offchain in the sense that Alice's box creation may be deferred until the time Bob actually participates in the protocol. Alice instead sends her box-creation transaction to Bob, who will then publish both transactions at a later time. 
\subsection{The XOR Game}

We describe a simple game called ``Same or Different'' or the XOR game. Alice and Bob both submit a coin each and select a bit independently. If the bits are same, Alice gets both coins, else Bob gets both coins. The game requires 3 transactions (steps). 
\begin{enumerate}
	\item Alice commits to a secret bit $a$ as follows. She selects a random bit-string $s$ and computes her commitment $k = H(s\|a)$ (i.e., hash after concatenating $s$ with $a$).
	
	She creates an unspent box called the {\em half-game output} containing her coin and commitment $k$. This box is protected by a script called the {\em half-game script}  given below. Alice waits for another player to join her game, who will do so by spending her half-game output and creating another box that satisfies the conditions given in the half-game script. Alice can also spend the half-game output herself before anyone joins, effectively aborting the game. 
	
	\item Bob decides to join Alice's game. He generates a random bit $b$ and spends Alice's half-game output alongwith one of his own to create a new box called the {\em full-game output}. This new box  holds two coins and contains $b$ (in the clear) alongwith Bob's public key in the registers. 
	Note that the full-game output must satisfy the conditions given by the half-game script. In particular, one of the conditions requires that the full-game output must be protected by the {\em full-game script} (given below).
	\item Alice opens $k$ by revealing $s, a$. If $a = b$ then Alice wins else Bob wins. The winner spends the full-game output using his/her private key and providing $s$ and $a$ to the full-game script.

	If Alice fails to open $k$ within a specified deadline (say 30 blocks after the full-game output is created) then Bob automatically wins. 
\end{enumerate}

The full-game script encodes the following conditions: The registers \texttt{R4}, \texttt{R5} and \texttt{R6} are expected to store Bob's bit $b$, Bob's public key (stored as a \texttt{ProveDLog} proposition) and the deadline for Bob's automatic win respectively. The context variables with id 0 and 1 (provided at the time of spending the full-game box) contain $s$ and $a$ required to open Alice's commitnent $k$, which is hardwired alongwith Alice's public key \texttt{alice} via the environment \texttt{env}. 
%The remaining part encodes the spending conditon of full-game box. 
Alice compiles the full-game script to get a binary representation of its \langname code: 

\begin{alltt}
val fullGameScript = compile(env, """ \Hi{\{}
  \Hi{val s     = getVar[Coll[Byte]](0).get // bit string s}
  \Hi{val a     = getVar[Byte](1).get       // bit a (represented as a byte)}
  \Hi{val b     = SELF.R4[Byte].get         // bit b (represented as a byte)}
  \Hi{val bob   = SELF.R5[SigmaProp].get    // Bob's public key}
  \Hi{val bobDeadline = SELF.R6[Int].get}
   
  \Hi{(bob && HEIGHT > bobDeadline) || }
  \Hi{(blake2b256(s ++ Coll(a)) == k && (alice && a == b || bob && a != b)) \}} """)
\end{alltt}

Then a hash of the above compiled script is computed:

\begin{verbatim}
  val scriptHash = Blake2b256(fullGameScript)
\end{verbatim}

Finally, Alice sets \texttt{scriptHash} as an environment variable for the compiler and creates her half-game output with the following spending condition:

\begin{alltt}
  \Hi{val out           = OUTPUTS(0)}
  \Hi{val b             = out.R4[Byte].get}
  \Hi{val bobDeadline   = out.R6[Int].get}
  \Hi{val validBobInput = b == 0 || b == 1}

  \Hi{validBobInput && blake2b256(out.propositionBytes) == scriptHash &&}
  \Hi{OUTPUTS.size == 1 && bobDeadline >= HEIGHT+30 && out.value >= SELF.value * 2 }
\end{alltt}

The above script requires that the transaction spending the half-game box must generate exactly one output box with the following properties:

\begin{enumerate}
	\item Its value must be at least twice that of the half-game box.
	\item Its register \texttt{R4} must contain a byte that is either 0 or 1. This encodes Bob's choice $b$.
	\item Its register \texttt{R6} must contain an integer that is at least 30 more than the height at which the box is generated. This will correspond to the height at which Bob automatically wins.
	\item It must be protected by a script whose hash equals \texttt{scriptHash}.
\end{enumerate}
 
The game ensure security and fairness as follows. Since Alice's choice is hidden from Bob when he creates the full-game output, he does not have any advantage in selecting $b$. Secondly, Alice is sure to lose if she commits to a value other than 0 or 1. Finally, if Alice refuses to open her commitment, then Bob is sure to win after about 30 blocks. 
\subsection{Rock-Paper-Scissors Game}

Compared to Rock-Paper-Scissors (RPS), the XOR game is simpler (and efficient) because there is no draw condition and for this reason should be prefered in practice. However, it is useful to consider the RPS game as an example of more complex protocols.

Let $a, b\in \mathbb{Z}_3$ be the choices of Alice and Bob, with the understanding that 0, 1 and 2 represent rock, paper and scissors respectively. If $a = b$ then the game is a draw, otherwise Alice wins if $a-b \in \{1, -2\}$ else Bob wins. The game is similar to XOR, except that Bob must now generate two outputs. In the draw case each player gets one output, otherwise the winner gets both. 
As before, Alice's commitment $k=H(a||s)$ and public key \texttt{alice} is given via \texttt{env} to the compiler	:

\begin{alltt}
val fullGameScript = compile(env, """ \Hi{\{}
  \Hi{val s = getVar[Coll[Byte]](0).get  // Alice's secret byte string s}
  \Hi{val a = getVar[Byte](1).get  // Alice's secret choice a (represented as a byte)}
  \Hi{val b = SELF.R4[Byte].get    // Bob's public choice b (represented as a byte)}
  \Hi{val bob = SELF.R5[SigmaProp].get}
  \Hi{val bobDeadline = SELF.R6[Int].get // after this, it becomes Bob's coin}
  \Hi{val drawPubKey = SELF.R7[SigmaProp].get}
  \Hi{val valid_a = (a == 0 || a == 1 || a == 2) && blake2b256(s ++ Coll(a)) == k}

  \Hi{(bob && HEIGHT > bobDeadline) || \{ valid_a &&}
    \Hi{if (a == b) drawPubKey}
    \Hi{else \{ if ((a - b) == 1 || (a - b) == -2) alice else bob \}\}\}} """)
\end{alltt}

The code is derived from the XOR game by adding \texttt{drawPubKey}. A hash of the above script is computed as \texttt{val scriptHash = Blake2b256(fullGameScript)} for use in the half-game script:

\begin{alltt}
\Hi{OUTPUTS.forall\{(out:Box) =>}
  \Hi{val b             = out.R4[Byte].get}
  \Hi{val bobDeadline   = out.R6[Int].get}

  \Hi{bobDeadline >= HEIGHT+30 && out.value >= SELF.value &&}
  \Hi{(b == 0 || b == 1 || b == 2) && blake2b256(out.propositionBytes) == scriptHash}
\Hi{\} && OUTPUTS.size == 2 && OUTPUTS(0).R7[SigmaProp].get == alice }
\end{alltt}

% // Bob needs to ensure that out.R5 contains bobPubKey

The above code ensures that \texttt{R7} of the first output contains Alice's public key (for the draw scenario). Bob should ensure that \texttt{R7} of the second output contains his public key. Additionally, he must ensure that \texttt{R5} of both outputs contains his public key.

\subsection{A Mixing Protocol}
\label{mix}

We describe a mixing protocol called \mixname, whose security depends on the hardness of the {\em Decision Diffie-Hellman} (DDH) Problem in $G$. 
%Because of the DDH-hard requirement, we must ensure that the underlying group does not support an efficient bilinear pairing (which makes the DDH easy). 
The protocol is motivated from ZeroCoin~\cite{zerocoin} (ZC) to overcomes some of its drawbacks (discussed later). 
%Since \mixname depends on the hardness of the DDH problem, it cannot be used on groups that support an efficient bilinear pairing (where this problem is easy).
%The name \mixname is a portmanteau of {\em Two} and {\em Mix}. 
\mixname essentially mixes two coins and so provides ``50\% anonymity'' in one round. A coin is successively mixed to increase the anonymity to any desired level (say 99.99999\%). 

\mixname has a pool, called the {\em Half-Mix} pool (H-pool), which contains coins ready for mixing. 
To mix an arbitrary non-H-pool coin $B$ (which could itself be the output of a previous mix), any one of the two actions can be performed:
\begin{enumerate}
	\item Pick a coin $A$ from the H-pool (if it is non-empty) and convert $(A, B)$ to two indistinguisble coins $\{O_A, O_B\}$, each spendable by their respective owner. Note that the original boxes $A, B$ are destroyed. Thus, $A$ is removed from the H-pool. We call this the {\em mix} operation. 
	\item Add coin $B$ to the H-pool and wait for someone to use it in mix. This is the {\em pool} operation.
\end{enumerate}

 Without loss of generality, Alice will pool and Bob will mix. In practice, each coin must go through multiple stages of mix, with the choice of going via pool randomly decided after each mix.

\begin{enumerate}
	\item \textbf{Pool:} To add a coin to the H-pool, Alice picks random generator $g\in G$ and $x\in \mathbb{Z}_q$. Let $u = g^{x}$. Alice creates an output box $A$ containing $(g, u)$ and protected by the script given below. She waits for Bob to join by spending $A$ subject to the conditions given in the script. 
	Alice's spending condition for $A$ is that any transaction spending $A$ should be as follows: 
	
	\begin{enumerate}
		\item It has two inputs of equal value, one of which is $A$. %The value of the second input should be the same as in $A$. 
		\item It has two outputs $(O_0, O_1)$ with data tuples $(g, c_1, u, c_2)$ and $(g, c_2, u, c_1)$ respectively. That is, the data of each output contains a 4-tuple where the first and third elements are $g$ and $u$ respectively and the second and fourth elements are swapped. 
		\item The spender of $A$ must satisfy $\texttt{proveDHTuple}(g, u, c_1, c_2)\lor \texttt{proveDHTuple}(g, u, c_2, c_1)$.
		\item The outputs should be protected by the script $\tau_\textsf{A} \lor \tau_\textsf{B}$ given in the Mix step below.
	\end{enumerate}
	
	
	\item \textbf{Mix:} Bob randomly picks a Half-Mix box from the H-pool, for instance, $A$. Bob then picks a random secret bit $b \in \mathbb{Z}_2$ and spends $A$ with another of his own unspent box $B$. The spending transaction creates two new unspent boxes $O_0, O_1$ of equal values (and indistinguishable) such that $O_b$ is spendable only by Alice and $O_{1-b}$ is spendable only by Bob. This is done as follows:
	
	\begin{enumerate}
		\item Bob picks secret $y\in \mathbb{Z}_q$. Let $h = {g}^{y}$ and $v = {u}^{y}$.  %Let $c_b = g^y$ and $c_{1-b} = g^{xy}$. Bob 
		The box $O_b$ contains data $(g, h, u, v)$ and $O_{1-b}$ contains $(g, v, u, h)$. If the DDH problem in $G$ is hard, the distributions $(g, {g}^{y}, {g}^{x}, {g}^{xy})$ and 
		$(g, {g}^{xy}, {g}^{x}, {g}^{y})$ are computationally indistinguishable. In other words, without knowledge of $x$ or $y$, one cannot guess $b$ with probability better than $1/2$.
		\item  Let 
		$\tau_\textsf{A}$ be the proposition: ``Parse data as $(g, h, u, v)$ and
		prove knowledge of $x$ such that $u = {g}^{x}$ and ${v} = {h}^{x}$.'' This is encoded as $\texttt{proveDHTuple}(g, h, u, v)$.
		
		\item Let $\tau_{\textsf{B}}$ be the proposition: ``Parse data as $(g, *, *, h)$ and
		prove knowledge of $y$ such that $h = {g}^{y}$.'' 
		%		Observe that $h, v$ have been swapped from $\tau_\textsf{A}$. 
		This is encoded as $\texttt{proveDlog}(h)$, keeping $g$ as the default generator.
		
		\item Each box is protected by the proposition $\tau_\textsf{A} \lor \tau_\textsf{B}$. 
		
	\end{enumerate}

%	\item \textbf{Spend:} Alice and Bob spent their respective boxes using their secrets, possibly sending funds back to the pool or mix stages. Bob already knows which coin belongs to him. For each output, Alice will parse the data as $(g, h, u, v)$ and select the one with $v = h^x$. 
\end{enumerate}
	After the mix, Alice and Bob can spent their respective boxes using their secrets. 
%	Bob already knows which box belongs to him. For each output, 
	Alice will parse the data of both boxes as $(g, h, u, v)$ and select the one with $v = h^x$. 

\textbf{\langname Code:} First define two variables representing $g$ and $g^x$. Lets call them \texttt{g} and \texttt{gX} respectively. Then pass them to the compiler via an environment variable, say \texttt{env}:

\begin{alltt}
val fullMixScript = compile(env, """ \Hi{\{}
  \Hi{val c1 = SELF.R4[GroupElement].get}
  \Hi{val c2 = SELF.R5[GroupElement].get}
  \Hi{proveDlog(c2) || proveDHTuple(g, c1, gX, c2) \}} """)
\end{alltt}

Compute a hash of the above script: \texttt{val fullMixScriptHash = Blake2b256(fullMixScript)}
Alice's Half-Mix box is protected \texttt{halfMixScript} containing the following code:

\begin{alltt}
	\Hi{val c1 = OUTPUTS(0).R4[GroupElement].get}
	\Hi{val c2 = OUTPUTS(0).R5[GroupElement].get}
	
	\Hi{OUTPUTS(0).value == SELF.value && OUTPUTS(1).value == SELF.value &&}
	\Hi{blake2b256(OUTPUTS(0).propositionBytes) == fullMixScriptHash &&}
	\Hi{blake2b256(OUTPUTS(1).propositionBytes) == fullMixScriptHash &&}
	\Hi{OUTPUTS(1).R4[GroupElement].get == c2 && OUTPUTS(1).R5[GroupElement].get == c1 &&}
	\Hi{OUTPUTS.size == 2 && (proveDHTuple(g, gX, c1, c2) || proveDHTuple(g, gX, c2, c1))}
\end{alltt}

\textbf{Security:} We claim the security of the protocol based on the following reasoning. Before spending, the outputs are indistinguisble under the DDH assumption. Since they are both spent using a $\Sigma$-OR-proof, their indistinguishability is preserved. Also, Alice can spend exactly one output, since the other one does not contain a valid DDH tuple. Similarly, Bob can spend exactly one output, since he does not know the discrete log of $g^{xy}$ to base $g$. The output that Bob can spend is exactly the one that Alice cannot. Finally, note that Bob cannot generate invalid outputs since he must prove that they are of the correct form. 

\textbf{Comparing with ZeroCash:} Both \mixname and ZeroCash (ZC) are based on zero-knowledge proofs and use an anonymizing pool. The difference is that the size of our pool depends on the number of unspent outputs, while that of ZC depends on the number of deposits, which is monotonously increasing. Additionally, the size of proofs in \mixname is constant, unlike ZC, where the proof size is logarithmic to the pool size. Finally, unlike ZC, the proofs in \mixname do not rely on expensive NP-reductions and are instead based on a number theoretic problem. This makes \mixname far more scalable than ZC. 

\textbf{Offchain Pool:} As mentioned earlier, Alice's Half-Mix box can be stored off-chain till the mixing step. Alice sends her unbroadcasted transaction directly to Bob who will broadcast both Half and Full mix transactions after the mix step. It will be interesting to have a variant of the protocol where both Alice and Bob add their Half-Mix coins to an offchain H-Pool and a 3rd party combines them without interacting with Alice or Bob. 

\textbf{Handling Fee:} To ensure perfect privacy and fairness, each output must have a fixed value and zero fee. However, zero-fee transactions are not practical. We describe below a few approaches to deduct fee. 
%a combination of which may be used. 
Assume that fee is paid in tokens\footnote{Tokens are additional assets stored in register R3 of a box as a collection of (token-ID, quantity) pairs. Every transaction may generate at most one token-ID of arbitrary quantity, where token-ID is the box-ID of the first input. For any other token-ID, the sum of quantities in outputs must be less or equal to the sum of quantities in inputs.} for transactions mined by some 3rd party. 

 A straightforward method of handling fee is as follows. Alice's Half-Mix box contains $i$ such tokens and requires each output box of the mix to contain exactly $i-1$ tokens. This allows Alice to mix her coin $i$ times, which is optimal and fair. However, this has two drawbacks. Firstly, it has weakened privacy because it restricts which coins can be mixed. Secondly, it impacts usability because there may not be any available boxes with the desired number of tokens. %The following tweaks to the basic protocol can be used to overcome these drawbacks. 
 
 In the {\em approximate fairness} strategy, Bob mixes by picking from the H-pool a box with token quantity ``closer'' to that of his own non-H-pool box. He will generate two outputs with equal amount of tokens after deducting fee. Alice's script could encode the maximum allowed difference in tokens. In the worst case, Alice will have to start with $2^i$ tokens to mix $i$ times.
 
 Starting with a fixed number of tokens restricts the number of mixes. To allow arbitrary number of mixes, we suggest a {\em fee accumulation} strategy, where the fee is accumulated rather than paid upfront. %For instance, fee for the mix transaction can be paid when spending the mixed outputs. 	
The fee keeps accumulating as long as the coin is circulated within the system (i.e., sent back to the H-pool or used in another mix operation) and is paid when the coin exits the system.

 The accumulated fee of a mix transaction is the sum of accumulated fee of the inputs plus mining fee, and in the most basic variant, is equally shared between the two mixed outputs.
 We can enhance this with the {\em first spender pays} strategy, where the first party to spend a mixed output takes the entire burden of the accumulated fee. 
 Below we describe how to identify the first spender.
 % This is achieved as follows:
 
 \textbf{Identifying the first spender:} A mix transaction must generate exactly 4 quantities of a new token (with some id $x$) distributed equally among 4 output boxes. Of these, two are the standard mix outputs $O_0, O_1$ with the additional spending condition that one output must contain some amount of token $x$. The other two boxes, $O_2, O_3$, have the following identical spending conditions:
		\begin{enumerate}
			\item The sum of quantities of token $x$ in the inputs and outputs is 3 and 2 respectively.
			\item One output contains 2 quantities of token $x$ and is protected by the same script as this box. 
		\end{enumerate}
	
Clearly, the first spender must spend both $O_2, O_3$ and generate a new box with 2 quantities of token $x$ that is spendable only by the second spender. 
Thus, anyone spending $O_0$ or $O_1$ is the second spender if and only if there exists an input box with two quantities of token $x$. 

%further improvements. Can we reduce offchain data size, do multiple mixes offchain?

\subsection{Identifying Protocol Transactions}

Consider the approximate fairness strategy of \mixname encoded in \texttt{halfMixScript} as follows:
\begin{enumerate}
	\item The current input and at least one other input have at least one mixing token each.
	\item A mix transaction uses two tokens and the balance is equally distributed in the two outputs.
	
\end{enumerate}


Assume that each party joins the protocol by purchasing 1000 mixing tokens. This will give about 10 sequential mixes in the worst case. In the ideal world, however, if Alice and Bob join by contributing 1000 tokens each and slowly use them up in subsequent mixes with other people, we expect that they should be able to do substantially higher number of mixes. To achieve this in the real world, we would like to ensure that if a party is contributing, say, 50 mixing tokens, then they actually got there `the hard way', by performing several sequential mixes and not just by starting out with 50. 
%Thus, coins with lower number of mixing tokens should have a higher {\em mix value}. 
One way to achieve this would via tokens with the following two properties. 

\textbf{Restricted transfer:} The tokens are transferrable only within the system as a whole. % (after deducting fee). 
This is enforced as follows. 
%Thus, the tokens of a fully mixed output are transferrable only if the coin is either sent back to the H-pool or used as an input in another mix transaction. 
%In particular, we need to identify the following cases within \texttt{fullMixScript} code: 
%	\begin{enumerate}
%		\item The output is a Half-Mix box (i.e., a single output protected by \texttt{halfMixScript})
%		\item This is a mix transaction (i.e., the first input is protected by \texttt{halfMixScript}). 
%	\end{enumerate}
%Otherwise the tokens are destroyed. 
Firstly, ensure that nothing is hardcoded in the scripts. Thus, \texttt{gX} must be read from a register in both \texttt{fullMixScript} and \texttt{halfMixScript}. Using the first available register, this is R6 in \texttt{fullMixScript} and R4 in \texttt{halfMixScript}. Additionally, \texttt{halfMixScript} must ensure that the correct \texttt{gX} is copied in the corresponding register (i.e., R6) of a mixed output. 

Secondly, modify \texttt{halfMixScript} to contain the following code for checking each output \texttt{out}: 
\texttt{\Hi{out.R7[Coll[Byte]].get == blake2b256(SELF.propositionBytes)}}, thereby ensuring that R7 of a fully mixed output contains the hash of \texttt{halfMixScript}. Finally, extend \texttt{fullMixScript}:

\begin{alltt}
\Hi{val halfMixScriptHash = SELF.R7[Coll[Byte]].get} 
\Hi{val isHalf = blake2b256(OUTPUTS(0).propositionBytes) == halfMixScriptHash &&}
             \Hi{OUTPUTS(0).tokens(0) == SELF.tokens(0)}
\Hi{val isFull = blake2b256(INPUTS(0).propositionBytes) == halfMixScriptHash} 
\Hi{val isNone = OUTPUTS.forall\{(b:Box) => }
  \Hi{b.tokens.forall\{(t:(Coll[Byte], Long)) => t._1 != SELF.tokens(0)._1\}\}} 
\Hi{(isFull || isHalf || isNone) && ... // existing condition} 
\end{alltt}

\textbf{Restricted entry:} The issuer only sells tokens in batches of 1000. The tokens are stored at the first index of a box protected by a script requiring they must be transferred as a whole, and only if the transaction is either a Full-Mix transaction or creates a Half-Mix box. 

\begin{alltt}
\Hi{val isHalfMixBox = \{(b:Box) => }
  \Hi{blake2b256(OUTPUTS(0).propositionBytes) == halfMixScriptHash\}}
  
\Hi{isHalfMixBox(INPUTS(0)) || (isHalfMixBox(OUTPUTS(0)) &&}
 \Hi{OUTPUTS.size == 1 && OUTPUTS(0).tokens(0) == SELF.tokens(0))}
\end{alltt}


%The spending condition of a fully mixed box is as follows:

%In any two-round two-party protocol, we may want to identify which box(es) of the second round are spent in creating reused in the protocol. need to identify which boxes are part of the  stay within the protocol , for example, in \mixname in practice, we mayidentify where we want to accumulate fee as long as the coin does not leave the system, In particular, we need to identify the mixed outputs that are either sent back to the H-pool or used as an input in another Full-Mix transaction.
%
%This problem can be formulated more generally for any arbitrary two-round two-party protocol with the first round box protected by script \texttt{firstRoundScript} and the second round box protected by \texttt{secondRoundScript}, such that $Hash(\texttt{secondRoundScript})$ is used to create \texttt{firstRoundScript}. When running \texttt{secondRoundScript}, that is, when spending the second round box, we want to
%determine if at least one the following cases is true: 
%\begin{enumerate}
%	\item The output is a first round box (i.e., protected by \texttt{firstRoundScript})
%	\item The output is a second round box, and another input is a first round box. 
%\end{enumerate}
%
%Clearly, such a requirement is non-trivial because the second round script references the first round script and the first round script needs $Hash(\texttt{secondRoundScript})$. However, \langname allows us to achieve this by giving us the ability to run arbitrary code not known at compile time using the \texttt{executeFromVar} and \texttt{executeFromReg} instructions.
%We describe how do this for \mixname. However, the ideas are general enough to be applied to any protocol. 
%
%The scripts cannot have keys hardcoded. Thus, \texttt{gX} must be read from a register in both \texttt{fullMixScript} and the code in Alice's Half-Mix box, which we call \texttt{halfMixScript}. Let it be R6 in \texttt{fullMixScript} and R4 in \texttt{halfMixScript}
%Additionally, \texttt{halfMixScript} should ensure that the correct \texttt{gX} is copied in the corresponding register (i.e., R6) of each mixed output. Compute the hash: \texttt{val halfMixScriptHash = blake2b256(halfMixScript)} for use below. 
%
%One register of each box stores \texttt{scriptHash}, the hash of some script to be supplied later. Let it be R7 in \texttt{fullMixScript} and R5 in \texttt{halfMixScript}. Additionally, \texttt{halfMixScript} must ensure that the appropriate register (i.e., R7) of each mixed output also contains this hash. 
%
%We now extend \texttt{fullMixScript} with the code:
%
%\begin{alltt}
%	\Hi{val scriptHash = SELF.R7[Coll[Byte]].get}
%	\Hi{val script = getVar[Coll[Byte]](1).get}
%	\Hi{val protocolTx = blake2b256(script) == scriptHash && executeFromVar(1)}
%\end{alltt}
%
%The instruction \texttt{executeFromVar(1)} reads the first context variable as a script, executes it in the current context and returns the result. We will use \texttt{protocolTx} to identify if a mixed output is spent in a pool or another mix transaction. Add both \texttt{halfMixScriptHash} and \texttt{fullMixScriptHash} to environment \texttt{env} and compute: \texttt{val scriptHash = blake2b256(script)}, where \texttt{script} is:
%
%\begin{alltt}
%val script = compile(env, """ \Hi{\{ val scriptHash = SELF(0).R7[Coll[Byte]].get}
%
%  \Hi{val isFullTx = OUTPUTS.size == 2 && INPUTS.size == 2 &&}
%                 \Hi{blake2b256(OUTPUTS(0).propositionBytes) == fullMixScriptHash &&}
%                 \Hi{blake2b256(OUTPUTS(1).propositionBytes) == fullMixScriptHash &&}
%                 \Hi{blake2b256(INPUTS(0).propositionBytes) == halfMixScriptHash &&}
%                 \Hi{OUTPUTS(0).R7[Coll[Byte]].get == scriptHash &&}
%                 \Hi{OUTPUTS(1).R7[Coll[Byte]].get == scriptHash &&}
%                 \Hi{INPUTS(0).R5[Coll[Byte]].get == scriptHash}
%
%  \Hi{val isHalfTx = OUTPUTS.size == 1 && INPUTS.size == 1 &&}
%                 \Hi{blake2b256(OUTPUTS(0).propositionBytes) == halfMixScriptHash &&}
%                 \Hi{OUTPUTS(0).R5[Coll[Byte]].get == scriptHash}
%	
%  \Hi{isHalfTx || isFullTx \}} """)
%  
%\end{alltt}
%
%The Half-Mix box is created with \texttt{scriptHash} stored in its register R4. 
%%The spending condition of a fully mixed box is as follows:

 
\bibliographystyle{unsrt}
\bibliography{sigmastate_protocols}
\end{document}