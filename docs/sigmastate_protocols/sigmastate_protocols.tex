\documentclass[11pt]{article}

\def\shownotes{1}
\def\notesinmargins{0}

\usepackage{fullpage}

\usepackage{mathtools,color,xcolor,hyperref,graphicx,wrapfig,listings,array,xspace}

\usepackage{amsfonts}

\ifnum\shownotes=1
\ifnum\notesinmargins=1
\newcommand{\authnote}[2]{\marginpar{\parbox{\marginparwidth}{\tiny %
  \textsf{#1 {\textcolor{blue}{notes: #2}}}}}%
  \textcolor{blue}{\textbf{\dag}}}
\else
\newcommand{\authnote}[2]{
  \textsf{#1 \textcolor{blue}{: #2}}}
\fi
\else
\newcommand{\authnote}[2]{}
\fi

\newcommand{\lnote}[1]{{\authnote{\textcolor{orange}{Leo notes}}{#1}}}
\newcommand{\snote}[1]{{\authnote{\textcolor{yellow}{Scalahub notes}}{#1}}}
\newcommand{\knote}[1]{{\authnote{\textcolor{green}{kushti notes}}{#1}}}
\newcommand{\mnote}[1]{{\authnote{\textcolor{red}{Morphic}}{#1}}}
\newcommand{\dnote}[1]{{\authnote{\textcolor{brown}{Dima notes}}{#1}}}

\newcommand{\ret}{\mathsf{ret}}
\newcommand{\new}{\mathsf{new}}
\newcommand{\hnew}{h_\mathsf{new}}
\newcommand{\old}{\mathsf{old}}
\newcommand{\op}{\mathsf{op}}
\newcommand{\verifier}{\mathcal{V}}
\newcommand{\prover}{\mathcal{P}}
\newcommand{\key}{\mathsf{key}}
\newcommand{\nextkey}{\mathsf{nextKey}}
\newcommand{\node}{\mathsf{t}}
\newcommand{\parent}{\mathsf{p}}
\newcommand{\leaf}{\mathsf{f}}
\newcommand{\vl}{\mathsf{value}}
\newcommand{\balance}{\mathsf{balance}}
\newcommand{\lft}{\mathsf{left}}
\newcommand{\rgt}{\mathsf{right}}
\newcommand{\lbl}{\mathsf{label}}
\newcommand{\direction}{\mathsf{d}}
\newcommand{\oppositedirection}{\bar{\mathsf{d}}}
\newcommand{\found}{\mathsf{found}}
\newcommand{\mypar}[1]{\smallskip\noindent\textbf{#1.}\ \ \ }
\newcommand{\ignore}[1]{}

\newcommand{\langname}{ErgoScript\xspace}
\newcommand{\mixname}{Twix\xspace}

\newcommand{\lst}[1]{\text{\lstinline[basicstyle={\ttfamily}]$#1$}}

\newcommand{\andnode}{\ensuremath{\mathsf{AND}}}
\newcommand{\ornode}{\ensuremath{\mathsf{OR}}}
\newcommand{\tnode}{\ensuremath{\mathsf{THRESHOLD}}}
\newcommand{\GF}{\ensuremath{\mathrm{GF}}}


\begin{document}

\title{\langname Overview (working title)}

\author{authors}


\maketitle


\begin{abstract}
This paper describes uses \langname to design games and mixing protocols
\end{abstract}
\section{Overview of \langname}

\paragraph{Built-in $\Sigma$-protocols}
Our language incorporates proofs as first-class citizens, giving developers access to cryptographic primitives for non-interactive {\em proofs of knowledge} known as $\Sigma$-protocols (pronounced ``sigma-protocols''). A transaction's output is protected by a statement known as a $\Sigma$-statement. In order to spend the output, the statement needs to be proven true (by providing a $\Sigma$-proof). The combination of the protecting script and the spending proof forms a $\Sigma$-protocol.

\subsection{Sigma Protocols}
For an introduction to $\Sigma$-protocols, we refer the reader to \cite{Dam10} and \cite[Chapter 6]{HL10}. Here we give a brief overview. The classic example a $\Sigma$-proof is the following 3-step identification protocol due to~\cite{Sch91}. $G$ is a cyclic multiplicative group of prime order $q$ such that computing discrete logarithms in $G$ is hard. Let $g$ be a generator of $G$. Alice has a secret $x \in \mathbb{Z}_q$, which she wants to prove knowledge of to some Bob who knows $y = g^x$.
\begin{enumerate}
	\item \textbf{Commit:} Alice selects a random $r$, computes $u = g^r$ and sends $u$ to Bob.
	\item \textbf{Challenge:} Bob selects a random $c\in\mathbb{Z}_q$ and sends $c$ to Alice.
	\item \textbf{Response:} Alice computes $z = r + cx$ and sends $z$ to Bob. Bob accepts iff $g^z = u\cdot y^c$.
\end{enumerate}

The above protocol is a proof of knowledge because Bob can extract $x$ if he can get Alice to respond twice for the same $r$ and different $c$. As an example, for $c = 1, 2$, Bob can obtain $r+x$ and $r+2x$, the difference of which gives $x$. This is also called (special) soundness. Above protocol is also (honest verifier) zero-knowledge because anyone can impersonate Alice if the challenge $c$ of Step 2 is known in advance simply by computing $z \stackrel{R}{\leftarrow} \mathbb{Z}_q$ and $u = g^z/y^c$. 

Any protocol that has the above 3-move structure (Alice $\stackrel{u}{\rightarrow}$ Bob, Alice $\stackrel{c}{\leftarrow}$ Bob, Alice $\stackrel{z}{\rightarrow}$ Bob), along with zero-knowledge and soundness property for some statement $s$ is called a $\Sigma$-protocol. 

\subsection{Non-Interactive Sigma Protocols}
For any $\Sigma$-protocol of some statement $s$ with messages $(u, c, z)$, we can apply the Fiat-Shamir transform to convert it into a non-interactive proof of $s$ by replacing the role of Bob in Step 2 by any hash function $H$ and computing $c$ = $H(u)$. The resulting protocol with messages $(u, H(u), z)$ can be performed by Alice alone. Intuitively, since $c$ depends deterministically on $u$, Bob cannot ``rewind'' Alice and get two different responses for the same $r$. Additionally, Alice cannot know $c$ in advance before deciding $u$ under the random oracle assumption. 

\subsubsection{Digital Signatures from Sigma Protocols}
\label{digital-sig}
Conceptually, $\Sigma$-proofs \cite{Cra96} are generalizations~\cite{CL06} of digital signatures.
In fact, Schnorr signature scheme~\cite{Sch91} (whose more recent version is popularly known as EdDSA \cite{BDLSY12,rfc8032}) is a special case of the above identification protocol with $c = H(u \Vert m)$, where $m$ is the message. The signature proves that the recipient knows the discrete logarithm of the public key (the proof is attached to a specific message, such as a particular transaction, and thus becomes a signature on the message; all $\Sigma$-proofs described here are attached to specific messages). $\Sigma$-protocols exist for proving a variety of properties and, importantly for \langname, elementary $\Sigma$-protocols can be combined into more sophisticated ones using the techniques of \cite{CDS94}. 

\subsection{Combining Sigma Protocols}

Any two $\Sigma$-protocols of statements $s_0, s_1$ with messages $(u_0, c_0, z_0), (u_1, c_1, z_1)$ respectively can be combined into a $\Sigma$-protocol of $s_0 \land s_1$ with messages $(u, c, z) = (u_0\Vert u_1,c_0\Vert c_1, c_0\Vert c_1)$. We call such a construction an $\andnode$ operator on the protocols. %Such a protocol proves both statements simultaneously. 

More interestingly, as shown in \cite{orprotocol},the two protocols can also be used to construct a $\Sigma$-protocol for $s_0\lor s_1$, where Alice proves knowledge of the witness of one of the statements without revealing which one. Let $b\in \{0, 1\}$ be the bit such that Alice knows the witness for $s_b$ but not for $s_{1-b}$. Alice will run the correct protocol for $s_b$ and a simulation for $s_{1-b}$. First she generates a random challenge $c_{1-b}$. She then generates $(u_{1-b}, z_{1-b})$ by using the simulator on $c_{1-b}$. She also generates $u_b$ by following the protocol correctly. The pair $(u_0, u_1)$ is sent to Bob, who responds with a challenge $c$. Alice then computes $c_b = c\oplus c_{1-b}$. She computes $z_b$ using $(u_b, c_b)$. Her response to Bob is $((z_0, c_0), (z_1, c_1))$, who accepts if: (1) $c = c_0 \oplus c_1$ and (2) $(u_0, c_0, z_0), (u_1, c_1, z_1)$ are both accepting convesations for $s_0, s_1$ respectively. We call such a construction an $\ornode$ operator. 

Clearly, both the $\andnode$ and $\ornode$ operators also result in $\Sigma$-protocols that can be further combined or made non-interactive via the Fiat-Shamir transform. 

There is one more operator that we need called $\tnode$, which allows us to construct a $k$-out-of-$n$ $\Sigma$-protocol in the following sense~\cite{threshold}: given $n$ statements, Alice can prove knowledge of witnesses for at least $k$ statements without revealing which statements were true. 

\snote{Describe Threshold briefly}
\section{Primitives in ErgoScript}

\langname provides as primitives two elementary $\Sigma$-protocols over an elliptic curve group of prime order, written here in multiplicative notation:
\begin{enumerate}
\item A proof of knowledge of discrete logarithm with respect to a fixed group generator: given a group element $y$, the proof convinces a verifier that the prover knows $x$ such that $y=g^x$, where $g$ is the group generator (also known as base point), without revealing $x$. This is the Schnorr signature with public key $y$, described in Section~\ref{digital-sig}.
We call this primtive \texttt{ProveDLog}$(g, y)$.
 
\snote{What is the exact input to the hash function? (what forms the message?)}

\item A proof of equality of discrete logarithms (i.e., a proof of a Diffie-Hellman tuple): given group elements $g_0, y_0, g_1, y_1$, the prover, Alice convinces a verifier Bob that she knows $x$ such that $y_0={g_0}^x$ and $y_1={g_1}^x$, without revealing $x$. This is done as follows. 
\begin{enumerate}
	\item \textbf{Commit:} Alice picks $r \stackrel{R}{\leftarrow} \mathbb{Z}_q$, computes $(u_0, u_1) = ({g_0}^r, {g_1}^r)$ and sends $(u_0, u_1)$ to Bob.
	\item \textbf{Challenge:} Bob picks $c \stackrel{R}{\leftarrow} \mathbb{Z}_q$ and sends $c$ to Alice.
	\item \textbf{Response:} Alice computes $z = r + cx$ and sends $z$ to Bob, who accepts if ${g_b}^z = {u_b}\cdot {y_b}^c$ for $b \in \{0,1\}$.
\end{enumerate}

We use the non-interactive variant of this protocol, where the challenge is computed as $c = H(u_0 \Vert u_1)$. We call this primitive \texttt{ProveDLogEq}$(g_0, y_0, g_1, y_1)$.%This can also be used in a DDH-easy group. 

\snote{What is the exact input to the hash function?}

\end{enumerate}

\langname gives the ability to build more sophisticated $\Sigma$-protocols using the connectives $\andnode$, $\ornode$, and $\tnode$. 
Crucially, the proof for an $\ornode$ and a $\tnode$ connective does not reveal which of the relevant values the prover knows. For example, in \langname a ring signature by public keys $y_1, \dots, y_n$ can be specified as an $\ornode$ of $\Sigma$-protocols for proving knowledge of discrete logarithms of $y_1, \dots, y_n$. The proof can be constructed with the knowledge of just one such discrete logarithm, and does not reveal which one was used in its construction. 

%Our implementation of these protocols is in Scala \cite{scala} and Java \cite{java}. The implementation was informed by SCAPI \cite{scapi}, but does not use SCAPI code. \lnote{our code currently has subdirectories named ``scapi'' so it's hard to say we don't use it\dots} We use Bouncy Castle \cite{bouncycastle} for big integer and elliptic curve operations; the implementation of arithmetic in fields of characteristic 2 (for $\tnode$ connectives) is our own. \lnote{any other credits or background info?}

\paragraph{Rich context, enabling self-replication}
In addition to $\Sigma$-protocols, \langname allows for predicates over the state of the blockchain and the current transaction. These predicates can be combined, via Boolean connectives, with $\Sigma$-statements, and are used during transaction validation. The set of predicates is richer than in Bitcoin, but still lean in order to allow for efficient processing even by light clients. Like in Bitcoin, we allow the use of current height of the blockchain; unlike Bitcoin, we also allow the use of information contained in the spending transaction, such as inputs it is trying to spend and outputs it is trying to create. This feature enables self-replication and sophisticated (even Turing-complete) long-term script behaviour, as described in examples below.

\langname is statically typed (with compile-time type checking) and allows the usual operations, such as integer arithmetic.

\snote{This seems incomplete. In particular, we should describe all context variables and operations allowed, possibly using BNF or some grammar.}


\paragraph{Running time estimation and safety checks}
\lnote{someone should fill this in, because I know very little about it}
See Section \ref{sec:safety} for more details.

\section{\langname Examples}

We give some examples of \langname to illustrate its usage. 
\subsection{Reversible Payments}

Often lack of reversibility is considered a weak point of Bitcoin. We give a protocol that allows reversible payments in Ergo. The payments are reversible for a limited time, which we call the cooling off period. Let $pk_\textsf{A}$ be the public key of someone who can reverse payments. This public key can (and should) be different from the sender of the payment. Let $pk_{\textsf{B}}$ be the recipient of the payment. The sender will create the output with the following spending condition:

 $$(pk_\textsf{A}\land \texttt{depth <= coolingPeriod}) \lor (pk_\textsf{B}\land \texttt{depth > coolingPeriod})$$
 
 \snote{This requires a `depth' instruction, which is current not present. Depth is simply current height - inclusion height.}
\subsection{The XOR Game}

We describe a simple game called ``Same or different'' or the XOR game. Alice and Bob both select a secret bit and submit a coin each. They then reveal their secret bits. If the bits are same, Alice gets both coins, else Bob gets both coins. The game requires at least 3 transactions. 
\begin{enumerate}
	\item Alice commits to a secret bit $a$ as follows. She selects a random string $s$ and computes her commitment $h = H(s\|a)$ (i.e., hash after concatenating $s$ with a string representation of $a$).
	
%	generates $a\in \mathbb{Z}_q$ and computes $h = H(a)$. We consider Alice's choice to be $\textsf{True}$ if $a < q/2$, and $\textsf{False}$ otherwise. 
	
	She adds her commitment $h$ along with her coin protected by secret $x_0$ and public $y_0 = g^{x_0}$. This creates an unspent Box by Alice. She waits for some Bob to join the game by spending this output subject to certian conditions given by the {\em firstRoundScript} (see below). Alice can spend the box if no one joins within 100 blocks. 
%	\item Alice generates $a\in \mathbb{Z}_q$ and computes $h = H(a)$. We consider Alice's choice to be $\textsf{True}$ if $a < q/2$, and $\textsf{False}$ otherwise. She adds her commitment $h$ along with her coin protected by secret $x_0$ and public $y_0 = g^{x_0}$. This creates an unspent Box by Alice. She waits for some Bob to join the game by spending this output subject to certian conditions (see below). Alice can spend the box if no one joins within 100 blocks. 
	\item Bob generates bit $b\in \{0,1\}$ and adds it (in the clear) along with his coin protected by secret $x_1$ and public $y_1 = g^{x_1}$. He does this by spending Alice's box with one of his own and creating a new Box containing both coins along with Alice's commitment $h$ and his own bit $b$. Lets call this an intermediate box. Note that the transaction must satisfy the conditions given by {\em firstRoundScript}. In particular, one of the instructions in this script requires that the output must be protected by {\em secondRoundScript} (also given below).
	\item Alice opens $h$ by revealing $s$ somehow (either privately to Bob or publicly). If Alice fails to reveal $a$ within 100 blocks of creating the intermediate box then Bob automatically wins and gets to spend the intermediate box. %We consider Alice's choice to be $\textsf{True}$ if $a < q/2$, and $\textsf{False}$ otherwise. 
	Anyone with knowledge of $s$ can send the price to the winner by inputting $a$ to {\em secondRoundScript}. 
	
%	\item Alice opens $h$ by revealing $a$ somehow (either privately or via the blockchain). If Alice fails to reveal $a$ within 100 blocks of creating the intermediate box then Bob automatically wins and gets to spend the intermediate box. We consider Alice's choice to be $\textsf{True}$ if $a < q/2$, and $\textsf{False}$ otherwise. The winner claims the prize by inputting $a$ to the script. 
\end{enumerate}

		%INPUTS.size == 2 && INPUTS(0).value == INPUTS(1).value && INPUTS(0).propositionBytes == pkA.propBytes,
		
The script {\em secondRoundScript} is given by the following conditions:
\begin{enumerate}
	\item The first free register (R4) is assumed to be Bob's input $b$ (boolean).
	\item The second free register (R5) contains Bob's public key. 
	\item If the block height is more than 100 then Bob's public key can spend.
	\item The first typed variable (obtainable via \texttt{getVar(0)}) must be Alice's secret $s$.
	\item The second typed variable (obtainable via \texttt{getVar(1)}) must be Alice's choice $a$ (boolean).
	\item Commitment must be correctly opened (i.e., $H(s\|a)$ must equal $h$).
	\item If $(a == b)$ then Alice can spend else Bob can spend.	
\end{enumerate}

% More security conditions:
% The spender must not give a high fee. We can also say that the winner must be spender. This is more complex but will be a good example.
% 
This is encoded in out Scala program as follows: 

\begin{verbatim}
{
val secondRoundScript = Compile( // Can this be implemented?
"""val hash = INPUTS(0).R4 // Alice's original commitment
val bobsBit = INPUTS(0).R5 // Boolean, Bob's public bit
val aliceBytes = getVar[Array[Byte]](0) // Alice's open commitment, a 256 bit integer
val correctlyOpened = sha256(aliceBytes) == hash 
val equals = bobsBit == aliceBytes(0) > 0  // use the LSB of aliceBytes
(correctlyOpened && 
(
(pkA && equals) || 
(pkB && !equals)
)
) || 
(pkB && txHeight > 100)"""
)

val pkA = // Alice's public key. Can we extract it from INPUT(0).propositionBytes ? 
val pkB = // Bob's public key. Can we extract it from INPUT(1).propositionBytes ?
val b = getVar[Boolean](0) // Bob's public bit

(pkA && txHeight > 100) || {
INPUTS.size == 2 && 
INPUTS(0).value == INPUTS(1).value && 
INPUTS(0) == SELF &&
OUTPUTS.size == 1 &&
OUTPUTS(0).R4 == INPUTS(0).R4 && // Copy Alice's commitment hash to output
OUTPUTS(0).R5 == b 
OUTPUTS(0).propositionBytes == outProp
}
\end{verbatim}


Alice creates her coin with the following spending condition in the output:

\begin{verbatim}
  {
    val outProp = Compile( // Can this be implemented?
     """val hash = INPUTS(0).R4 // Alice's original commitment
        val bobsBit = INPUTS(0).R5 // Boolean, Bob's public bit
        val aliceBytes = getVar[Array[Byte]](0) // Alice's open commitment, a 256 bit integer
        val correctlyOpened = sha256(aliceBytes) == hash 
        val equals = bobsBit == aliceBytes(0) > 0  // use the LSB of aliceBytes
        (correctlyOpened && 
           (
              (pkA && equals) || 
              (pkB && !equals)
           )
        ) || 
        (pkB && txHeight > 100)"""
    )

    val pkA = // Alice's public key. Can we extract it from INPUT(0).propositionBytes ? 
    val pkB = // Bob's public key. Can we extract it from INPUT(1).propositionBytes ?
    val b = getVar[Boolean](0) // Bob's public bit

    (pkA && txHeight > 100) || {
      INPUTS.size == 2 && 
      INPUTS(0).value == INPUTS(1).value && 
      INPUTS(0) == SELF &&
      OUTPUTS.size == 1 &&
      OUTPUTS(0).R4 == INPUTS(0).R4 && // Copy Alice's commitment hash to output
      OUTPUTS(0).R5 == b 
      OUTPUTS(0).propositionBytes == outProp
    }
\end{verbatim}

%\begin{verbatim}
		%INPUTS.size == 2 && 
		%INPUTS(0).value == INPUTS(1).value && 
		%INPUTS(0) == SELF &&
		%OUTPUTS.size == 1 &&
		%OUTPUTS(0).R3 == INPUTS(0).R3 &&
		%OUTPUTS(0).R4 == INPUTS(1).R3 &&
		%OUTPUTS(0).propositionBytes = COMPILE{ // hypothetical function
		  %"INPUTS.size == 1 &&
		   %sha256(INPUTS(0).R5) == INPUTS(0).R3 && 
		   %sha256(INPUTS(0).R6) == INPUTS(1).R4 &&"
			%
		%}
		%{
		 %{ 
       %pkA && 
       %SELF.R3 < q/2 == SELF.R4 < q/2
		 %} ||
		 %{
       %pkB && 
       %SELF.R3 < q/2 != SELF.R4 < q/2
		 %}
		%} 		
%\end{verbatim}
%

%
%Let us try to describe this in Ergo. Let $g, h$ be two public parameters 
%Public parameters: Let g, h be two public generators such that DLog h to base g is unknown (that is, g and h are two random elements of group).
%We commitment to a secret bit is as follows:
%Choose a large secret x. If committing to 0, compute c = g^x else compute c = h^x. 
%In summary to commit to bit b, compute c = g^((1-b)x).h^(bx)
%The commitment is c. In order to open c, we simply reveal x. The scheme is perfectly hiding. Note that commitment must open to either 0 or 1 else its an invalid commitment and coin is unusable. 
%Alice first creates input with 1 coin and commitment C_A and conditions as follows:
%{ // normal protocol
%Let Bob (an arbitrary key) input 1 coin and commitment C_B in future before height 100
	%Let Alice open commitment C_A to bit a
	%Let Bob open commitment C_B to bit b
	%if (a == b) Alice can spend both coins else Bob can spend both coins
%}
%// error protocol
%If Alice does not open within 10 blocks when she has to then Bob gets both coins
%If Alice’s commitment opens to something other than 0 or 1 then Bob gets both coins
%If Bob does not open within 10 blocks when he has to then Alice gets both coins
%If Bob’s commitment opens to something other than 0 or 1 then Alice gets both coins
%If no Bob joins before height 100 then Alice can withdraw (spend) her coin
%
%So it’s like a “game pool”, with two different types of inputs:
%Input type 1: a party can put their coins and wait for other party to join. 
%Input type 2: If coins already in pool, the party can join existing game 
%


\subsection{The Mixing Protocol}

We now describe a mixing protocol for Ergo called \mixname, which is motivated from ZeroCash (ZC). 
The name \mixname is a portmanteau of {\em Two} and {\em Mix}. 
\mixname essentially mixes two coins and so provides ``50\% anonymity'' in one mix. A coin can be successively mixed to increase the anonymity above any desired level (say 99.99999\%). We do a formal analysis of the protocol later. 

\mixname is based on the UTXO model. Like ZC, \mixname uses pooled coins for mixing. Unlike ZC, however, \mixname has two UTXO pools for providing anonymity: a {\em half-mixed} pool ($H$) and a {\em fully-mixed} pool ($F$). The $F$ pool contains coins that are anonymized. There is also the standard pool ($S$) that contains UTXOs for ordinary spending without any anonymity. The goal of the protocol is to move coins from $O$ to $F$ (possibly via $H$) and after sufficient mixing, back to $O$. The protocol contains the following transactions. 
\begin{enumerate}
	\item \textbf{Half-mix:} This takes one coin from either $O$ or $F$ and puts it in $H$.
	\item \textbf{Full-mix:} This takes one coin from $H$, the other from either $O$ or $F$ and puts both coins in $F$ such that it is impossible (for outsiders) to distinguish them.
	\item \textbf{Spend:} This takes one coin from $F$ and either puts it in $O$.% or $H$.
		
\end{enumerate}
To participate in the mix, a user can may either add an unspent coin to the pool (which can be an output of a previous mix operation), or below operations anyone can add coins to this unspent pool. 
tained. Anyone can deposit ordinary currency, say Ethers
(ETH) to the 2C pool and later withdraw from it at a 1:1
exchange rate. The key difference is that the size of the 2C
pool depends on
Twix attempts to fix some of its drawbacks discussed below. Like 
We describe Two-Coin, a cryptocurrency for enhancing pri-
vacy of trancactions. Two-Coin (2C), like Zero-Coin (ZC)
uses zero-knowledge proofs but is more storage efficient than
ZC. Similar to ZC, in 2C a pool of anonymous coins is main-
tained. Anyone can deposit ordinary currency, say Ethers
(ETH) to the 2C pool and later withdraw from it at a 1:1
exchange rate. The key difference is that the size of the 2C
pool depends on the number of unspent coins rather than
number of deposited coins (as in ZC). This greatly enhances
the scalability, while keeping anonymity at similar levels. In
2C, each unspent coin can be spent twice, hence the name
(a withdraw is treated similar to a spend). Once a coin has
been spent twice, it is removed from the pool. Thus, un-
like ZC, a 2C pool does not have a monotonously increasing
set. In practice, we can replace zero-knowledge proofs with
zk-SNARKS at the cost of lower security.
\begin{enumerate}
	\item ZeroCash requires a pool of mixed coins, whose size increases monotonously. Once a coin is added to the pool, it  
	
\end{enumerate}

The idea of Twix is quite general and can be implemented in other platforms. In Ergo, however, the protocol can be used without any additional platform support. 


There is a pool of unmixed coins where anyone can add theirs.

The protocol is as follows:
%The game requires at least 3 transactions. 

\begin{enumerate}
	\item \textbf{Pool:} To add a coin to the pool, Alice picks random generator $g_\textsf{A}\in G$ and $x_\textsf{A}\in \mathbb{Z}_q$. Let $y_\textsf{A} = {g_\textsf{A}}^{x_\textsf{A}}$. Alice creates an output box $A$ containing $(g_\textsf{A}, y_\textsf{A})$ and protected by the script given below. She waits for Bob to join by spending $A$ subject to the conditions given in the script. Alice can spend $A$ if no one joins within 100 blocks. 
	\item \textbf{Mix:} Bob randomly picks one unspent box from the pool, for instance, $A$. Bob then picks a random secret bit $b$ and spends $A$ with another of his own unspent box $B$. The spending transaction creates two new unspent boxes $O_0, O_1$ of equal values such that $C_b$ is spendable only by Alice and $C_{1-b}$ is spendable only by Bob. This is done as follows:
	
	\begin{enumerate}
		%\item Bob selects a secret bit $b$. Then output $O_b$ is spendable by Bob alone, while $O_{1-b}$ is spendable by Alice alone. %Lets call these the intermediate boxes. 
		
		\item Bob picks secret $x_\textsf{B}\in \mathbb{Z}_q$. Let $g_\textsf{B} = {g_\textsf{A}}^{x_\textsf{B}}$ and $y_\textsf{B} = {y_\textsf{A}}^{x_\textsf{B}} = {g_\textsf{A}}^{x_\textsf{A}x_\textsf{B}}~(={g_\textsf{B}}^{x_\textsf{A}})$.  %Let $c_b = g^y$ and $c_{1-b} = g^{xy}$. Bob 
		The box $O_b$ contains the tuple $(g_\textsf{A}, y_\textsf{A}, g_\textsf{B}, y_\textsf{B})$ and $O_{1-b}$ contains $(g_\textsf{A}, y_\textsf{A}, y_\textsf{B}, g_\textsf{B})$. Assuming that the {\em Decision Diffie-Hellman Problem} in $G$ is hard, the distributions $(g_\textsf{A}, {g_\textsf{A}}^{x_\textsf{A}}, {g_\textsf{A}}^{x_\textsf{B}}, {g_\textsf{A}}^{x_\textsf{A}x_\textsf{B}})$ and $(g_\textsf{A}, {g_\textsf{A}}^{x_\textsf{A}}, {g_\textsf{A}}^{x_\textsf{A}x_\textsf{B}}, {g_\textsf{A}}^{x_\textsf{B}})$ are computationally indistinguishable. In other words, without knowledge of $x_\textsf{A}$ or $x_\textsf{B}$, one cannot guess $b$ with probability better than $1/2$.
		\item  Let 
		$s_\textsf{A}$ be the statement: ``For given $(g_\textsf{A}, y_\textsf{A}, g_\textsf{B}, y_\textsf{B})$ 
		prove knowledge of $x_\textsf{A}$ such that $y_\textsf{A} = {g_\textsf{A}}^{x_\textsf{A}}$ and ${y_\textsf{B}} = {g_\textsf{B}}^{x_\textsf{A}}$.'' This is encoded as $$s_\textsf{A} = (g_\textsf{A}, y_\textsf{A}, g_\textsf{B}, y_\textsf{B}) \mapsto \texttt{ProveDLogEq}(g_\textsf{A}, y_\textsf{A}, g_\textsf{B}, y_\textsf{B}).$$
		
		\item Let $s_{\textsf{B}}$ be the statement: ``For given $(g_\textsf{A}, y_\textsf{A}, y_\textsf{B}, g_\textsf{B})$
		prove knowledge of $x_\textsf{B}$ such that $g_\textsf{B} = {g_\textsf{A}}^{x_\textsf{B}}$ and $y_\textsf{B} = {y_\textsf{A}}^{x_\textsf{B}}$.''  This is encoded as $$s_\textsf{B} = (g_\textsf{A}, y_\textsf{A}, y_\textsf{B}, g_\textsf{B}) \mapsto \texttt{ProveDLogEq}(g_\textsf{A}, g_\textsf{B}, y_\textsf{A}, y_\textsf{B}).$$
			Observe that the order of $g_\textsf{B}, y_\textsf{B}$ is reversed from $s_\textsf{A}$.
		\item Each box is protected by the statement $s_\textsf{A} \lor s_\textsf{B}$. 
		
	\end{enumerate}
	Alice's spending condition for $A$ is that the transaction should be as follows: 
	
	\begin{enumerate}
		\item It should contain two inputs, the first of which is $A$. The value of the second input should be the same as in $A$. 
		\item It should contain exactly two outputs $(O_0, O_1)$ of the form $(g_\textsf{A}, y_\textsf{A}, c_0, c_1)$ and $(g_\textsf{A}, y_\textsf{A}, c_1, c_0)$ respectively;
		\item It The spender must satisfy $\texttt{ProveDLogEq}(g_\textsf{A}, c_0, y_\textsf{A}, c_1)\lor \texttt{ProveDLogEq}(g_\textsf{A}, c_1, y_\textsf{A}, c_0)$.
		\item The outputs should be protected by the script 
		%Additionally, the spending condition for $O_0, O_1$ is $s_\textsf{Alice}(g_A, y_A, c_0, c_1) \lor s_\textsf{Bob}(g_A, y_A, c_0, c_1)$.
\end{enumerate}
	\item \textbf{Spend:} Both Alice and Bob later spent their respective boxes using their secrets. 
\end{enumerate}


\end{document}